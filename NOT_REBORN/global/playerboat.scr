main local.name local.model local.origin local.angles local.health local.vehiclespeed local.resettime local.scale local.gotout local.door_open:

	if(local.model == NIL) { wait 1; println("----- ERROR playerboat.scr: 'model' parameter is missing!"); end }
	if(local.model[0] != "m" && local.model[1] != "o" && local.model[2] != "d" && local.model[3] != "e" && local.model[4] != "l" && local.model[5] != "s")
	{
		local.model = "models/" + local.model
		if(local.model == "models/vehicles/higgins.tik") { local.model = "models/vehicles/higginsxtrahull.tik" }
		if(level.vehiclescriptmaster[local.model] != 1) { cache local.model }
	}

	if($(local.name) != NULL) 
	{
		waitframe; if($(local.name) != NULL) { waitframe; if($(local.name) != NULL) { waitframe; if($(local.name) != NULL) { waitframe; if($(local.name) != NULL) { waitframe } } } }
		if($(local.name) != NULL)
		{
			if(level.vehiclescriptmaster[local.model] != 1) { wait 1; println("----- ERROR playerboat.scr: $" + local.name + " must be removed before spawning a drivable boat.") }
			end
		}
	}

	if(local.health == NIL || (local.health != NIL && local.health <= 0 && level.vehiclescriptmaster[local.model] != 1)) { wait 1; println("----- ERROR playerboat.scr: health must be greater than 0."); end }
	if(local.health == NIL || (local.health != NIL && local.health <= 0 && level.vehiclescriptmaster[local.model] == 1)) { end } // end when in rare cases, a 2nd vehicle with local.health = 0 could spawn after getting destroyed

	if(local.model == "models/vehicles/higginsxtrahull.tik") { local.desmodel = models/vehicles/higgins_damage.tik }

	local.vehicle = spawn local.model targetname (local.name) // scriptmasters are already added in ubersound.scr
	local.vehicle.name = local.name
	local.vehicle.origin = local.origin
	local.vehicle.angles = local.angles
	local.vehicle.desmodel = local.desmodel
	local.vehicle.health = local.health
	local.vehicle.vehiclespeed = local.vehiclespeed
	local.vehicle.vehiclespeed_max = local.vehiclespeed
	local.vehicle.resettime = local.resettime
	if(local.scale == NIL || local.vehicle.model != "models/vehicles/uboat.tik") { local.vehicle.scale = 1 }
	else
	{
		local.vehicle.scale = local.scale
		local.vehicle setsize ( -(2000 * local.scale) -(150 * local.scale) 0 ) ( (1820 * local.scale) (150 * local.scale) (140 * local.scale) )
	}

	if(local.vehicle.classname != "DrivableVehicle") { local.vehicle remove; wait 1; println("----- ERROR playerboat.scr: .tik model is not a DrivableVehicle."); end }

	local.vehicle turnrate 5; local.vehicle.turningrate = 5.000
	if(local.gotout == 1) { local.vehicle playsound sdkfz_snd_stop }

	if(local.vehicle.model== "models/vehicles/uboat.tik") { local.vehicle.outheight = 180 }
	else { local.vehicle.outheight = 120 } // if this is 100 or lower and the boat is still moving after the player gets out, the player will be run over by the boat and killed.

	local.vehicle.seats = 1		// initialize this before adding seats in "seatstuff" thread to avoid NIL errors
	local.vehicle thread vehiclereset
	local.vehicle thread vehicledamage
	local.vehicle thread vehicledeath
	local.vehicle thread vehicletrigger

	if(level.boat_initorigin[local.name] == NIL) { level.boat_initorigin[local.name] = local.origin } // store the initial origin/angles as level variable arrays
	if(level.boat_initangles[local.name] == NIL) { level.boat_initangles[local.name] = local.angles }
	if(level.boat_inithealth[local.name] == NIL) { level.boat_inithealth[local.name] = local.health }

	if(level.vehiclescriptmaster[local.vehicle.model] != 1) // this only runs once
	{
		cache local.vehicle.model
		cache local.desmodel
		cache models/emitters/fancyfire.tik; cache models/emitters/thin_black_short.tik
		cache models/emitters/mortar_higgins.tik
		cache models/emitters/mortar_dirt_nosound.tik
		cache models/static/corona_util.tik
		if(local.vehicle.model == "models/vehicles/higginsxtrahull.tik") { cache models/vehicles/higginsdoor.tik; cache models/vehicles/mercedes.tik }
		thread scriptmaster local.vehicle.model
		level.vehiclescriptmaster[local.vehicle.model] = 1
		level.vehiclescriptmaster[local.model] = 1
	}

	if(local.vehicle.model == "models/vehicles/uboat.tik")
	{
		local.vehicle turnrate 1; local.vehicle.turningrate = 1.000
		local.vehicle attachmodel models/emitters/fancyfire.tik "Box01" 1 (local.name + "_tag_barrel") 1 -1 -1 -1 -1 ( 0 211 565 ) //( +left -right, +up -down, +forward -backward )
		$(local.name + "_tag_barrel") notsolid
		$(local.name + "_tag_barrel") hide
		local.vehicle.gun = $(local.name + "_tag_barrel")

		local.vehicle thread boatstuck_inwall_fix
		local.vehicle thread turret_laser local.name
	}
	if(local.vehicle.model == "models/vehicles/higginsxtrahull.tik")
	{
		local.vehicle attachmodel models/static/corona_util.tik "Box01" 1 (local.name + "_doorglue") 1 -1 -1 -1 -1 ( 0 0 0 ) //( -forward +backward, +up -down, +left -right )
		$(local.name + "_doorglue") notsolid
		local.vehicle.doorglue = $(local.name + "_doorglue")
		$(local.name + "_doorglue") attachmodel models/vehicles/higginsdoor.tik "Box01" 1 (local.name + "_doorclosed") 1 -1 -1 -1 -1 ( 0 0 0 ) //( -forward +backward, +up -down, +left -right )
		$(local.name + "_doorclosed").angles = ( 90 0 0 )
		$(local.name + "_doorclosed") notsolid
		local.vehicle.doorclosed = $(local.name + "_doorclosed")
		$(local.name + "_doorglue") attachmodel models/vehicles/higginsdoor.tik "Box01" 1 (local.name + "_dooropen") 1 -1 -1 -1 -1 ( 309 0 -225 ) //( +up -down, +left -right, -forward +backward )
		$(local.name + "_dooropen").angles = ( 0 180 180 )
		$(local.name + "_dooropen") notsolid
		local.vehicle.dooropen = $(local.name + "_dooropen")

		local.vehicle.door_open = local.door_open
		if(local.door_open == 1) { $(local.name + "_doorclosed") hide; $(local.name + "_dooropen") show }
		else { $(local.name + "_doorclosed") show; $(local.name + "_dooropen") hide }

		local.doorclip = spawn script_model targetname (local.name + "_doorclip")
		local.doorclip model "vehicles/mercedes.tik"
		local.doorclip solid
		local.doorclip hide
		local.vehicle.doorclip = local.doorclip // do not use local.vehicle.doorclip = $(local.name + "_doorclip"), otherwise mysterious "array" console errors will occur, even though $(local.name + "_doorclip").size = 1, and even though only 1 entity is inside of .doorclip.
		local.vehicle thread keep_at_door local.doorclip local.door_open
	}
										// "local.player.touching_playerboat" or "$player[1].touching_playerboat" can be included in trigger setthreads
	if(level.touching_playerboat != 1) { thread touching_playerboat }	// to exclude teleporting players that are touching "$ocean" or similar water-surface triggers.

	if(level.chainreactors == NIL || (level.chainreactors != NIL && level.chainreactors.size < 1)) { level.chainreactors[1] = local.vehicle }
	else
	{
		for(local.c = 1; local.c <= 999; local.c++)
		{
			if(level.chainreactors[local.c] == NIL)
			{
				level.chainreactors[local.c] = local.vehicle
				local.vehicle thread chainreactors_remove local.c
				break
			}
		}
	}
	local.vehicle thread move_stuck_players // the vehicle might respawn on top of other players, move them onto the top of it.

	if(level.drivable_entities == NIL) { level.drivable_entities[1] = local.name }
	else
	{
		for(local.d = 1; local.d <= level.drivable_entities.size; local.d++)
		{
			if(level.drivable_entities[local.d] == local.name) { end }
		}
		level.drivable_entities[level.drivable_entities.size + 1] = local.name
	}
end

chainreactors_remove local.c:

	while(self != NULL) { waitframe }
	level.chainreactors[local.c] = NIL
end

shottrig:

	local.player = parm.other
	if(self.vehicle != NULL && (self.vehicle.driver == NIL || (self.vehicle.driver != NIL && (self.vehicle.driver.dmteam != local.player.dmteam || getcvar("g_gametype") == "1")))) { self.vehicle.shooter = local.player }
end

removetrig:

	while(self != NULL && self.vehicle != NULL) { waitframe }
	if(self != NULL) { self remove }
end

////////////////////////////////////////////////////////////////////////

vehiclereset:

	self thread healthboost
	removeclass Camera // also removes PlayerIntermission and other func_cameras
end

healthboost: // shotgun: 340 damage, bazooka: 105 damage, sniper: 106 damage, one grenade: 200 damage, two grenades: 400 damage

	local.health = self.health
	while(self != NULL && self.health > 0 && (self.driver == NIL || self.damagetrig.health > 0))
	{
		if(self.driver != NIL && self.damagetrig.health < self.health) { self.health = self.damagetrig.health }
		if(self.health < local.health && self.shooter != NIL && self.shooter != NULL)
		{
			if(self.passengers != NIL && self.passengers.size >= 1)
			{
				local.damage = ((local.health - self.health) / self.passengers.size)
				for(local.i = 1; local.i <= self.passengers.size; local.i++)
				{
					self.passengers[local.i] takedamage
					if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.passengers[local.i] damage self.shooter.player_owner local.damage self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.passengers[local.i] damage self.shooter.owner local.damage self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					else { self.passengers[local.i] damage self.shooter local.damage self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					self.passengers[local.i] nodamage
				}
			}
			if(self.driver != NIL && self.driver != NULL && self.model != "models/vehicles/uboat.tik")
			{
				if(self.driver.health > 1)
				{
					self.driver takedamage
					if(self.passengers != NIL && self.passengers.size >= 1) { local.damage = ((local.health - self.health) / (2 + self.passengers.size)) }
					else { local.damage = ((local.health - self.health) / 2) }

					if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.driver damage self.shooter.player_owner local.damage self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.driver damage self.shooter.owner local.damage self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					else { self.driver damage self.shooter local.damage self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					self.driver nodamage
				}
				else
				{
					self thread driverreset 1
					self thread vehiclereset
					if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.driver damage self.shooter.player_owner 9999999 self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.driver damage self.shooter.owner 9999999 self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					else { self.driver damage self.shooter 9999999 self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					self.driver = NIL
				}
			}

			if(self.model != "models/vehicles/uboat.tik")
			{
				for(local.i = 1; local.i <= $player.size; local.i++)
				{
					if($player[local.i].isdog == 1 && $("dogmouthtrig_" + $player[local.i].entnum).biting == 1 && $("dogmouthtrig_" + $player[local.i].entnum) istouching self && $player[local.i].passenger != 1)
					{
						for(local.i = 1; local.i <= self.passengers.size; local.i++)
						{
							self.passengers[local.i] damage $player[local.i] 15000 $player[local.i] (0 0 0) (0 0 0) (0 0 0) 0 9 0 0
						}
					}
				}
			}
		}
		if(isalive self) // need "isalive" check to avoid "cannot give health to dead entities" error
		{
			self.health = local.health
			if(self.driver != NIL) { self.damagetrig.health = local.health }
		}
		if(self.shooter != NIL) { self thread shooter_NIL }
		waitframe
	}
end

shooter_NIL:

	waitframe
	if(self != NULL) { self.shooter = NIL }
end

vehicletrigger:

	if($(self.name + "_trig") != NULL) { $(self.name + "_trig") remove }
	local.trig = spawn trigger_use targetname (self.name + "_trig")
	local.trig.origin = self.origin
	if(self.model != "models/vehicles/uboat.tik") { local.trig setsize ( -130 -130 -100 ) ( 130 130 100 ) }
	else { local.trig setsize ( -(2000 * self.scale) -(150 * self.scale) -(10 * self.scale) ) ( (1820 * self.scale) (150 * self.scale) (200 * self.scale) ) }
	local.trig.vehicle = self
	local.trig glue self
	local.trig setthread triggered
end

triggered:

	local.player = parm.other
	if(local.player.driving == 1 || local.player.passenger == 1 || local.player.flying == 1) { end }

	if(self.vehicle != NULL)
	{
		if(self.vehicle.driver != NIL && self.vehicle.passengers.size < self.vehicle.seats)
		{
			self.vehicle thread passengers
		}
		if(self.vehicle.driver == NIL)
		{
			if(local.player.isdog != 1) { self.vehicle thread playergetin }
			if(local.player.isdog == 1) { local.player iprint ("Dogs cannot drive vehicles.") } // set other exceptions here
		}
	}
end

playergetin:

	local.player = parm.other
	local.team = local.player.dmteam
	if(self.attachingdriver == 1) { end }
	self.attachingdriver = 1

	local.player safeholster 1
	wait 1
	if(self == NULL || local.player == NIL || local.player == NULL || !isalive local.player || local.player.dmteam != local.team || local.player.dead == 1 || level.change_team_score == 1 || level.bbactive == 0 || (self.turretplayer != NIL && self.turretplayer != NULL) || local.player.driving == 1 || local.player.flying == 1)
	{
		if(self != NULL) { self.attachingdriver = 0 }
		end
	}

	self.driver = local.player
	self.driver.driving = 1
	self.driver.drivingent = self
	local.driver = self.driver
	self.player_owner = self.driver

	self.passengers[1] = NIL // initialize as array to make size = 0 instead of size = -1
	self thread seatstuff

	self.driver forcelegsstate STAND
	//self.driver hide
	self.driver nodamage // keep this off until the player receives damage, then quickly do "takedamage" and give damage, before doing "nodamage" again in "healthboost" thread (allows for more damage types such as bazooka rockets to count as kills).
	self.driver notsolid
	self.driver.driving_state_jump = 0
	if(self.model == "models/vehicles/uboat.tik")
	{
		self.driver iprint ("press A - D (left-right keys) = aim turret down/up.")
		self.driver iprint ("JUMP = exit boat. FIRE = shoot rockets. FIRE + USE(e) = throw grenades.")
	}
	else { self.driver iprint ("JUMP = exit boat. hold FIRE = look behind. press A - D (left-right keys) = close/open door.") }

	self attachdriverslot 0 self.driver
	self thread dummyavatar
	self.driver loopsound wavelaps
	self.turretlaser_offset = 0

	self waitthread spawn_driver_seat_and_trigs
	if($("driver_seat_" + self.entnum) != NULL) { self.driver glue $("driver_seat_" + self.entnum) }

	if(local.driver.using_pack == 1)
	{
		local.driver stufftext "globalwidgetcommand june6 linkcvar phealth"
		local.driver stufftext "globalwidgetcommand june6 statbar vertical 0 100"
		local.driver stufftext "globalwidgetcommand charliesector linkcvar phealth"
		local.driver stufftext "set phealth 100"
	}
	else { local.driver thread display }

	local.c = 5.000		// boat speed divisor; Higher = starting speed is much slower (total change is larger), Lower = starting speed is closer to max speed (total change is smaller).
	local.decel_rate = 30	// how many divisions of local.c for deceleration/acceleration. Higher = more time to reach max speed, Lower = less time to reach max speed.
	local.deceleration = local.c
	local.drivervelocity_old = ( 0 0 0 )
	self.movingforward = 0
	self.movingbackward = 0
	local.d = local.c	// vehicle turnrate will increase equally when accelerating, but will decrease 4x as fast when decelerating.

	self.attachingdriver = 0
	while(self != NULL && isalive self.driver && self.driver.dmteam == local.team && self.driver.dead != 1 && level.change_team_score != 1 && level.bbactive != 0)
	{
		self.driver.viewangles = ( (self.angles[0] + 10) self.angles[1] self.angles[2] )

		if(self.driver.driving_state_jump == 1) // Press JUMP to exit.
		{
			self thread driverreset
			self thread vehiclereset
			self.driver thread wallstuck_fix
			self.driver = NIL
			break
		}

		if(self.model == "models/vehicles/uboat.tik")
		{
			if(self.turretlaser != NIL && self.turretlaser != NULL)
			{
				local.fwd_vec = angles_toforward ( (self.angles[0] + self.turretlaser_offset) self.angles[1] self.angles[2] )
				local.start = $(self.targetname + "_tag_barrel").origin
				local.groundtarget = trace (local.start + local.fwd_vec * 56) (local.start + local.fwd_vec * 10240) 0

				self.turretlaser.origin = $(self.targetname + "_tag_barrel").origin
				self.turretlaser endpoint local.groundtarget
				self.turretlaser_point.origin = local.groundtarget
			}

			if(self.driver.fireheld == 1)
			{
				if(self.driver.useheld != 1) { self thread firegun } 
				else { self thread firesecondary }
			}

			if(self.driver.fireheld != 1 && self.driver.driving_state_left == 1 || self.driver.driving_state_right == 1)
			{
				if(self.turretlaser != NIL && self.turretlaser != NULL)
				{
					if(self.driver.driving_state_left != 1 && self.driver.driving_state_right == 1)
					{
						if(self.turretlaser_offset > -15) { self.turretlaser activate; self.turretlaser_point show; self.turretlaser_offset -= .25 }
						else { self.turretlaser deactivate; self.turretlaser_point hide; self.turretlaser_offset = -15 }
					}

					if(self.driver.driving_state_left == 1 && self.driver.driving_state_right != 1)
					{
						if(self.turretlaser_offset < 3) { self.turretlaser activate; self.turretlaser_point show; self.turretlaser_offset += .25 }
						else { self.turretlaser deactivate; self.turretlaser_point hide; self.turretlaser_offset = 3 }
					}
					if(self.driver.driving_state_left != 1 && self.driver.driving_state_right != 1) { self.turretlaser deactivate; self.turretlaser_point hide }
				}
			}
			else { self.turretlaser deactivate; self.turretlaser_point hide }
		}
		else
		{
			if(self.driver.fireheld == 1) { self.driver.viewangles = ( (10 + self.angles[0] * -1) (self.angles[1] + 180) (self.angles[2] * -1) ) }

			if(self.driver.driving_state_left == 1 && local.toggle != 1 && self.door_open == 1 && self.door_count >= 20) // press A (left key) to close higgins door
			{
				//self.driver iprint "Closing the higgins door."
				self.doorclip playsound higgins_door_close
				self.dooropen hide
				self.doorclosed show
				self.door_open = 0
				local.toggle = 1
			}
			if(self.driver.driving_state_right == 1 && local.toggle != 1 && self.door_open != 1 && self.door_count >= 20) // press D (right key) to open higgins door
			{
				//self.driver iprint "Opening the higgins door."
				self.doorclip playsound higgins_door_open
				self.dooropen show
				self.doorclosed hide
				self.door_open = 1
				local.toggle = 1
			}
			if(self.driver.driving_state_left != 1 && self.driver.driving_state_right != 1) { local.toggle = 0; local.toggle2 = 0 }
		}

		if(self.driver.viewangles[0] > 180) { self.driver.viewangles = ( (10 + (self.angles[0] - 360)) self.driver.viewangles[1] self.driver.viewangles[2] ) } // any viewangles[0] +/- 180 will cause camera issues (going under vehicle).
		if(self.driver.viewangles[0] < -180) { self.driver.viewangles = ( (self.driver.viewangles[0] + 360) self.driver.viewangles[1] self.driver.viewangles[2] ) } // prevent camera from moving too far down.

		if(self.vehiclespeed == 0) { self.movingforward = 0; self.movingbackward = 0 }

		if(self.velocity != ( 0 0 0 )) // make boats drive faster in reverse, only when holding S (walk backwards key) and when holding FIRE (looking behind).
		{
			self.driver loopsound riverdrive

			if(self.driver.driving_state_backward == 1)
			{
				if(self.movingforward == 1 && local.c < local.deceleration) // slowing down, before reversing begins.
				{
					local.c += local.deceleration * 2.000 / local.decel_rate
					local.d += 4.000 * local.deceleration / local.decel_rate
					if(local.c > local.deceleration) { local.c = local.deceleration; self.vehiclespeed = 0 }
					if(local.d > local.deceleration) { local.d = local.deceleration }
					self.vehiclespeed = self.vehiclespeed_max / local.c
					self.velocity = self.driver.velocity * (self.vehiclespeed / self.vehiclespeed_max * -1) + self.forwardvector * self.vehiclespeed
				}
				else
				{
					local.c -= local.deceleration / local.decel_rate
					local.d -= local.deceleration / local.decel_rate
					if(local.c < 1) { local.c = 1 }
					if(local.d < 1) { local.d = 1 }
					self.vehiclespeed = self.vehiclespeed_max / local.c
					self.velocity = self.driver.velocity + self.forwardvector * self.vehiclespeed * -0.500 // only reverse at half the maximum boat speed
					self.movingforward = 0
					self.movingbackward = 1
				}
			}
			else // make boats drive faster, only when holding W (forward key).
			{
				if(self.movingbackward == 1 && local.c < local.deceleration) // slowing down, before driving forward begins.
				{
					local.c += local.deceleration * 2.000 / local.decel_rate
					local.d += 4.000 * local.deceleration / local.decel_rate
					if(local.c > local.deceleration) { local.c = local.deceleration; self.vehiclespeed = 0 }
					if(local.d > local.deceleration) { local.d = local.deceleration }
					self.vehiclespeed = self.vehiclespeed_max / local.c
					self.velocity = self.driver.velocity * (self.vehiclespeed / self.vehiclespeed_max * -1) + self.forwardvector * self.vehiclespeed * -0.500 // only reverse at half the maximum boat speed
				}
				else
				{
					local.c -= local.deceleration / local.decel_rate
					local.d -= local.deceleration / local.decel_rate
					if(local.c < 1) { local.c = 1 }
					if(local.d < 1) { local.d = 1 }
					self.vehiclespeed = self.vehiclespeed_max / local.c
					self.velocity = self.driver.velocity + self.forwardvector * self.vehiclespeed
					self.movingforward = 1
					self.movingbackward = 0
				}
			}

			if(self.turningrate / local.d < 1) { self.turnrate = 1 }
			else if(self.turningrate / local.d < self.turningrate) { self turnrate (self.turningrate / (local.d * 0.500)) }
			else { self turnrate self.turningrate }
		}
		else
		{
			self.driver loopsound wavelaps
			if(local.c == 1) { self playsound sdkfz_snd_shift2 }

			local.d += 4.000 * local.deceleration / local.decel_rate
			if(local.d > local.deceleration) { local.d = local.deceleration }

			local.c += local.deceleration / local.decel_rate
			if(local.c > local.deceleration) { local.c = local.deceleration; self.vehiclespeed = 0 }
			else { self.vehiclespeed = self.vehiclespeed_max / local.c }

			if(self.driver.driving_state_backward == 1) { self.velocity = local.drivervelocity_old + self.forwardvector * self.vehiclespeed * -1 }
			else { self.velocity = local.drivervelocity_old + self.forwardvector * self.vehiclespeed }
		}

		if(self.model != "models/vehicles/uboat.tik")
		{
			for(local.i = 1; local.i <= $player.size; local.i++)
			{
				if($player[local.i].isdog == 1 && $("dogmouthtrig_" + $player[local.i].entnum).biting == 1 && ($("dogmouthtrig_" + $player[local.i].entnum) istouching self.damagetrig || $("dogmouthtrig_" + $player[local.i].entnum) istouching self.damagetrig))
				{
					self.shooter = $player[local.i]
					self.driver takedamage
					self.driver damage $player[local.i] 15000 $player[local.i] (0 0 0) (0 0 0) (0 0 0) 0 9 0 0
				}
			}
		}

		local.drivervelocity_old = self.driver.velocity
		local.driver stufftext ("set phealth " + int(local.driver.health))
		waitframe
	}

	if(self != NULL) // spawn in the new vehicle and remove the old one.
	{
		thread main self.name self.model self.origin self.angles self.health self.vehiclespeed_max self.resettime self.scale 1 self.door_open

		if(self.driver != NIL && self.driver != NULL)
		{
			if(self.driver.dmteam == local.team && level.change_team_score != 1 && level.bbactive != 0) { self thread driverreset }
			else { self thread driverreset 2 } // if the player switched teams without dying, make sure they don't tele back to the vehicle.
			self thread vehiclereset
		}
		if(self.turretplayer != NIL && self.turretplayer != NULL) { self waitthread turretplayer_reset self.turretplayer.dmteam self.turretplayer }

		self.driver = NIL // the old vehicle must be properly removed, otherwise the server will crash if anyone driving the vehicle leaves the game (becomes NULL).
		self remove
	}
	waitframe
	if(local.driver != NULL)
	{
		local.driver.driving = 0
		local.driver.drivingent = NIL
		local.driver stoploopsound
		if(!isalive local.driver) { local.driver stufftext ("set phealth 0") }

		if(local.driver.using_pack == 1)
		{
			local.driver stufftext "globalwidgetcommand june6 linkcvar fuel"
			local.driver stufftext ("globalwidgetcommand june6 statbar vertical 0 " + level.jetpack_max_fuel)
			local.driver stufftext "globalwidgetcommand charliesector linkcvar fuel"
		}
		else
		{
			local.driver stufftext "hidemenu dday1"
			local.driver stufftext "hidemenu dday2"
		}

		local.origin = local.driver.origin
		while(local.driver != NULL && !isalive local.driver && local.driver.dmteam != "spectator")
		{
			local.driver.origin = ( local.origin[0] local.origin[1] local.driver.origin[2] ) // for some reason, drivers' dead bodies would move forward across the ground until they hit a wall.
			local.driver notsolid
			local.driver droptofloor
			waitframe
		}
	}
end

driverreset local.status:

	if(self.driver == NIL) { end } // if the vehicle blew up with nobody driving it, end this thread.

	if(local.status != 1) { cueplayer }				// reattaches camera to player's head
	self detachdriverslot 0 self.driver
	self.driver.viewangles = ( 0 self.driver.viewangles[1] 0 )
	if($("driver_seat_" + self.entnum) != NULL) { self.driver unglue }

	if(local.status != 2)
	{
		self.driver show
		if(local.status != 1) { self.driver solid }
		self.driver takedamage
		self.driver forcetorsostate STAND // without this, players will be stuck in noclip mode, even though noclip isn't used for drivers (doing "self.driver noclip; self driver noclip" also works).
		self.driver.origin = self.origin + (angles_toup self.angles * self.outheight)
		self.driver.viewangles = ( self.driver.viewangles[0] self.driver.viewangles[1] 0 )
	}
end

vehicledamage:

	local.c = 0
	while(self != NULL && self.health > 0)
	{
		if(self != NULL)
		{
			local.previoushealth = self.health
			if(local.c > 0) { local.c-- }
		}
		waitframe
		if(self != NULL && local.previoushealth > self.health)
		{
			local.c = local.c + 2
			self playsound damage_vehicle
			//if(local.c == 2) { exec global/earthquake.scr .2 3 0 0 } // if boat is getting constantly damaged per frame, stop earthquake from spamming. (removed, since it was still getting annoying)
		}
	}
end

vehicledeath:

	self waittill death // when waiting until "death", vehicle is not NULL yet
	self stoploopsound
	self playsound explode_truck

	if(self.desmodel == NIL) { self.desmodel = self.model }
	local.desvehicle = spawn script_model
	local.desvehicle.origin = self.origin + ( 0 0 -25 )
	local.desvehicle.scale = self.scale
	local.desvehicle model self.desmodel
	local.desvehicle loopsound vehicledeathfire

	if(self.model != "models/vehicles/uboat.tik") { local.distance = -100 }
	else { local.distance = 355; local.distance2 = 675 }

	local.sin = (waitthread global/math.scr::sine self.angles[1]) * local.distance * local.desvehicle.scale
	local.cos = (waitthread global/math.scr::cosine self.angles[1]) * local.distance * local.desvehicle.scale

	if(self.angles[2] > 5 && self.angles[2] < 180) { local.one = 1 }
	if(self.angles[2] > 180 && self.angles[2] < 355) { local.one = -1 }
	if(self.angles[2] <= 5 || self.angles[2] >= 345)
	{
		local.r = randomint(2)
		if(local.r == 0) { local.one = 1 }
		if(local.r == 1) { local.one = -1 }
	}

	if(self.model == "models/vehicles/uboat.tik")
	{
		local.desvehicle.angles = self.angles + ( 0 0 ((randomint(20) + 15) * local.one) )

		local.fire = spawn script_model
		local.fire model "models/emitters/fancyfire.tik"
		local.fire.origin = local.desvehicle.origin + local.desvehicle.forwardvector * local.distance + angles_toup local.desvehicle.angles * 150 * local.desvehicle.scale
		local.fire.angles = ( 0 0 0 )
		local.fire.scale = 5 * local.desvehicle.scale
		local.fire anim start
		local.fire notsolid
		local.smoke = spawn script_model
		local.smoke model "models/emitters/thin_black_short.tik"
		local.smoke.origin = local.desvehicle.origin + local.desvehicle.forwardvector * local.distance + angles_toup local.desvehicle.angles * 150 * local.desvehicle.scale
		local.smoke.angles = ( 0 0 0 )
		local.smoke.scale = 3.5 * local.desvehicle.scale
		local.smoke anim start
		local.smoke notsolid
		local.fire2 = spawn script_model
		local.fire2 model "models/emitters/fancyfire.tik"
		local.fire2.origin = local.desvehicle.origin + local.desvehicle.forwardvector * local.distance2 * -1 + angles_toup local.desvehicle.angles * 150 * local.desvehicle.scale
		local.fire2.angles = ( 0 0 0 )
		local.fire2.scale = 5 * local.desvehicle.scale
		local.fire2 anim start
		local.fire2 notsolid
		local.smoke2 = spawn script_model
		local.smoke2 model "models/emitters/thin_black_short.tik"
		local.smoke2.origin = local.desvehicle.origin + local.desvehicle.forwardvector * local.distance2 * -1 + angles_toup local.desvehicle.angles * 150 * local.desvehicle.scale
		local.smoke2.angles = ( 0 0 0 )
		local.smoke2.scale = 3.5 * local.desvehicle.scale
		local.smoke2 anim start
		local.smoke2 notsolid
	}
	else
	{
		local.desvehicle.angles = self.angles + ( 0 0 ((randomint(30) + 5) * local.one) )

		local.fire = spawn script_model
		local.fire model "models/emitters/fancyfire.tik"
		local.fire.origin = local.desvehicle.origin + local.desvehicle.forwardvector * local.distance + angles_toup local.desvehicle.angles * 42
		local.fire.angles = ( 0 0 0 )
		local.fire.scale = 1
		local.fire anim start
		local.fire notsolid
		local.smoke = spawn script_model
		local.smoke model "models/emitters/thin_black_short.tik"
		local.smoke.origin = local.desvehicle.origin + local.desvehicle.forwardvector * local.distance + angles_toup local.desvehicle.angles * 42
		local.smoke.angles = ( 0 0 0 )
		local.smoke.scale = .7
		local.smoke anim start
		local.smoke notsolid
	}

	self thread driverreset 1								// local.status = 1
	self thread mainreset local.desvehicle local.fire local.smoke local.fire2 local.smoke2	// waiting self.resettime seconds until a new vehicle is spawned in

	self thread kill_riders
	self.driver = NIL

	if($(self.name + "_trig") != NULL) { $(self.name + "_trig") remove }
	exec global/earthquake.scr .35 2 0 0
	if(local.desvehicle.model == "models/vehicles/uboat.tik") { local.radius = 1000 }
	else { local.radius = 600 }

	if(self.shooter != NIL && self.shooter != NULL)
	{
		if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { local.shooter = self.shooter.player_owner }
		else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { local.shooter = self.shooter.owner }
		else { local.shooter = self.shooter }
	}
	local.blewup = 1
	for(local.i = 1; local.i <= $player.size; local.i++) // use this instead of radiusdamage, so death explosions can count as score/kills.
	{
		if(vector_length(self.origin - $player[local.i].origin) <= local.radius) // "local.explode" emitters cannot be used with "cansee"
		{
			if(local.shooter == NIL || local.shooter == NULL)
			{
				if($player[local.i].driving != 1 && $player[local.i].flying != 1 && $player[local.i] cansee local.desvehicle 360) // "cansee self" does not work.
				{
					$player[local.i] damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0
				}
				else if($player[local.i].drivingent != NIL && $player[local.i].drivingent != NULL)
				{
					if($player[local.i].flying == 1) { $("planehit" + $player[local.i].entnum) damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else { $player[local.i].drivingent damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
				}
			}
			else if($player[local.i] != local.shooter && $player[local.i].dmteam == local.shooter.dmteam && getcvar("g_teamdamage") != "1" && getcvar("g_gametype") != "1") { local.blewup = 0 }
			else
			{
				if($player[local.i].driving != 1 && $player[local.i].flying != 1 && $player[local.i] cansee local.desvehicle 360)
				{
					$player[local.i] damage local.shooter 500 local.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 // "damage" does not hurt teammates, but scriptbazookaexplosion.tik does
				}
				else if($player[local.i].drivingent != NIL && $player[local.i].drivingent != NULL)
				{
					$player[local.i].drivingent.shooter = local.shooter
					if($player[local.i].flying == 1) { $("planehit" + $player[local.i].entnum) damage local.shooter 500 local.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else { $player[local.i].drivingent damage local.shooter 500 local.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
				}
			}
		}
	}
	self remove

	local.boom = spawn script_model
	local.boom model "models/emitters/mortar_higgins.tik"
	local.boom.origin = local.desvehicle.origin + ( 0 0 25 )
	local.boom.angles = ( 0 -90 0 ) + ( 260 0 0 )
	if(local.desvehicle.model == "models/vehicles/uboat.tik") { local.boom.scale = 2.5 }
	else { local.boom.scale = 1 }
	local.boom anim start
	local.boom notsolid

	local.debris = spawn script_model targetname "mortar_dirt_nosound"
	local.debris model "emitters/mortar_dirt_nosound.tik" 
	local.debris.origin = local.desvehicle.origin + ( 0 0 25 )
	if(local.desvehicle.model == "models/vehicles/uboat.tik") { local.debris.scale = 2.0 }
	else { local.debris.scale = .8 }
	local.debris anim start
	local.debris notsolid
	waitframe
	local.boom remove
	local.debris remove
	if(local.blewup == 1) { radiusdamage local.desvehicle.origin 500 local.radius } // this must be one frame after other damages in this thread, otherwise chain-reaction kills will not count.
end

kill_riders:

	if(self.passengers.size >= 1)
	{
		for(local.i = 1; local.i <= self.passengers.size; local.i++)
		{
			if(self.passengers[local.i] != NIL && self.passengers[local.i] != NULL)
			{
				if(self.shooter != NIL)
				{
					self.passengers[local.i] takedamage
					if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.passengers[local.i] damage self.shooter.player_owner 9999999 self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.passengers[local.i] damage self.shooter.owner 9999999 self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else if(self.shooter != NULL) { self.passengers[local.i] damage self.shooter 9999999 self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					self.passengers[local.i] nodamage
				}
				else { self.passengers[local.i] volumedamage 9999999 }
			}
		}
	}

	if(self.shooter != NIL)
	{
		if(self.driver != NIL)
		{
			self.driver takedamage
			if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.driver damage self.shooter.player_owner 9999999 self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.driver damage self.shooter.owner 9999999 self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			else if(self.shooter != NULL) { self.driver damage self.shooter 9999999 self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			self.driver nodamage
		}
	}
	else if(self.driver != NIL) { self.driver volumedamage 9999999 } // let's make sure the driver is dead.
end

mainreset local.desvehicle local.fire local.smoke local.fire2 local.smoke2:

	if(self.resettime == NIL || self.resettime <= 0) { end }

	local.name = self.name
	local.model = self.model
	local.origin = self.originold  // respawns the vehicle where it was destroyed, only by setting "thread main" origin/angles to "local.origin" "local.angles".
	local.angles = self.angles
	local.health = level.boat_inithealth[self.name]
	local.vehiclespeed = self.vehiclespeed_max
	local.resettime = self.resettime
	local.scale = self.scale

	while(self != NULL) { waitframe }
	wait local.resettime

	if(local.fire != NIL && local.fire != NULL) { local.fire remove }
	if(local.smoke != NIL && local.smoke != NULL) { local.smoke remove }
	if(local.fire2 != NIL && local.fire2 != NULL) { local.fire2 remove }
	if(local.smoke2 != NIL && local.smoke2 != NULL) { local.smoke2 remove }
	local.desvehicle remove
	thread main local.name local.model level.boat_initorigin[local.name] level.boat_initangles[local.name] local.health local.vehiclespeed local.resettime local.scale
end

////////////////////////////////////////////////////////////////////////

passengers:
	
	local.player = parm.other
	local.team = local.player.dmteam
	waitframe	// need this here, otherwise driver & passenger could be attached to the same seat!

	if(local.player == NIL || local.player == NULL || !isalive local.player || local.player.dmteam != local.team || local.player == self.driver || local.player == self.turretplayer || local.player.passenger == 1 || local.player.driving == 1 || local.player.flying == 1 || local.player.dead == 1 || level.change_team_score == 1 || level.bbactive == 0) { end }

	for(local.s = 1; local.s <= self.seats; local.s++)
	{
		if(self.passengers[local.s] == NIL) { self.passengers[local.s] = local.player; break } // assign player to the 1st available passenger seat
	}
	if(local.s > self.seats) { end } // no seats available.

	if(local.player.dmteam != self.driver.dmteam && local.player.dmteam != "spectator" && getcvar("g_gametype") != "1")
	{
		self.passengers[local.s] = NIL
		local.player iprint ("An enemy player is driving this vehicle!")
		end
	}

	self waitthread spawn_passenger_seat local.s
	if($("passenger_seat_" + local.s + "_" + self.entnum) != NULL) { local.player glue $("passenger_seat_" + local.s + "_" + self.entnum) }

	local.player take "models/items/binoculars.tik" // using these will cause camera jittering again.
	local.player forcetorsostate VEHICLE_PASSENGER // prevents camera jittering.
	local.player forcelegsstate STAND
	//local.player hide
	//local.player noclip
	local.player nodamage // keep this off until the player receives damage, then quickly do "takedamage" and give damage, before doing "nodamage" again in "healthboost" thread (allows for more damage types such as bazooka rockets to count as kills).
	local.player notsolid // need this, otherwise vehicles cannot reverse properly.
	local.player iprint ("Press JUMP = exit vehicle. Hold FIRE(zoom) = look around.")
	local.player.origin = self.origin
	local.player.passenger = 1
	local.player.ridingent = self
	local.player.driving = 1 // should help with other scripts.
	local.player.driving_state_jump = 0
	local.PI = 3.14159265359
	local.driver = self.driver
	local.outheight = self.outheight
	local.model = self.model

	while(self != NULL && isalive self.driver && self.driver.dmteam == local.team && self.driver.dead != 1 && isalive local.player && local.player.dmteam == local.team && local.player.dead != 1 && level.change_team_score != 1 && level.bbactive != 0 && $("passenger_seat_" + local.s + "_" + self.entnum) != NULL)
	{
		local.player anim unarmed_stand_idle // need this, since VEHICLE_PASSENGER state uses "movetype anim" instead of "movetype legs", which omits all legs animations (player will landshark without this).

		local.angles = self.angles
		local.dist = vector_length($("passenger_seat_" + local.s + "_" + self.entnum).origin - self.origin)
		local.s_ang = vector_toangles($("passenger_seat_" + local.s + "_" + self.entnum).origin - self.origin)
		local.s_vec = angles_toforward(local.s_ang) * local.dist

		if(local.player.fireheld != 1)
		{
			if(self.playerang_offset[local.s] != NIL) { local.player.viewangles = ( (self.angles[0] + 10) self.angles[1] self.angles[2] ) + ( self.angles[0] self.playerang_offset[local.s] self.angles[2] ) } // some vehicles' passengers should not face forward (view is blocked)
			else { local.player.viewangles = ( (self.angles[0] + 10) self.angles[1] self.angles[2] ) }
		}

		if(local.player.viewangles[0] > 180) { local.player.viewangles = ( (10 + (self.angles[0] - 360)) local.player.viewangles[1] local.player.viewangles[2] ) } // any viewangles[0] +/- 180 will cause camera issues (going under vehicle).
		if(local.player.viewangles[0] < -180) { local.player.viewangles = ( (local.player.viewangles[0] + 360) local.player.viewangles[1] local.player.viewangles[2] ) } // prevent camera from moving too far down.

		if(local.player.driving_state_jump == 1) // Press JUMP to exit vehicle.
		{
			local.player unglue
			if(local.player.isdog != 1) { local.player show }
			local.player give "models/items/binoculars.tik"
			local.player solid
			local.player takedamage
			//local.player noclip
			local.player forcetorsostate STAND
			local.player.origin += local.s_vec + angles_toup(self.angles) * self.outheight
			local.player.viewangles = ( local.player.viewangles[0] local.player.viewangles[1] 0 )

			local.player thread wallstuck_fix
			self.passengers[local.s] = NIL
			local.player.passenger = 0
			local.player.ridingent = NIL
			local.player.driving = 0
			if($("passenger_seat_" + local.s + "_" + self.entnum) != NULL) { $("passenger_seat_" + local.s + "_" + self.entnum) remove }
			end
		}
		waitframe
	}
	if(self != NULL)
	{
		self.passengers[local.s] = NIL
		if($("passenger_seat_" + local.s + "_" + self.entnum) != NULL) { $("passenger_seat_" + local.s + "_" + self.entnum) remove }
	}

	if(local.player != NULL)
	{
		local.player unglue
		local.player.viewangles = ( 0 local.player.viewangles[1] 0 ) // passenger reset
		local.player.passenger = 0
		local.player.ridingent = NIL
		local.player.driving = 0
		if(local.player.dmteam != spectator)
		{
			if(isalive local.player) { local.player give "models/items/binoculars.tik" }
			if(local.player.isdog != 1) { local.player show }
			local.player solid
			local.player takedamage
			//local.player noclip
			local.player forcetorsostate STAND
			if(local.player.dmteam == local.team) // if the passenger did not switch teams
			{
				if(local.model != "models/vehicles/uboat.tik") { local.player.origin += local.s_vec * 1.5 + angles_toup(local.angles) * local.outheight }
				else { local.player.origin = self.origin + (angles_toup self.angles * self.outheight) }
				local.player.viewangles = ( local.player.viewangles[0] local.player.viewangles[1] 0 )
				local.player thread wallstuck_fix
	
				if(local.driver != NULL && (!isalive local.driver || local.driver.dead == 1))
				{
					if(self != NULL && self.shooter != NIL)
					{
						if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { local.player damage self.shooter.player_owner 9999999 self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
						else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { local.player damage self.shooter.owner 9999999 self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
						else { local.player damage self.shooter 9999999 self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					}
					else { local.player damage $world 9999999 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
				}
			}

			local.origin = local.player.origin
			while(local.player != NULL && !isalive local.player && local.player.dmteam != "spectator")
			{
				local.player.origin = ( local.origin[0] local.origin[1] local.player.origin[2] ) // for some reason, passengers' dead bodies would move forward across the ground until they hit a wall.
				local.player notsolid
				local.player droptofloor
				waitframe
			}
		}
	}
end

////////////////////////////////////////////////////////////////////////

firegun:

	if(self.firing_gun == 1) { end }
	self.firing_gun = 1

	self thread projectile
	self playsound uboat_snd_fire //panzerschrecksndfire
	self playsound uboat_reload

	self.boatsmokecount = 0
	self thread smokey

	wait 5
	if(self != NULL) { self.firing_gun = 0 }
end

firesecondary:

	if(self.firing_gun2 == 1) { end }
	self.firing_gun2 = 1

	self thread projectile 1
	self playsound grenadethrow

	wait 1
	if(self != NULL) { self.firing_gun2 = 0 }
end

smokey:

	self.boatsmoking = 1
	local.targetname = self.targetname
	local.boatsmokecount = self.boatsmokecount

	local.smoke = spawn script_model
	local.smoke model "fx/fx_cannonsmoke.tik"
	self.gun = $(self.name + "_tag_barrel")
	local.smoke.origin = self.gun.origin

	while(self != NULL && self.boatsmokecount < 120)
	{
		local.smoke.origin = self.gun.origin
		self.boatsmokecount++
		local.boatsmokecount = self.boatsmokecount
		waitframe
	}

	local.c = 0
	while($(local.targetname) == NULL) // boat is always removed after a player exits the boat, wait for the boat to respawn before continuing smokecount
	{
		if(local.c >= 10) // remove the smoke sooner if the boat was destroyed
		{
			if(local.smoke != NULL) { local.smoke remove }
			end
		}
		local.c++
		waitframe
	}

	$(local.targetname).boatsmoking = 1
	$(local.targetname).boatsmokecount = local.boatsmokecount
	$(local.targetname).gun = $(local.targetname + "_tag_barrel")

	while($(local.targetname) != NULL && $(local.targetname).gun != NULL && $(local.targetname).boatsmokecount != NIL && $(local.targetname).boatsmokecount < 120)
	{
		local.smoke.origin = $(local.targetname).gun.origin
		$(local.targetname).boatsmokecount++
		waitframe	
	}

	if(local.smoke != NULL) { local.smoke remove }
	if($(local.targetname) != NULL) { $(local.targetname).boatsmoking = 0; $(local.targetname).boatsmokecount = 0 }
end

projectile local.secondary:

	local.player = self.driver // used for the for-loop later
	self.gun = $(self.name + "_tag_barrel")

	local.rocket = spawn script_model
	if(local.secondary == 1)
	{
		if(local.player.dmteam == "axis") { local.rocket model "projectiles/steilhandgranate_primary.tik" }
		else { local.rocket model "projectiles/M2FGrenade_primary.tik" }
	}
	else { local.rocket model "projectiles/tigercannonshell.tik" } // "projectiles/panzerschreckshell.tik"
	local.rocket.origin = self.gun.origin
	local.rocket light 0 1 0 400
	local.rocket.scale = 1
	local.rocket solid
	local.rocket physics_on    // need this for gravity and waittill touch to work.
	local.rocket.scale = 3
	if(self != NULL) { local.rocket.player_owner = self.driver }

	if(local.secondary == 1)
	{
		local.rocket playsound grenadethrow
		local.rocket.angles = ( -90 self.angles[1] 0 )
		local.rocket thread rotate

		local.rocket gravity .8
		local.fwd_vec = angles_toforward ( 0 self.angles[1] 0 )
		local.rocket.velocity = ( local.fwd_vec[0] local.fwd_vec[1] .500 ) * 950 // local.fwd_vec[2] = .500 = 45 degrees facing upward
	}
	else
	{
		local.rocket loopsound rocketfireloop
		local.rocket.angles = ( self.turretlaser_offset (self.angles[1] + 180) 0 )

		local.rocket gravity 0
		local.rocket.velocity = (angles_toforward ( (self.angles[0] + self.turretlaser_offset) self.angles[1] self.angles[2] )) * 6000
	}

	if(local.secondary == 1) { wait 3 }
	else
	{
		local.rocket thread waittill_touch local self local.player
		local.hitthing = self
		while(local.hitthing == self || (self != NULL && local.hitthing == self.gun))
		{
			local.rocket waittill touch
			local.hitthing = parm.other
		}
	}
	local.rocket.velocity = ( 0 0 0 )

	local.explode = spawn "fx/explosionTIGERshell.tik" // "fx/explosionPANZERIVshell.tik"
	local.explode.origin = local.rocket.origin
	local.explode.scale = 1
	local.explode light 1 0 0 600
	local.explode anim idle
	//local.explode playsound bazooka_exp // already included in explosionPANZERIVshell

	if(self != NULL && local.rocket istouching self) { local.blewup = 0 }
	else { local.blewup = 1 }

	for(local.i = 1; local.i <= $player.size; local.i++) // use this instead of radiusdamage, so rockets can count as score/kills
	{
		if(vector_length(local.explode.origin - $player[local.i].origin) <= 500) // without "cansee", these rockets can kill people through walls
		{
			if(local.player == NIL || local.player == NULL)
			{
				if($player[local.i].driving != 1 && $player[local.i].flying != 1 && $player[local.i] cansee local.rocket 360)
				{
					$player[local.i] damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 1 15 -1
				}
				else if($player[local.i].drivingent != NIL && $player[local.i].drivingent != NULL)
				{
					if($player[local.i].flying == 1) { $("planehit" + $player[local.i].entnum) damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 1 15 -1 }
					else { $player[local.i].drivingent damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 1 15 -1 }
				}
			}
			else if($player[local.i] != local.player && $player[local.i].dmteam == local.player.dmteam && getcvar("g_teamdamage") != "1" && getcvar("g_gametype") != "1") { local.blewup = 0 }
			else
			{
				if($player[local.i].driving != 1 && $player[local.i].flying != 1 && $player[local.i] cansee local.rocket 360)
				{
					$player[local.i] damage local.player 500 local.player (0 0 0) (0 0 0) (0 0 0) 0 1 15 -1 // "damage" does not hurt teammates, but scriptbazookaexplosion.tik does
				}
				else if($player[local.i].drivingent != NIL && $player[local.i].drivingent != NULL)
				{
					$player[local.i].drivingent.shooter = local.player
					if($player[local.i].flying == 1) { $("planehit" + $player[local.i].entnum) damage local.player 500 local.player (0 0 0) (0 0 0) (0 0 0) 0 1 15 -1 }
					else { $player[local.i].drivingent damage local.player 500 local.player (0 0 0) (0 0 0) (0 0 0) 0 1 15 -1 }
				}
			}
		}
	}
	if(local.blewup == 1) { radiusdamage local.explode.origin 500 500 } // 110 200
	waitframe
	local.rocket remove
	wait .2 // keeps the explosion light visible longer
	local.explode remove
end

////////////////////////////////////////////////////////////////////////

waittill_touch local.thread local.turret local.player:

	while(1)
	{
		if(self == NULL || vector_length(self.origin) > 12000) // if moving outside the map or NULL.
		{
			if(local.thread != NULL) { local.thread remove } // prematurely end "waittill touch" and its thread (nothing else runs after it).
			if(self != NULL) { self remove }
			end
		}

		if(self.velocity == ( 0 0 0 )) { end } // self.hitwater not needed, since these projectiles already stop when hitting water.
		waitframe
	}
end

////////////////////////////////////////////////////////////////////////

rotate:

	while(self != NULL && self.velocity != ( 0 0 0 ))
	{
		self.angles = (self.angles + ( 3 0 0 ))
		waitframe
	}
end

turret_laser local.name:

	local.laser = spawn func_beam
	local.laser minoffset 0
	local.laser maxoffset 0
	local.laser numsegments 1
	local.laser life 0
	local.laser color ( 1 0 0 )
	local.laser alpha .4
	local.laser alwaysdraw
	local.laser deactivate	
	local.laser scale 1.0
	local.laser notsolid
	local.laser.origin = $(local.name + "_tag_barrel").origin
	local.laser endpoint $(local.name + "_tag_barrel").origin
	self.turretlaser = local.laser

	local.point = spawn script_model
	local.point model "static/corona_util.tik"
	local.point.origin = $(local.name + "_tag_barrel").origin
	//local.point light 1 0 0 250
	local.point hide
	self.turretlaser_point = local.point

	while(self != NULL) { waitframe }
	local.laser remove
	local.point remove
end

////////////////////////////////////////////////////////////////////////

seatstuff:

	if(self.model == "models/vehicles/higginsxtrahull.tik")
	{
		self.seats = 9 // [1] = front passenger. [2] = back right, [3], [4], [5] = front right. [6] = front left, [7], [8], [9] = back left
	}
	else if(self.model == "models/vehicles/uboat.tik")
	{
		self.seats = 5 // [1], [2] = right, left front captain platform, [3] = back of captain platform, [4], [5] = right side (facing forward), left side of middle platform
	}
end

spawn_driver_seat_and_trigs: // only spawn seats & triggers when needed, otherwise initializing all seats when vehicle spawns will greatly increase map's entity count.

	local.trig = spawn trigger_multiple spawnflags 128 // for calculating how much damage was given (triggers with health will not go to a setthread until it's fully dead).
	local.trig.origin = self.origin
	local.trig.health = self.health
	local.trig.vehicle = self
	self.damagetrig = local.trig
	local.trig glue self
	local.trig thread removetrig
	if(self.model == "models/vehicles/uboat.tik") { local.trig setsize ( -450 -450 0 ) ( 450 450 420 ) }
	else { local.trig setsize ( -90 -90 0 ) ( 90 90 159 ) }
	local.trig.model = self.model
	local.trig.scale = self.scale
	local.trig hide

	local.trigshot = spawn trigger_multiple spawnflags 128 // instantly determine the vehicle's shooter (runs setthread each time it's triggered).
	local.trigshot.origin = self.origin
	local.trigshot.vehicle = self
	self.trigshot = local.trigshot
	local.trigshot glue self
	local.trigshot thread removetrig
	local.trigshot setthread shottrig
	if(self.model == "models/vehicles/uboat.tik") { local.trigshot setsize ( -450 -450 0 ) ( 450 450 420 ) }
	else { local.trigshot setsize ( -90 -90 0 ) ( 90 90 159 ) }
	local.trigshot.model = self.model
	local.trigshot.scale = self.scale
	local.trigshot hide

	if($("driver_seat_" + self.entnum) != NULL) { $("driver_seat_" + self.entnum) remove }

	if(self.model == "models/vehicles/higginsxtrahull.tik") // "Box01", "Box02", or similar is determined by the model's .skc file.
	{
		self attachmodel models/static/jug.tik "Box01" 1 ("driver_seat_" + self.entnum) 1 -1 -1 -1 -1 ( 120 50 58 ) // ( -forward +backward, +up -down, +left -right )
	}
	else if(self.model == "models/vehicles/uboat.tik")
	{
		self attachmodel models/static/jug.tik "Box01" 1 ("driver_seat_" + self.entnum) 1 -1 -1 -1 -1 ( 0 323 40 ) // ( -right +left, +up -down, +forward -backward )
	}

	if($("driver_seat_" + self.entnum) != NULL)
	{
		$("driver_seat_" + self.entnum).angles = self.angles
		$("driver_seat_" + self.entnum) bind self
		$("driver_seat_" + self.entnum) hide
	}
end

spawn_passenger_seat local.s: // only spawn seats when needed.

	if($("passenger_seat_" + local.s + "_" + self.entnum) != NULL) { $("passenger_seat_" + local.s + "_" + self.entnum) remove }

	local.add = 0
	if(self.model == "models/vehicles/higginsxtrahull.tik") //( +left -right, +up -down, +forward -backward )
	{
		if(local.s == 1) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 120 64 -58 ) } // ( -forward +backward, +up -down, +left -right )
		if(local.s == 2) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 30 64 -40 ) }
		if(local.s == 3) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -50 64 -40 ) }
		if(local.s == 4) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -122 64 -40 ) }
		if(local.s == 5) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -215 64 -40 ) }
		if(local.s == 6) { self.trigshot attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -215 64 40 ) } // each entity can only have 8 attachmodels max,
		if(local.s == 7) { self.trigshot attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -122 64 40 ) } // so attach more seats to the vehicle's glued triggers instead,
		if(local.s == 8) { self.trigshot attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -50 64 40 ) } // and give the triggers identical models.
		if(local.s == 9) { self.trigshot attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 30 64 40 ) }
	}
	else if(self.model == "models/vehicles/uboat.tik") // ( -forward +backward, +up -down, +left -right )
	{
		if(local.s == 1) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -45 321 -111 ) } // ( -right +left, +up -down, +forward -backward )
		if(local.s == 2) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 45 321 -111 ) }
		if(local.s == 3) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 0 321 -270 ); local.add = 180 }
		if(local.s == 4) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -71 234 -407 ); local.add = -90 }
		if(local.s == 5) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 71 234 -407 ); local.add = 90 }
	}

	if($("passenger_seat_" + local.s + "_" + self.entnum) != NULL)
	{
		$("passenger_seat_" + local.s + "_" + self.entnum).angles = self.angles + ( 0 local.add 0 )
		$("passenger_seat_" + local.s + "_" + self.entnum) bind self
		$("passenger_seat_" + local.s + "_" + self.entnum) hide
	}
end

////////////////////////////////////////////////////////////////////////

dummyavatar:

	local.avatar = spawn func_beam
	local.avatar attach self.driver "Bip01 Head"
	local.avatar.origin = self.driver.origin + ( 0 0 100 )
	local.avatar endpoint (local.avatar.origin + ( 0 0 13 ))
	local.avatar minoffset 0
	local.avatar maxoffset 0
	local.avatar color ( 1 1 1 )
	local.avatar scale 7.0
	local.avatar life 0
	if(self.driver.dmteam == "allies") { local.avatar shader ("textures/hud/allies_headicon") }
	if(self.driver.dmteam == "axis") { local.avatar shader ("textures/hud/axis_headicon") }
	local.avatar numsegments 1
	local.avatar alpha .80
	local.avatar activate
	local.heightinc = 0

	self.driver show
	local.team = self.driver.dmteam
	while(self != NULL && isalive self.driver && self.driver.dmteam == local.team && self.driver.dead != 1 && level.change_team_score != 1 && level.bbactive != 0)
	{
		local.avatar.origin = self.driver.origin + ( 0 0 (100 + local.heightinc) )
		local.avatar endpoint (local.avatar.origin + ( 0 0 13 ))
		waitframe
	}
	local.avatar remove
end

////////////////////////////////////////////////////////////////////////

wallstuck_fix:

	local.c = 0
	local.origin = self.origin
	local.team = self.dmteam

	if(self.wallstuck_fixing == 1) { end }
	self.wallstuck_fixing = 1

	while(self != NULL && isalive self && self.dmteam == local.team) // while player is stuck in a wall (falling) and origin isn't changing, count a few seconds, then respawn the player
	{
		if(local.c >= 60) // about 3 seconds
		{
			if((self getmovement) == falling && self.origin == local.origin) { self respawn }
			if(self.isdog == 1) { self hide }
			break
		}
		local.c++
		waitframe
	}
	if(self != NULL) { self.wallstuck_fixing = 0 }
end

////////////////////////////////////////////////////////////////////////

boatstuck_inwall_fix:

	while(self != NULL)
	{
		if((self.angles[0] <= 340 && self.angles[0] >= 20) || (self.angles[2] <= 340 && self.angles[2] >= 20))
		{
			killent self.entnum
			break
		}
		waitframe
	}
end

////////////////////////////////////////////////////////////////////////

touching_playerboat:

	level.touching_playerboat = 1

	while($player.size < 1) { waitframe }
	while($player.size >= 1)
	{
		for(local.i = 1; local.i <= $player.size; local.i++)
		{
			$player[local.i].touching_playerboat = 0 // ensures that only one boat needs to be touched for touching_playerboat = 1.
		}

		for(local.a = 0; local.a <= level.drivable_entities.size; local.a++)
		{
			for(local.s = 1; $(level.drivable_entities[local.a]) != NULL && local.s <= $(level.drivable_entities[local.a]).size; local.s++) // sometimes, two vehicles with the same targetname can exist
			{													// for 1 or 2 frames. this for-loop prevents any console errors.
				for(local.i = 1; local.i <= $player.size; local.i++)
				{
					if($player[local.i] istouching $(level.drivable_entities[local.a])[local.s]) { $player[local.i].touching_playerboat = 1 }

					if($(level.drivable_entities[local.a])[local.s].doorclip != NIL && $(level.drivable_entities[local.a])[local.s].doorclip != NULL && $player[local.i] istouching $(level.drivable_entities[local.a])[local.s].doorclip)
					{
						$player[local.i].touching_playerboat = 1
					}
				}
			}
		}
		waitframe
	}

	thread touching_playerboat
end

////////////////////////////////////////////////////////////////////////

move_stuck_players:

	for(local.i = 1; local.i <= $player.size; local.i++)
	{
		if(isalive $player[local.i] && $player[local.i].dead != 1 && $player[local.i].dmteam != "spectator" && ($player[local.i] istouching self || (self.model == "models/vehicles/higginsxtrahull.tik" && $player[local.i] istouching self.doorclip)))
		{
			if($player[local.i] istouching self.doorclip) { local.add = 120 }
			else { local.add = 0 }
			$player[local.i].origin += (angles_toup self.angles * (self.outheight + local.add))
		}
	}
end

////////////////////////////////////////////////////////////////////////

keep_at_door local.doorclip local.door_open:

	if(self.door_open != 1) { local.height = 60; local.angle = 0; local.dist = 285 }
	else { local.height = -47; local.angle = 22; local.dist = 235 }
	self.door_count = 0

	while(self != NULL)
	{
		if(self.door_open != local.door_open && self.door_count >= 20)
		{
			self.door_count = 0
			if(self.door_open != 1) { local.height = 60; local.angle = 0; local.dist = 285 }
			else { local.height = -47; local.angle = 22; local.dist = 235 }
		}
		else { self.door_count++ }
		if(self.door_count >= 20) { self.door_count = 20 }

		if(self.movingbackward == 1) { local.direction = -1 }
		else { local.direction = 1 }

		local.doorclip.origin = self.origin + self.leftvector * 0 + self.forwardvector * local.dist + self.upvector * local.height + self.forwardvector * self.vehiclespeed * 0.075 * local.direction
		local.doorclip.angles = ( (self.angles[2] * -1) self.angles[1] self.angles[0] ) + ( 0 90 local.angle )

		local.door_open = self.door_open
		waitframe
	}
	local.doorclip remove
end

////////////////////////////////////////////////////////////////////////

display:

	if(game.game != "AA") { local.menu1 = "bastogne1"; local.menu2 = "bastogne2" }
	else { local.menu1 = "dday1"; local.menu2 = "dday2" }

	self stufftext ("globalwidgetcommand " + local.menu1 + " shader townhallwindow")
	self stufftext ("globalwidgetcommand " + local.menu1 + " fgcolor 1.00 1.00 1.00 1.00")
	self stufftext ("globalwidgetcommand " + local.menu1 + " bgcolor 0.50 0.50 0.50 0.00")
	self stufftext ("globalwidgetcommand " + local.menu1 + " fadein 0")
	self stufftext ("globalwidgetcommand " + local.menu1 + " menu " + local.menu1 + " 640 480 NONE 0")
	self stufftext ("globalwidgetcommand " + local.menu1 + " virtualres 1")
	self stufftext ("globalwidgetcommand " + local.menu1 + " fullscreen 1")

	self stufftext "globalwidgetcommand june6 borderstyle NONE"
	self stufftext "globalwidgetcommand june6 shader textures/hud/healthback"
	self stufftext "globalwidgetcommand june6 rect 16 420 16 64"
	self stufftext "globalwidgetcommand june6 fgcolor 1.00 1.00 1.00 1.00"
	self stufftext "globalwidgetcommand june6 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand june6 linkcvar phealth"
	self stufftext "globalwidgetcommand june6 statbar vertical 0 100"
	self stufftext "globalwidgetcommand june6 statbar_shader textures/hud/healthmeter"
	self stufftext "globalwidgetcommand june6 statbar_shader_flash textures/hud/healthmeterflash"

	self stufftext ("globalwidgetcommand " + local.menu2 + " fgcolor 1.00 1.00 1.00 1.00")
	self stufftext ("globalwidgetcommand " + local.menu2 + " bgcolor 0.50 0.50 0.50 0.00")
	self stufftext ("globalwidgetcommand " + local.menu2 + " fadein 0")
	self stufftext ("globalwidgetcommand " + local.menu2 + " menu " + local.menu2 + " 640 480 NONE 0")
	self stufftext ("globalwidgetcommand " + local.menu2 + " virtualres 1")
	self stufftext ("globalwidgetcommand " + local.menu2 + " fullscreen 1")

	self stufftext "globalwidgetcommand charliesector borderstyle NONE"
	self stufftext "globalwidgetcommand charliesector textalign left "
	self stufftext "globalwidgetcommand charliesector rect 40 470 150 20"
	self stufftext "globalwidgetcommand charliesector fgcolor 0.70 0.60 0.05 1.00"
	self stufftext "globalwidgetcommand charliesector bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand charliesector linkcvar phealth"
	self stufftext "globalwidgetcommand charliesector font facfont-20"
	self stufftext "globalwidgetcommand charliesector shader townhallwindow"

	self stufftext ("showmenu " + local.menu2)
	self stufftext ("showmenu " + local.menu1)
	self stufftext "set phealth 100"
end

////////////////////////////////////////////////////////////////////////

scriptmaster local.model:

level.mapname = getcvar "mapname"
local.master = spawn scriptmaster

if(level.boatscriptmaster != 1)
{
	local.master aliascache wavelaps sound/amb/Wave_Laps1.wav soundparms 1 0 1 0 200 4000 auto loaded maps level.mapname
	local.master aliascache riverdrive sound/amb/Amb_River.wav soundparms 2.0 0 1 0 200 4000 auto loaded maps level.mapname
	local.master aliascache impact_leavewater sound/null.wav soundparms .7 .4 1 .5 100 1600 auto loaded maps level.mapname
}

if(level.boatscriptmaster2 != 1 && local.model == "models/vehicles/uboat.tik")
{
	local.master aliascache rocketfireloop sound/amb/Amb_FirePlace.wav soundparms 2.0 0 1 0 400 5000 auto loaded maps level.mapname
	local.master aliascache grenadethrow sound/weapons/foley/Grenade_Throw.wav soundparms .9 .2 .8 .2 400 5000 weapon loaded maps level.mapname
	//local.master aliascache panzerschrecksndfire sound/weapons/fire/PanzershrekFire2.wav soundparms 1.5 0 .92 .15 500 9000 weapon loaded maps level.mapname

	local.master aliascache uboat_reload sound/weapons/fire/TankFire1.wav soundparms 1.5 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache uboat_snd_fire1 sound/weapons/fire/TankCannonFire1.wav soundparms 1.5 0 1 0 2000 5000 weapon loaded maps level.mapname
	local.master aliascache uboat_snd_fire2 sound/weapons/fire/Flak88Fire1.wav soundparms 1.5 0 1 0 2000 5000 weapon loaded maps level.mapname
	local.master aliascache uboat_snd_fire3 sound/weapons/fire/Flak88Fire3.wav soundparms 1.5 0 1 0 2000 5000 weapon loaded maps level.mapname
	local.master aliascache uboat_snd_fire4 sound/weapons/fire/Flak88Fire4.wav soundparms 1.5 0 1 0 2000 5000 weapon loaded maps level.mapname
	level.boatscriptmaster2 = 1
}

local.soundtype = 2
if(level.vehiclescriptmaster[local.soundtype] != NIL) { end }
level.vehiclescriptmaster[local.soundtype] = 1

if(local.soundtype == 2 && level.mapname != "training" && level.mapname != "m3l3" && level.mapname != "m5l2a")
{
	local.master aliascache sdkfz_snd_idle sound/vehicle/veh_track_idle.wav soundparms .5 0 1 0 800 4000 auto loaded maps level.mapname
}

if(local.soundtype == 2 && level.mapname != "m3l3" && level.mapname != "m5l2a")
{
	local.master aliascache sdkfz_snd_run sound/vehicle/veh_track_move.wav soundparms 1.5 0 1 0 1000 6000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_revup sound/vehicle/veh_track_revup.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_revdown sound/vehicle/veh_track_revdown.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_shift1 sound/vehicle/veh_track_shiftin.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_shift2 sound/vehicle/veh_track_shiftout.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_on sound/vehicle/veh_track_on.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_start sound/vehicle/veh_track_on.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_off sound/vehicle/veh_track_off.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_stop sound/vehicle/veh_track_off.wav soundparms 1.5 0 1 0 1000 6000 auto loaded maps level.mapname
	local.master aliascache sdkfz_tread_snd_dirt sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_tread_snd_stone sound/vehicle/veh_tread_metal.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_tread_snd_grass sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_tread_snd_wood sound/vehicle/veh_tread_metal.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_tread_snd_mud sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_doorclose sound/null.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_dooropen sound/null.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
}

if(local.soundtype == 2 && level.mapname != "m3l3" && level.mapname != "m5l2a" && level.mapname != "m5l2b")
{
	local.master aliascache sdkfz_vehicle_crash1 sound/null.wav soundparms .7 .4 1 .5 100 1600 auto loaded maps level.mapname
}

if(level.vehiclescriptmaster2 != 1 && level.mapname != "m1l3a" && level.mapname != "m1l3b" && level.mapname != "m4l1")
{
	local.master aliascache explode_truck1 sound/weapons/explo/Explo_MetalMed1.wav soundparms 1.2 .2 .8 .2 1500 8000 weapon loaded maps level.mapname
}

if(level.vehiclescriptmaster2 != 1 && level.mapname != "m1l3a" && level.mapname != "m1l3b")
{
	local.master aliascache explode_truck2 sound/weapons/explo/Explo_MetalMed2.wav soundparms 1.2 .2 .8 .2 1500 8000 weapon loaded maps level.mapname
	local.master aliascache explode_truck3 sound/weapons/explo/Explo_MetalMed3.wav soundparms 1.2 .2 .8 .2 1500 8000 weapon loaded maps level.mapname
	local.master aliascache explode_truck4 sound/weapons/explo/Explo_MetalMed4.wav soundparms 1.2 .2 .8 .2 1500 8000 weapon loaded maps level.mapname
	local.master aliascache explode_truck5 sound/weapons/explo/Explo_MetalMed5.wav soundparms 1.2 .2 .8 .2 1500 8000 weapon loaded maps level.mapname
}

if(level.vehiclescriptmaster2 != 1 && level.mapname != "m5l1a" && level.mapname != "m5l1b" && level.mapname != "m5l2a" && level.mapname != "m5l2b" && level.mapname != "m5l3")
{
	local.master aliascache damage_vehicle1 sound/null.wav soundparms .7 .4 .9 .2 160 1600 auto loaded maps level.mapname
}

if(level.vehiclescriptmaster3 != 1)
{
	local.master aliascache sndfire30cal sound/weapons/fire/50CalFire2.wav soundparms 1.05 .2 .95 .1 800 4000 weapon loaded maps level.mapname

	local.master aliascache vehicledeathfire sound/amb/fire.wav soundparms 1.2 0.0 1.0 0.0 200 2000 auto loaded maps level.mapname
	local.master aliascache vehicledeathwater sound/mechanics/Mec_WaterLoop_03.wav soundparms 1.2 0.0 1.0 0.0 200 2000 auto loaded maps level.mapname
}

if(level.vehiclescriptmaster4 != 1)
{
	local.master aliascache higgins_door_open sound/mechanics/DoorHatchOpen_02.wav soundparms 1.5 0.0 1.0 0.0 160 1600 item loaded maps level.mapname
	local.master aliascache higgins_door_close sound/mechanics/DoorMetalClose_stop1.wav soundparms 1.5 0.2 0.8 0.2 160 1600 item loaded maps level.mapname
	local.master aliascache higgins_door_close sound/mechanics/DoorMetalClose_stop3.wav soundparms 1.5 0.2 0.8 0.2 160 1600 item loaded maps level.mapname
}

level.boatscriptmaster = 1
level.vehiclescriptmaster2 = 1
level.vehiclescriptmaster3 = 1
level.vehiclescriptmaster4 = 1
end
