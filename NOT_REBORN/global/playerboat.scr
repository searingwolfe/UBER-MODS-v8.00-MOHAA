main local.name local.model local.origin local.angles local.health local.vehiclespeed local.resettime local.scale local.gotout local.door_open:

	if(local.model == NIL) { wait 1; println("----- ERROR playerboat.scr: 'model' parameter is missing!"); end }
	if(local.model[0] != "m" && local.model[1] != "o" && local.model[2] != "d" && local.model[3] != "e" && local.model[4] != "l" && local.model[5] != "s")
	{
		local.model = "models/" + local.model
		if(local.model == "models/vehicles/higgins.tik") { local.model = "models/vehicles/higginsxtrahull.tik" }
		if(level.vehiclescriptmaster[local.model] != 1) { cache local.model }
	}

	if($(local.name) != NULL) 
	{
		waitframe; if($(local.name) != NULL) { waitframe; if($(local.name) != NULL) { waitframe; if($(local.name) != NULL) { waitframe; if($(local.name) != NULL) { waitframe } } } }
		if($(local.name) != NULL)
		{
			if(level.vehiclescriptmaster[local.model] != 1) { wait 1; println("----- ERROR playerboat.scr: $" + local.name + " must be removed before spawning a drivable boat.") }
			end
		}
	}

	if(local.health == NIL || (local.health != NIL && local.health <= 0 && level.vehiclescriptmaster[local.model] != 1)) { wait 1; println("----- ERROR playerboat.scr: health must be greater than 0."); end }
	if(local.health == NIL || (local.health != NIL && local.health <= 0 && level.vehiclescriptmaster[local.model] == 1)) { end } // end when in rare cases, a 2nd vehicle with local.health = 0 could spawn after getting destroyed

	local.vehicle = spawn local.model targetname (local.name) // scriptmasters are already added in ubersound.scr
	local.vehicle.name = local.name
	local.vehicle.origin = local.origin
	local.vehicle.angles = local.angles
	local.vehicle.health = local.health
	local.vehicle.vehiclespeed = local.vehiclespeed
	local.vehicle.vehiclespeed_max = local.vehiclespeed
	local.vehicle.resettime = local.resettime
	if(local.scale == NIL || local.vehicle.model != "models/vehicles/uboat.tik") { local.vehicle.scale = 1 }
	else
	{
		local.vehicle.scale = local.scale
		local.vehicle setsize ( -(2000 * local.scale) -(150 * local.scale) 0 ) ( (1820 * local.scale) (150 * local.scale) (140 * local.scale) )
	}

	if(local.vehicle.classname != "DrivableVehicle") { local.vehicle remove; wait 1; println("----- ERROR playerboat.scr: .tik model is not a DrivableVehicle."); end }

	local.vehicle thread vehicle_settings local.gotout local.door_open // includes seatstuff, gotout playsound, desmodel, outheight, turnrate, higgins_door stuff, etc.
	local.vehicle thread vehiclereset
	local.vehicle thread vehicledamage
	local.vehicle thread vehicledeath
	local.vehicle thread vehicletrigger
	local.vehicle thread move_stuck_players // the vehicle might respawn on top of other players, move them onto the top of it.

	if(level.boat_initorigin[local.name] == NIL) { level.boat_initorigin[local.name] = local.origin } // store the initial origin/angles as level variable arrays
	if(level.boat_initangles[local.name] == NIL) { level.boat_initangles[local.name] = local.angles }
	if(level.boat_inithealth[local.name] == NIL) { level.boat_inithealth[local.name] = local.health }

										// "local.player.touching_playerboat" or "$player[1].touching_playerboat" can be included in trigger setthreads
	if(level.touching_playerboat != 1) { thread touching_playerboat }	// to exclude teleporting players that are touching "$ocean" or similar water-surface triggers.

	if(level.chainreactors == NIL || (level.chainreactors != NIL && level.chainreactors.size < 1)) { level.chainreactors[1] = local.vehicle }
	else
	{
		for(local.c = 1; local.c <= 999; local.c++)
		{
			if(level.chainreactors[local.c] == NIL)
			{
				level.chainreactors[local.c] = local.vehicle
				local.vehicle thread chainreactors_remove local.c
				break
			}
		}
	}

	if(level.drivable_entities == NIL) { level.drivable_entities[1] = local.name }
	else
	{
		for(local.d = 1; local.d <= level.drivable_entities.size; local.d++)
		{
			if(level.drivable_entities[local.d] == local.name) { end }
		}
		level.drivable_entities[level.drivable_entities.size + 1] = local.name
	}
end

chainreactors_remove local.c:

	while(self != NULL) { waitframe }
	level.chainreactors[local.c] = NIL
end

////////////////////////////////////////////////////////////////////////

vehiclereset:

	self thread healthboost
	removeclass Camera // also removes PlayerIntermission and other func_cameras
end

healthboost: // shotgun: 340 damage, bazooka: 105 damage, sniper: 106 damage, one grenade: 200 damage, two grenades: 400 damage

	local.health = self.health
	while(self != NULL && self.health > 0)
	{
		if(self.damagetrig != NIL && self.damagetrig != NULL && self.damagetrig.health < local.health && self.damagetrig.health > 0) { self.health = self.damagetrig.health }
		if(self.health < local.health)
		{
			for(local.i = 1; local.i <= self.passengers.size; local.i++)
			{
				local.damage = ((local.health - self.health) / (3 + self.passengers.size))
				if(self.passengers[local.i] != NIL && self.passengers[local.i] != NULL && self.shooter != NIL)
				{
					self.passengers[local.i] takedamage
					if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.passengers[local.i] damage self.shooter.player_owner local.damage self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.passengers[local.i] damage self.shooter.owner local.damage self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					else { self.passengers[local.i] damage self.shooter local.damage self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					self.passengers[local.i] nodamage
				}
			}
			if(self.driver != NIL && self.driver != NULL)
			{
				if(self.driver.health > 1)
				{
					self.driver takedamage
					if(self.passengers != NIL && self.passengers.size >= 1) { local.damage = ((local.health - self.health) / (3 + self.passengers.size)) }
					else { local.damage = ((local.health - self.health) / 3) }

					if(self.shooter != NIL)
					{
						if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.driver damage self.shooter.player_owner local.damage self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
						else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.driver damage self.shooter.owner local.damage self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
						else { self.driver damage self.shooter local.damage self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					}
					//else { self.driver damage $world local.damage $world (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 } // this may cause drivers to randomly die by running over stuff, even though "damagehandler.scr" script does not detect any damage dealt.
					self.driver nodamage
				}
				else
				{
					self thread driverreset 1
					self thread vehiclereset

					if(self.shooter != NIL)
					{
						if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.driver damage self.shooter.player_owner 9999999 self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
						else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.driver damage self.shooter.owner 9999999 self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
						else { self.driver damage self.shooter 9999999 self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					}
					//else { self.driver damage $world 9999999 $world (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 } // this may cause drivers to randomly die by running over stuff, even though "damagehandler.scr" script does not detect any damage dealt.
					self.driver = NIL
				}
			}
		}

		for(local.i = 1; local.i <= $player.size; local.i++)
		{
			if(self != NULL && $player[local.i].isdog == 1 && $("dogmouthtrig_" + $player[local.i].entnum).biting == 1 && ($("dogmouthtrig_" + $player[local.i].entnum) istouching self || (self.damagetrig != NIL && $("dogmouthtrig_" + $player[local.i].entnum) istouching self.damagetrig) || (self.trigshot != NIL && $("dogmouthtrig_" + $player[local.i].entnum) istouching self.trigshot)) && $player[local.i].passenger != 1 && $player[local.i].turreting != 1 && $player[local.i].driving != 1)
			{
				self.shooter = $player[local.i]
				for(local.i = 1; local.i <= self.passengers.size; local.i++)
				{
					self.passengers[local.i] takedamage
					self.passengers[local.i] damage $player[local.i] 15000 $player[local.i] (0 0 0) (0 0 0) (0 0 0) 0 9 0 0
				}
				if(self.driver != NIL && self.driver != NULL && self.model != "models/vehicles/sdkfz.tik" && self.model != "models/vehicles/sdkfz_afrika.tik" && self.model != "models/vehicles/shermantank.tik")
				{
					self.driver takedamage
					self.driver damage $player[local.i] 15000 $player[local.i] (0 0 0) (0 0 0) (0 0 0) 0 9 0 0
				}
			}
		}

		if(isalive self) // need "isalive" check to avoid "cannot give health to dead entities" error
		{
			self.health = local.health
			if(self.damagetrig != NIL && self.damagetrig != NULL && self.damagetrig.health > 0) { self.damagetrig.health = local.health }
		}

		if(self.shooter != NIL) { self thread shooter_NIL }
		if(self.nodamage == 1) { self.nodamage = 0; self takedamage }
		waitframe
	}
end

shooter_NIL:

	waitframe
	if(self != NULL) { self.shooter = NIL }
end

vehicletrigger:

	if($(self.name + "_trig") != NULL) { $(self.name + "_trig") remove }
	local.trig = spawn trigger_use targetname (self.name + "_trig")
	local.trig.origin = self.origin
	if(self.model != "models/vehicles/uboat.tik") { local.trig setsize ( -130 -130 -100 ) ( 130 130 100 ) }
	else { local.trig setsize ( -(2000 * self.scale) -(150 * self.scale) -(10 * self.scale) ) ( (1820 * self.scale) (150 * self.scale) (200 * self.scale) ) }
	local.trig.vehicle = self
	local.trig glue self
	local.trig setthread triggered
end

triggered:

	local.player = parm.other
	if(local.player.classname != Player) { end }
	if(self.vehicle == NULL || self.vehicle.dead == 1 || local.player == NIL || local.player == NULL || local.player.enteringvehicle == 1 || !isalive local.player || local.player.dead == 1 || level.change_team_score == 1 || level.bbactive == 0 || local.player.driving == 1 || local.player.passenger == 1 || local.player.flying == 1 || local.player.missile != NIL || (local.player getcontrollerangles 0)[2] > 15 || (local.player getcontrollerangles 0)[2] < -15) { end }

	if(self.vehicle != NULL)
	{
		if(self.vehicle.driver != NIL)
		{
			if(self.vehicle.passengers.size < self.vehicle.seats) { self.vehicle thread passengers }
			else { local.player iprint "There are no seats available." }
		}
		else { self.vehicle thread playergetin }
	}
end

playergetin:

	local.player = parm.other
	if(local.player.classname != Player) { end }
	local.team = local.player.dmteam
	if(self.attachingdriver == 1) { end }
	self.attachingdriver = 1
	local.player.enteringvehicle = 1

	local.player iprint "Entering vehicle... JUMP to use passenger seats."

	for(local.s = 1; local.s <= self.seats; local.s++)
	{
		if(self.passengers[local.s] != NIL && self.passengers[local.s] != NULL && (self.passengers[local.s].dmteam != local.player.dmteam || getcvar("g_gametype") == "1")) { local.cancel = 1 }
	}
	if(local.cancel == 1)
	{
		local.player iprint "An enemy player is in this vehicle!"
		local.player.enteringvehicle = 0
		self.attachingdriver = 0
		end
	}

	local.player safeholster 1
	local.c = 0
	local.standing = 0
	while(self != NULL && local.player != NULL && local.c <= 20) // wait 1
	{
		for(local.s = 1; local.s <= self.seats; local.s++)
		{
			if(self.passengers[local.s] == NIL) { break }
		}
		if(local.player getposition != "standing" && local.standing == 1 && local.s <= self.seats && local.player getmovement != "falling")
		{
			local.player safeholster 0
			local.player.enteringvehicle = 0
			self.attachingdriver = 0
			self thread passengers
			end
		}

		if(local.player getposition == "standing") { local.standing = 1 }
		local.c++
		waitframe
	}

	if(self == NULL || self.dead == 1 || self.driver != NIL || local.player == NIL || local.player == NULL || !isalive local.player || local.player.dmteam != local.team || local.player.dead == 1 || level.change_team_score == 1 || level.bbactive == 0 || local.player.driving == 1 || local.player.passenger == 1 || local.player.flying == 1 || local.player.missile != NIL)
	{
		if(self != NULL) { self.attachingdriver = 0 }
		if(local.player != NULL) { local.player.enteringvehicle = 0 }
		end
	}
	if((local.player getcontrollerangles 0)[2] > 15 || (local.player getcontrollerangles 0)[2] < -15)
	{
		if(self != NULL) { self.attachingdriver = 0 }
		local.player.enteringvehicle = 0
		local.player safeholster 0
		local.player iprint "You canceled entering vehicle by leaning left/right."
		end
	}
	if(local.player.isdog == 1)
	{
		if(self != NULL) { self.attachingdriver = 0 }
		local.player.enteringvehicle = 0
		local.player iprint ("Dogs cannot drive vehicles.")
		end
	}

	self.driver = local.player
	self.driver.driving = 1
	self.driver.drivingent = self
	local.driver = self.driver
	self.player_owner = self.driver
	self.passengers[0] = NIL // initialize as array to make size = 0 instead of size = -1

	self.driver forcelegsstate STAND
	//self.driver hide
	self.driver nodamage // keep this off until the player receives damage, then quickly do "takedamage" and give damage, before doing "nodamage" again in "healthboost" thread (allows for more damage types such as bazooka rockets to count as kills).
	self.driver notsolid
	self.driver.driving_state_jump = 0
	if(self.model == "models/vehicles/uboat.tik")
	{
		self.driver iprint ("press A - D (left-right keys) = aim turret down/up.")
		self.driver iprint ("JUMP = exit boat... FIRE = shoot rockets... FIRE + USE(e) = throw grenades.")

		self attachmodel models/emitters/fancyfire.tik "Box01" 1 (self.name + "_tag_barrel") 1 -1 -1 -1 -1 ( 0 211 565 ) //( +left -right, +up -down, +forward -backward )
		$(self.name + "_tag_barrel") notsolid
		$(self.name + "_tag_barrel") hide
		self.gun = $(self.name + "_tag_barrel")
		self thread turret_laser self.name
	}
	else { self.driver iprint ("JUMP = exit boat... hold FIRE = look behind... press A - D (left-right keys) = close/open door.") }

	local.spray1 = spawn script_model targetname (self.name + "_sprayleft") // only spawn these when a driver enters a boat, to reduce entity count.
	local.spray1 model "animate/fx_water_spray.tik"
	local.spray1 notsolid
	self.sprayleft = local.spray1
	local.spray2 = spawn script_model targetname (self.name + "_sprayright")
	local.spray2 model "animate/fx_water_spray.tik"
	local.spray2 notsolid
	self.sprayright = local.spray2
	self thread keep_at_boat local.spray1 local.spray2

	self attachdriverslot 0 self.driver
	self thread dummyavatar
	self.driver loopsound wavelaps
	self.turretlaser_offset = 0

	self waitthread spawn_driver_seat_and_trigs
	if($("driver_seat_" + self.entnum) != NULL) { self.driver glue $("driver_seat_" + self.entnum) }

	if(local.driver.using_pack == 1)
	{
		local.driver stufftext "globalwidgetcommand june6 linkcvar phealth"
		local.driver stufftext "globalwidgetcommand june6 statbar vertical 0 100"
		local.driver stufftext "globalwidgetcommand charliesector linkcvar phealth"
		local.driver stufftext ("set phealth " + int(local.driver.health))
	}
	else { local.driver thread display }

	local.c = 5.000		// boat speed divisor; Higher = starting speed is much slower (total change is larger), Lower = starting speed is closer to max speed (total change is smaller).
	local.decel_rate = 30	// how many divisions of local.c for deceleration/acceleration. Higher = more time to reach max speed, Lower = less time to reach max speed.
	local.deceleration = local.c
	local.drivervelocity_old = ( 0 0 0 )
	self.movingforward = 0
	self.movingbackward = 0
	local.d = local.c	// vehicle turnrate will increase equally when accelerating, but will decrease 4x as fast when decelerating.

	local.player.enteringvehicle = 0
	self.attachingdriver = 0
	while(self != NULL && self.dead != 1 && isalive self.driver && self.driver.dmteam == local.team && self.driver.dead != 1 && level.change_team_score != 1 && level.bbactive != 0)
	{
		self.driver.viewangles = ( (self.angles[0] + 10) self.angles[1] self.angles[2] )

		if(self.driver.driving_state_jump == 1) // Press JUMP to exit.
		{
			self thread driverreset
			self thread vehiclereset
			self.driver thread wallstuck_fix
			self.driver = NIL
			break
		}

		if(self.model == "models/vehicles/uboat.tik")
		{
			if(self.turretlaser != NIL && self.turretlaser != NULL)
			{
				local.fwd_vec = angles_toforward ( (self.angles[0] + self.turretlaser_offset) self.angles[1] self.angles[2] )
				local.start = $(self.targetname + "_tag_barrel").origin
				local.groundtarget = trace (local.start + local.fwd_vec * 56) (local.start + local.fwd_vec * 10240) 0

				self.turretlaser.origin = $(self.targetname + "_tag_barrel").origin
				self.turretlaser endpoint local.groundtarget
				self.turretlaser_point.origin = local.groundtarget
			}

			if(self.driver.fireheld == 1)
			{
				if(self.driver.useheld != 1) { self thread firegun } 
				else { self thread firesecondary }
			}

			if(self.driver.fireheld != 1 && self.driver.driving_state_left == 1 || self.driver.driving_state_right == 1)
			{
				if(self.turretlaser != NIL && self.turretlaser != NULL)
				{
					if(self.driver.driving_state_left != 1 && self.driver.driving_state_right == 1)
					{
						if(self.turretlaser_offset > -15) { self.turretlaser activate; self.turretlaser_point show; self.turretlaser_offset -= .25 }
						else { self.turretlaser deactivate; self.turretlaser_point hide; self.turretlaser_offset = -15 }
					}

					if(self.driver.driving_state_left == 1 && self.driver.driving_state_right != 1)
					{
						if(self.turretlaser_offset < 3) { self.turretlaser activate; self.turretlaser_point show; self.turretlaser_offset += .25 }
						else { self.turretlaser deactivate; self.turretlaser_point hide; self.turretlaser_offset = 3 }
					}
					if(self.driver.driving_state_left != 1 && self.driver.driving_state_right != 1) { self.turretlaser deactivate; self.turretlaser_point hide }
				}
			}
			else { self.turretlaser deactivate; self.turretlaser_point hide }
		}
		else
		{
			if(self.driver.fireheld == 1) { self.driver.viewangles = ( (10 + self.angles[0] * -1) (self.angles[1] + 180) (self.angles[2] * -1) ) }

			if(self.driver.driving_state_left == 1 && local.toggle != 1 && self.door_open == 1 && self.door_count >= 20) // press A (left key) to close higgins door
			{
				//self.driver iprint "Closing the higgins door."
				self.doorclip playsound higginsdoor_close
				self.dooropen hide
				self.doorclosed show
				self.door_open = 0
				local.toggle = 1
			}
			if(self.driver.driving_state_right == 1 && local.toggle != 1 && self.door_open != 1 && self.door_count >= 20) // press D (right key) to open higgins door
			{
				//self.driver iprint "Opening the higgins door."
				self.doorclip playsound higginsdoor_open
				self.dooropen show
				self.doorclosed hide
				self.door_open = 1
				local.toggle = 1
			}
			if(self.driver.driving_state_left != 1 && self.driver.driving_state_right != 1) { local.toggle = 0; local.toggle2 = 0 }
		}

		if(self.driver.viewangles[0] > 180) { self.driver.viewangles = ( (10 + (self.angles[0] - 360)) self.driver.viewangles[1] self.driver.viewangles[2] ) } // any viewangles[0] +/- 180 will cause camera issues (going under vehicle).
		if(self.driver.viewangles[0] < -180) { self.driver.viewangles = ( (self.driver.viewangles[0] + 360) self.driver.viewangles[1] self.driver.viewangles[2] ) } // prevent camera from moving too far down.

		if(self.vehiclespeed == 0) { self.movingforward = 0; self.movingbackward = 0 }

		if(self.velocity != ( 0 0 0 )) // make boats drive faster in reverse, only when holding S (walk backwards key) and when holding FIRE (looking behind).
		{
			self.driver loopsound riverdrive

			if(self.driver.driving_state_backward == 1)
			{
				if(self.movingforward == 1 && local.c < local.deceleration) // slowing down, before reversing begins.
				{
					local.c += local.deceleration * 2.000 / local.decel_rate
					local.d += 4.000 * local.deceleration / local.decel_rate
					if(local.c > local.deceleration) { local.c = local.deceleration; self.vehiclespeed = 0 }
					if(local.d > local.deceleration) { local.d = local.deceleration }
					self.vehiclespeed = self.vehiclespeed_max / local.c
					self.velocity = self.driver.velocity * (self.vehiclespeed / self.vehiclespeed_max * -1) + self.forwardvector * self.vehiclespeed
				}
				else
				{
					local.c -= local.deceleration / local.decel_rate
					local.d -= local.deceleration / local.decel_rate
					if(local.c < 1) { local.c = 1 }
					if(local.d < 1) { local.d = 1 }
					self.vehiclespeed = self.vehiclespeed_max / local.c
					self.velocity = self.driver.velocity + self.forwardvector * self.vehiclespeed * -0.500 // only reverse at half the maximum boat speed
					self.movingforward = 0
					self.movingbackward = 1
				}
			}
			else // make boats drive faster, only when holding W (forward key).
			{
				if(self.movingbackward == 1 && local.c < local.deceleration) // slowing down, before driving forward begins.
				{
					local.c += local.deceleration * 2.000 / local.decel_rate
					local.d += 4.000 * local.deceleration / local.decel_rate
					if(local.c > local.deceleration) { local.c = local.deceleration; self.vehiclespeed = 0 }
					if(local.d > local.deceleration) { local.d = local.deceleration }
					self.vehiclespeed = self.vehiclespeed_max / local.c
					self.velocity = self.driver.velocity * (self.vehiclespeed / self.vehiclespeed_max * -1) + self.forwardvector * self.vehiclespeed * -0.500 // only reverse at half the maximum boat speed
				}
				else
				{
					local.c -= local.deceleration / local.decel_rate
					local.d -= local.deceleration / local.decel_rate
					if(local.c < 1) { local.c = 1 }
					if(local.d < 1) { local.d = 1 }
					self.vehiclespeed = self.vehiclespeed_max / local.c
					self.velocity = self.driver.velocity + self.forwardvector * self.vehiclespeed
					self.movingforward = 1
					self.movingbackward = 0
				}
			}

			if(self.turningrate / local.d < 1) { self.turnrate = 1 }
			else if(self.turningrate / local.d < self.turningrate) { self turnrate (self.turningrate / (local.d * 0.500)) }
			else { self turnrate self.turningrate }
		}
		else
		{
			self.driver loopsound wavelaps
			if(local.c == 1) { self playsound sdkfz_snd_shift2 }

			local.d += 4.000 * local.deceleration / local.decel_rate
			if(local.d > local.deceleration) { local.d = local.deceleration }

			local.c += local.deceleration / local.decel_rate
			if(local.c > local.deceleration) { local.c = local.deceleration; self.vehiclespeed = 0 }
			else { self.vehiclespeed = self.vehiclespeed_max / local.c }

			if(self.driver.driving_state_backward == 1) { self.velocity = local.drivervelocity_old + self.forwardvector * self.vehiclespeed * -1 }
			else { self.velocity = local.drivervelocity_old + self.forwardvector * self.vehiclespeed }
		}

		local.drivervelocity_old = self.driver.velocity
		waitframe
	}

	if(self != NULL) // spawn in the new vehicle and remove the old one.
	{
		thread main self.name self.model self.origin self.angles self.health self.vehiclespeed_max self.resettime self.scale 1 self.door_open

		if(self.driver != NIL && self.driver != NULL)
		{
			if(self.driver.dmteam == local.team && level.change_team_score != 1 && level.bbactive != 0) { self thread driverreset }
			else { self thread driverreset 2 } // if the player switched teams without dying, make sure they don't tele back to the vehicle
			self thread vehiclereset
		}

		if(self != NULL)
		{
			self.driver = NIL // the old vehicle must be properly removed, otherwise the server will crash if anyone driving the vehicle leaves the game (becomes NULL).
			if(self.dead != 1) { self remove }
		}
	}
	waitframe
	if(local.driver != NULL)
	{
		local.driver.driving = 0
		local.driver.passenger = 0
		local.driver.drivingent = NIL
		local.driver stoploopsound
		if(!isalive local.driver) { local.driver stufftext ("set phealth 0") }

		if(local.driver.using_pack == 1)
		{
			local.driver stufftext "globalwidgetcommand june6 linkcvar fuel"
			local.driver stufftext ("globalwidgetcommand june6 statbar vertical 0 " + level.jetpack_max_fuel)
			local.driver stufftext "globalwidgetcommand charliesector linkcvar fuel"
		}
		else
		{
			local.driver stufftext "hidemenu dday1"
			local.driver stufftext "hidemenu dday2"
		}

		local.origin = local.driver.origin
		while(local.driver != NULL && !isalive local.driver && local.driver.dmteam != "spectator")
		{
			local.driver.origin = ( local.origin[0] local.origin[1] local.driver.origin[2] ) // for some reason, drivers' dead bodies would move forward across the ground until they hit a wall.
			local.driver notsolid
			local.driver droptofloor
			waitframe
		}
	}
end

driverreset local.status:

	if(self.driver == NIL) { end } // if the vehicle blew up with nobody driving it, end this thread.

	if(local.status != 1) { cueplayer }				// reattaches camera to player's head
	self detachdriverslot 0 self.driver
	self.driver.viewangles = ( 0 self.driver.viewangles[1] 0 )
	if($("driver_seat_" + self.entnum) != NULL) { self.driver unglue }
	self.driver exit	// not needed, but added as a redundancy.
	self.driver.driving = 0
	self.driver.passenger = 0

	if(local.status != 2)
	{
		self.driver show
		if(local.status != 1) { self.driver solid }
		self.driver takedamage
		self.driver forcetorsostate STAND // without this, players will be stuck in noclip mode, even though noclip isn't used for drivers (doing "self.driver noclip; self driver noclip" also works).
		self.driver forcelegsstate STAND
		self.driver.origin += (angles_toup self.angles * self.outheight)
		self.driver.viewangles = ( self.driver.viewangles[0] self.driver.viewangles[1] 0 )
	}
	else { self.driver respawn }
end

vehicledamage:

	local.c = 0
	while(self != NULL && self.health > 0)
	{
		if(self != NULL)
		{
			local.previoushealth = self.health
			if(local.c > 0) { local.c-- }
		}
		waitframe
		if(self != NULL && local.previoushealth > self.health)
		{
			local.c = local.c + 2
			self playsound damage_vehicle
			//if(local.c == 2) { exec global/earthquake.scr .2 3 0 0 } // if boat is getting constantly damaged per frame, stop earthquake from spamming. (removed, since it was still getting annoying)
		}
	}
end

vehicledeath:

	self waittill death // when waiting until "death", vehicle is not NULL yet
	self stoploopsound
	self playsound explode_truck
	self.dead = 1

	if(self.desmodel == NIL) { self.desmodel = self.model }
	local.desvehicle = spawn script_model
	local.desvehicle.origin = self.origin + ( 0 0 -25 )
	local.desvehicle.scale = self.scale
	local.desvehicle model self.desmodel
	local.desvehicle playsound boatsinkwave
	local.desvehicle thread move_stuck_players

	local.died_touching_water = 0
	local.waterheight = -9999
	if(level.water_volumes != NIL && level.water_volumes != 0)
	{
		for(local.v = 1; local.v <= level.water_volumes.size; local.v++)
		{
			local.X_min[local.v] = level.water_volumes[local.v][1][0] + level.water_volumes[local.v][2][0]
			local.X_max[local.v] = level.water_volumes[local.v][1][0] + level.water_volumes[local.v][3][0]
			local.Y_min[local.v] = level.water_volumes[local.v][1][1] + level.water_volumes[local.v][2][1]
			local.Y_max[local.v] = level.water_volumes[local.v][1][1] + level.water_volumes[local.v][3][1]
			local.Z_min[local.v] = level.water_volumes[local.v][1][2] + level.water_volumes[local.v][2][2]
			local.Z_max[local.v] = level.water_volumes[local.v][1][2] + level.water_volumes[local.v][3][2]
			local.origin = local.desvehicle.origin
	
			if(int(local.origin[0]) >= local.X_min[local.v] && int(local.origin[0]) <= local.X_max[local.v] && int(local.origin[1]) >= local.Y_min[local.v] && int(local.origin[1]) <= local.Y_max[local.v] && int(local.origin[2]) >= local.Z_min[local.v] && int(local.origin[2]) <= local.Z_max[local.v])
			{
				local.died_touching_water = 1
				local.waterheight = local.Z_max[local.v]
			}
		}
	}

	if(self.model != "models/vehicles/uboat.tik") { local.distance = -100 }
	else { local.distance = 355; local.distance2 = 675 }

	if(self.angles[2] > 5 && self.angles[2] < 180) { local.one = 1 }
	if(self.angles[2] > 180 && self.angles[2] < 355) { local.one = -1 }
	if(self.angles[2] <= 5 || self.angles[2] >= 345)
	{
		local.r = randomint(2)
		if(local.r == 0) { local.one = 1 }
		if(local.r == 1) { local.one = -1 }
	}

	if(self.model == "models/vehicles/uboat.tik")
	{
		local.desvehicle.angles = self.angles + ( 0 0 ((randomint(20) + 15) * local.one) )

		local.fire = spawn script_model
		local.fire model "models/emitters/fancyfire.tik"
		local.fire.origin = local.desvehicle.origin + local.desvehicle.forwardvector * local.distance + angles_toup local.desvehicle.angles * 150 * local.desvehicle.scale
		local.fire.angles = ( 0 0 0 )
		local.fire.scale = 5 * local.desvehicle.scale
		local.fire anim start
		local.fire notsolid
		local.fire loopsound vehicledeathfire
		local.smoke = spawn script_model
		local.smoke model "models/emitters/thin_black_short.tik"
		local.smoke.origin = local.desvehicle.origin + local.desvehicle.forwardvector * local.distance + angles_toup local.desvehicle.angles * 150 * local.desvehicle.scale
		local.smoke.angles = ( 0 0 0 )
		local.smoke.scale = 3.5 * local.desvehicle.scale
		local.smoke anim start
		local.smoke notsolid
		local.fire2 = spawn script_model
		local.fire2 model "models/emitters/fancyfire.tik"
		local.fire2.origin = local.desvehicle.origin + local.desvehicle.forwardvector * local.distance2 * -1 + angles_toup local.desvehicle.angles * 150 * local.desvehicle.scale
		local.fire2.angles = ( 0 0 0 )
		local.fire2.scale = 5 * local.desvehicle.scale
		local.fire2 anim start
		local.fire2 notsolid
		local.fire2 loopsound vehicledeathfire
		local.smoke2 = spawn script_model
		local.smoke2 model "models/emitters/thin_black_short.tik"
		local.smoke2.origin = local.desvehicle.origin + local.desvehicle.forwardvector * local.distance2 * -1 + angles_toup local.desvehicle.angles * 150 * local.desvehicle.scale
		local.smoke2.angles = ( 0 0 0 )
		local.smoke2.scale = 3.5 * local.desvehicle.scale
		local.smoke2 anim start
		local.smoke2 notsolid

		local.spray1 = spawn script_model
		local.spray1 model animate/fx_water_spray.tik
		local.spray1.origin = local.desvehicle.origin + local.desvehicle.forwardvector * 100 + local.desvehicle.upvector * 20
		local.spray1 anim start
		local.spray1 loopsound boatsinking
		local.spray2 = spawn script_model
		local.spray2 model animate/fx_water_spray.tik
		local.spray2.origin = local.desvehicle.origin + local.desvehicle.forwardvector * -650 + local.desvehicle.upvector * 20
		local.spray2 anim start
		local.spray2 loopsound boatsinking
	}
	else
	{
		local.desvehicle.angles = self.angles + ( 0 0 ((randomint(30) + 5) * local.one) )

		local.desvehicle attachmodel models/static/jug.tik "Box01" 1 (self.targetname + "_d_doorglue") 1 -1 -1 -1 -1 ( 0 0 0 ) //( -forward +backward, +up -down, +left -right )
		$(self.targetname + "_d_doorglue") notsolid

		if(self.door_open == 1)
		{
			$(self.targetname + "_d_doorglue") attachmodel models/vehicles/higginsdoor.tik "Box06" 1 (self.targetname + "_d_dooropen") 1 -1 -1 -1 -1 ( 309 0 -225 ) //( +up -down, +left -right, -forward +backward )
			$(self.targetname + "_d_dooropen").angles = ( 0 180 180 )
			$(self.targetname + "_d_dooropen") notsolid
		}
		else
		{
			$(self.targetname + "_d_doorglue") attachmodel models/vehicles/higginsdoor.tik "Box06" 1 (self.targetname + "_d_doorclosed") 1 -1 -1 -1 -1 ( 0 0 0 ) //( -forward +backward, +up -down, +left -right )
			$(self.targetname + "_d_doorclosed").angles = ( 90 0 0 )
			$(self.targetname + "_d_doorclosed") notsolid
		}

		local.fire = spawn script_model
		local.fire model "models/emitters/fancyfire.tik"
		local.fire.origin = local.desvehicle.origin + local.desvehicle.forwardvector * local.distance + angles_toup local.desvehicle.angles * 60
		local.fire.angles = ( 0 0 0 )
		local.fire.scale = 1
		local.fire anim start
		local.fire notsolid
		local.fire loopsound vehicledeathfire
		local.smoke = spawn script_model
		local.smoke model "models/emitters/thin_black_short.tik"
		local.smoke.origin = local.desvehicle.origin + local.desvehicle.forwardvector * local.distance + angles_toup local.desvehicle.angles * 70
		local.smoke.angles = ( 0 0 0 )
		local.smoke.scale = .7
		local.smoke anim start
		local.smoke notsolid

		local.spray1 = spawn script_model
		local.spray1 model animate/fx_water_spray.tik
		local.spray1.origin = local.desvehicle.origin + local.desvehicle.forwardvector * 225 + local.desvehicle.leftvector * 100 + local.desvehicle.upvector * 20
		local.spray1 anim start
		local.spray1 loopsound boatsinking
		local.spray2 = spawn script_model
		local.spray2 model animate/fx_water_spray.tik
		local.spray2.origin = local.desvehicle.origin + local.desvehicle.forwardvector * 225 + local.desvehicle.leftvector * -100 + local.desvehicle.upvector * 20
		local.spray2 anim start
		local.spray2 loopsound boatsinking
	}
	local.spray1.origin = ( local.spray1.origin[0] local.spray1.origin[1] local.waterheight )
	local.spray2.origin = ( local.spray2.origin[0] local.spray2.origin[1] local.waterheight )

	if(local.died_touching_water == 1) { local.desvehicle thread deathrotate local.one local.distance local.fire local.smoke local.fire2 local.smoke2 local.distance2 }
	local.desvehicle thread waterspray local.spray1 local.spray2 local.died_touching_water

	self thread driverreset 1								// local.status = 1
	self thread mainreset local.desvehicle local.fire local.smoke local.fire2 local.smoke2	// waiting self.resettime seconds until a new vehicle is spawned in

	self thread driver_shooter
	self thread kill_riders
	self.driver = NIL

	if(self != NULL && $(self.name + "_trig") != NULL) { $(self.name + "_trig") remove }
	exec global/earthquake.scr .35 2 0 0
	if(local.desvehicle.model == "models/vehicles/uboat.tik") { local.radius = 1000 }
	else { local.radius = 600 }

	if(self != NULL && self.shooter != NIL && self.shooter != NULL)
	{
		if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { local.shooter = self.shooter.player_owner }
		else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { local.shooter = self.shooter.owner }
		else { local.shooter = self.shooter }
	}
	local.blewup = 1
	for(local.i = 1; local.i <= $player.size; local.i++) // use this instead of radiusdamage, so death explosions can count as score/kills.
	{
		if(vector_length(local.desvehicle.origin - $player[local.i].origin) <= local.radius) // "local.explode" emitters cannot be used with "cansee"
		{
			if(local.shooter == NIL || local.shooter == NULL)
			{
				if($player[local.i].driving != 1 && $player[local.i].flying != 1 && $player[local.i] cansee local.desvehicle 360) // "cansee self" does not work.
				{
					$player[local.i] damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0
				}
				else if($player[local.i].drivingent != NIL && $player[local.i].drivingent != NULL)
				{
					if($player[local.i].flying == 1) { $("planehit" + $player[local.i].entnum) damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else { $player[local.i].drivingent damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
				}
			}
			else if($player[local.i] != local.shooter && $player[local.i].dmteam == local.shooter.dmteam && getcvar("g_teamdamage") != "1" && getcvar("g_gametype") != "1") { local.blewup = 0 }
			else
			{
				if($player[local.i].driving != 1 && $player[local.i].flying != 1 && $player[local.i] cansee local.desvehicle 360)
				{
					$player[local.i] damage local.shooter 500 local.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 // "damage" does not hurt teammates, but scriptbazookaexplosion.tik does
				}
				else if($player[local.i].drivingent != NIL && $player[local.i].drivingent != NULL)
				{
					$player[local.i].drivingent.shooter = local.shooter
					if($player[local.i].flying == 1) { $("planehit" + $player[local.i].entnum) damage local.shooter 500 local.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else { $player[local.i].drivingent damage local.shooter 500 local.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
				}
			}
		}
	}
	if(self != NULL) { self remove }

	local.boom = spawn script_model
	local.boom model "models/emitters/mortar_higgins.tik"
	local.boom.origin = local.desvehicle.origin + ( 0 0 25 )
	local.boom.angles = ( 0 -90 0 ) + ( 260 0 0 )
	if(local.desvehicle.model == "models/vehicles/uboat.tik") { local.boom.scale = 2.5 }
	else { local.boom.scale = 1; local.boom.origin += local.desvehicle.forwardvector * -150 }
	local.boom anim start
	local.boom notsolid

	local.debris = spawn script_model targetname "mortar_dirt_nosound"
	local.debris model "emitters/mortar_dirt_nosound.tik" 
	local.debris.origin = local.desvehicle.origin + ( 0 0 25 )
	if(local.desvehicle.model == "models/vehicles/uboat.tik") { local.debris.scale = 2.0 }
	else { local.debris.scale = .8; local.debris.origin += local.desvehicle.forwardvector * -150 }
	local.debris anim start
	local.debris notsolid
	waitframe
	local.boom remove
	local.debris remove
	if(local.blewup == 1) { radiusdamage local.desvehicle.origin 500 local.radius } // this must be one frame after other damages in this thread, otherwise chain-reaction kills will not count.
end

driver_shooter:

	if(self.driver == NIL || self.driver == NULL) { end }

	local.driver = self.driver
	local.driver.driver_shooter = self.shooter
	waitframe
	if(local.driver != NULL) { local.driver.driver_shooter = NIL }
end

kill_riders:

	if(self.passengers.size >= 1)
	{
		for(local.i = 1; local.i <= self.passengers.size; local.i++)
		{
			if(self.passengers[local.i] != NIL && self.passengers[local.i] != NULL)
			{
				if(self.shooter != NIL)
				{
					self.passengers[local.i] takedamage
					if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.passengers[local.i] damage self.shooter.player_owner 9999999 self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.passengers[local.i] damage self.shooter.owner 9999999 self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else if(self.shooter != NULL) { self.passengers[local.i] damage self.shooter 9999999 self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					self.passengers[local.i] nodamage
				}
				else { self.passengers[local.i] volumedamage 9999999 }
			}
		}
	}

	if(self.shooter != NIL)
	{
		if(self.driver != NIL)
		{
			self.driver takedamage
			if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.driver damage self.shooter.player_owner 9999999 self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.driver damage self.shooter.owner 9999999 self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			else if(self.shooter != NULL) { self.driver damage self.shooter 9999999 self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			self.driver nodamage
		}
	}
	else if(self.driver != NIL) { self.driver volumedamage 9999999 } // let's make sure the driver is dead.
end

mainreset local.desvehicle local.fire local.smoke local.fire2 local.smoke2:

	if(self.resettime == NIL || self.resettime <= 0) { end }

	local.name = self.name
	local.model = self.model
	local.origin = self.originold  // respawns the vehicle where it was destroyed, only by setting "thread main" origin/angles to "local.origin" "local.angles".
	local.angles = self.angles
	local.health = level.boat_inithealth[self.name]
	local.vehiclespeed = self.vehiclespeed_max
	local.resettime = self.resettime
	local.scale = self.scale

	while(self != NULL) { waitframe }
	wait local.resettime

	if(local.fire != NIL && local.fire != NULL) { local.fire remove }
	if(local.smoke != NIL && local.smoke != NULL) { local.smoke remove }
	if(local.fire2 != NIL && local.fire2 != NULL) { local.fire2 remove }
	if(local.smoke2 != NIL && local.smoke2 != NULL) { local.smoke2 remove }
	local.desvehicle remove
	thread main local.name local.model level.boat_initorigin[local.name] level.boat_initangles[local.name] local.health local.vehiclespeed local.resettime local.scale
end

////////////////////////////////////////////////////////////////////////

waterspray local.spray1 local.spray2 local.died_touching_water:

	local.c = 0
	while(self != NULL && local.c <= 100 && local.died_touching_water == 1)
	{
		local.c++
		wait .1
	}
	local.spray1 anim stop
	local.spray2 anim stop
	local.spray1 stoploopsound
	local.spray2 stoploopsound

	if(local.died_touching_water == 1)
	{
		local.spray1 loopsound boatsunk
		local.spray2 loopsound boatsunk

		while(self != NULL) { waitframe }
	}
	local.spray1 remove
	local.spray2 remove
end

deathrotate local.one local.distance local.fire local.smoke local.fire2 local.smoke2 local.distance2:

	self thread firesmoke_hold local.one local.distance local.fire local.smoke local.fire2 local.smoke2 local.distance2

	local.r = randomint(2)
	self time 20
	if(local.one == 1) { self rotatezup 22 }
	if(local.one == -1) { self rotatezdown 22 }
	if(local.distance2 != NIL)
	{
		//if(local.r == 0) { self rotatexdown 11 }
		//if(local.r == 1) { self rotatexup 11 }
	}
	else { self rotatexdown 22 }
	self movedown 250
	self movenorth 150
	self waitmove
end

firesmoke_hold local.one local.distance local.fire local.smoke local.fire2 local.smoke2 local.distance2:

	while(self != NULL)
	{
		if(local.fire2 != NIL && local.smoke2 != NIL)
		{
			local.fire.origin = self.origin + self.forwardvector * local.distance + angles_toup self.angles * 150 * self.scale
			local.smoke.origin = self.origin + self.forwardvector * local.distance + angles_toup self.angles * 150 * self.scale
			local.fire2.origin = self.origin + self.forwardvector * local.distance2 * -1 + angles_toup self.angles * 150 * self.scale
			local.smoke2.origin = self.origin + self.forwardvector * local.distance2 * -1 + angles_toup self.angles * 150 * self.scale
		}
		else
		{
			local.fire.origin = self.origin + self.forwardvector * local.distance + angles_toup self.angles * 60
			local.smoke.origin = self.origin + self.forwardvector * local.distance + angles_toup self.angles * 70
		}
		waitframe
	}
end

////////////////////////////////////////////////////////////////////////

passengers local.player local.s:
	
	if(local.player == NIL) { local.player = parm.other }
	if(local.player.classname != Player) { end } // somehow the "self" DrivableVehicle entity was able to run this script as parm.other and crash the server; this line prevents that from ever happening.
	if(local.s == NIL) { local.s_nil = 1 }
	local.team = local.player.dmteam
	waitframe	// need this here, otherwise driver & passenger could be attached to the same seat!

	if(self == NULL || self.dead == 1 || local.player == NIL || local.player == NULL || !isalive local.player || local.player.dmteam != local.team || local.player == self.driver || local.player.passenger == 1 || local.player.driving == 1 || local.player.flying == 1 || local.player.dead == 1 || level.change_team_score == 1 || level.bbactive == 0) { end }

	if(local.s == NIL)
	{
		for(local.s = 1; local.s <= self.seats; local.s++)
		{
			if(self.passengers[local.s] == NIL) { self.passengers[local.s] = local.player; break } // assign player to the 1st available passenger seat
		}
		if(local.s > self.seats) { local.player iprint ("No more seats available."); end }

		if(self.driver != NIL && self.driver != NULL && local.player.dmteam != self.driver.dmteam && local.player.dmteam != "spectator" && getcvar("g_gametype") != "1")
		{
			self.passengers[local.s] = NIL
			local.player iprint ("An enemy player is driving this vehicle!")
			end
		}
	}
	else if(self.passengers[local.s] != NIL && self.passengers[local.s] != local.player) { local.player iprint ("This seat is already occupied."); end }
	else { self.passengers[local.s] = local.player }

	self waitthread spawn_driver_seat_and_trigs
	self waitthread spawn_passenger_seat local.s
	if($("passenger_seat_" + local.s + "_" + self.entnum) != NULL) { local.player glue $("passenger_seat_" + local.s + "_" + self.entnum) }

	if(local.s_nil == 1) { local.player take "models/items/binoculars.tik" } // using these will cause camera jittering again.
	local.player forcetorsostate VEHICLE_PASSENGER // prevents camera jittering.
	local.player forcelegsstate STAND
	//local.player hide
	//local.player noclip
	local.player nodamage // keep this off until the player receives damage, then quickly do "takedamage" and give damage, before doing "nodamage" again in "healthboost" thread (allows for more damage types such as bazooka rockets to count as kills).
	local.player notsolid // need this, otherwise vehicles cannot reverse properly.
	if(local.s_nil == 1)
	{
		if(self.seats > 1) { local.player iprint ("JUMP = exit vehicle... Hold FIRE(zoom) = look around... Lean Left/Right = change seats.") }
		else { local.player iprint ("JUMP = exit vehicle... Hold FIRE(zoom) = look around.") }
	}
	local.player.origin = self.origin
	local.player.passenger = 1
	local.player.ridingent = self
	local.player.driving = 1 // should help with other scripts.
	local.player.driving_state_jump = 0
	local.PI = 3.14159265359
	local.driver = self.driver
	local.outheight = self.outheight

	local.targetname = self.targetname
	local.passenger_reattach = 0
	while(self != NULL && self.dead != 1 && isalive local.player && local.player.dmteam == local.team && local.player.dead != 1 && level.change_team_score != 1 && level.bbactive != 0 && $("passenger_seat_" + local.s + "_" + self.entnum) != NULL)
	{
		local.player anim unarmed_stand_idle // need this, since VEHICLE_PASSENGER state uses "movetype anim" instead of "movetype legs", which omits all legs animations (player will landshark without this).

		local.angles = self.angles
		local.dist = vector_length($("passenger_seat_" + local.s + "_" + self.entnum).origin - self.origin)
		local.s_ang = vector_toangles($("passenger_seat_" + local.s + "_" + self.entnum).origin - self.origin)
		local.s_vec = angles_toforward(local.s_ang) * local.dist

		if(local.player.fireheld != 1)
		{
			if(self.playerang_offset[local.s] != NIL) { local.player.viewangles = ( (self.angles[0] + 10) self.angles[1] self.angles[2] ) + ( self.angles[0] self.playerang_offset[local.s] self.angles[2] ) } // some vehicles' passengers should not face forward (view is blocked)
			else { local.player.viewangles = ( (self.angles[0] + 10) self.angles[1] self.angles[2] ) }
		}

		if(local.player.viewangles[0] > 180) { local.player.viewangles = ( (10 + (self.angles[0] - 360)) local.player.viewangles[1] local.player.viewangles[2] ) } // any viewangles[0] +/- 180 will cause camera issues (going under vehicle).
		if(local.player.viewangles[0] < -180) { local.player.viewangles = ( (local.player.viewangles[0] + 360) local.player.viewangles[1] local.player.viewangles[2] ) } // prevent camera from moving too far down.

		local.cycled = 0
		local.changeseats = 0
		local.newseat = 0
		local.p = local.s
		if(local.leaning == 0 && (local.player getcontrollerangles 0)[2] > 15 && (local.player getcontrollerangles 0)[2] >= -15) // lean left to cycle upward through available passenger seats.
		{
			for(local.z = 1; local.z <= self.seats; local.z++)
			{
				if(local.p + local.z > self.seats && local.cycled != 1) { local.p = 1; local.z = 0; local.cycled = 1 }
				if(self.passengers[local.p + local.z] == NIL) { local.changeseats = 1; local.newseat = local.p + local.z; break }
			}
		}
		if(local.leaning == 0 && (local.player getcontrollerangles 0)[2] <= 15 && (local.player getcontrollerangles 0)[2] < -15) // lean right to cycle downward through available passenger seats.
		{
			for(local.z = 1; local.z <= self.seats; local.z++)
			{
				if(local.p - local.z < 1 && local.cycled != 1) { local.p = self.seats; local.z = 0; local.cycled = 1 }
				if(self.passengers[local.p - local.z] == NIL) { local.changeseats = 1; local.newseat = local.p - local.z; break }
			}
		}

		if(local.player.driving_state_jump == 1 || local.changeseats == 1) // Press JUMP to exit vehicle.
		{
			local.player unglue
			if(local.player.isdog != 1) { local.player show }
			local.player give "models/items/binoculars.tik"
			local.player solid
			local.player takedamage
			//local.player noclip
			local.player forcetorsostate STAND
			local.player forcelegsstate STAND
			if(local.changeseats != 1) { local.player.origin += angles_toup self.angles * self.outheight }
			local.player.viewangles = ( local.player.viewangles[0] local.player.viewangles[1] 0 )

			local.player thread wallstuck_fix
			self.passengers[local.s] = NIL
			local.player.passenger = 0
			local.player.ridingent = NIL
			local.player.driving = 0
			if($("passenger_seat_" + local.s + "_" + self.entnum) != NULL) { $("passenger_seat_" + local.s + "_" + self.entnum) remove }

			if(local.changeseats == 1) { self thread passengers local.player local.newseat }
			end
		}
		if((local.player getcontrollerangles 0)[2] <= 15 && (local.player getcontrollerangles 0)[2] >= -15) { local.leaning = 0 }

		local.driver = self.driver
		local.angles = self.angles
		if(self.driver != NIL && self.driver != NULL) { local.passenger_reattach = 1 }
		waitframe
	}
	if(self != NULL)
	{
		self.passengers[local.s] = NIL
		if($("passenger_seat_" + local.s + "_" + self.entnum) != NULL) { $("passenger_seat_" + local.s + "_" + self.entnum) remove }
	}

	if(local.player != NULL)
	{
		local.player unglue
		local.player.viewangles = ( 0 local.player.viewangles[1] 0 ) // passenger reset
		local.player.passenger = 0
		local.player.ridingent = NIL
		local.player.driving = 0
		if(local.player.dmteam != spectator)
		{
			if(isalive local.player) { local.player give "models/items/binoculars.tik" }
			if(local.player.isdog != 1) { local.player show }
			local.player solid
			local.player takedamage
			//local.player noclip
			local.player forcetorsostate STAND
			local.player forcelegsstate STAND
			if(local.player.dmteam == local.team) // if the passenger did not switch teams
			{
				local.player.origin += angles_toup local.angles * local.outheight
				local.player.viewangles = ( local.player.viewangles[0] local.player.viewangles[1] 0 )
				local.player thread wallstuck_fix
	
				if(local.driver != NIL && local.driver != NULL && (!isalive local.driver || local.driver.dead == 1))
				{
					if(self != NULL && self.shooter != NIL)
					{
						if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { local.player damage self.shooter.player_owner 9999999 self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
						else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { local.player damage self.shooter.owner 9999999 self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
						else { local.player damage self.shooter 9999999 self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					}
					else if(local.driver.driver_shooter != NIL)
					{
						if(local.driver.driver_shooter.player_owner != NIL && local.driver.driver_shooter.player_owner != NULL) { local.player damage local.driver.driver_shooter.player_owner 9999999 local.driver.driver_shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
						else if(local.driver.driver_shooter.owner != NIL && local.driver.driver_shooter.owner != NULL) { local.player damage local.driver.driver_shooter.owner 9999999 local.driver.driver_shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
						else if(local.driver.driver_shooter != NIL && local.driver.driver_shooter != NULL) { local.player damage local.driver.driver_shooter 9999999 local.driver.driver_shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
						else { local.player damage $world 9999999 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					}

				}
			}
			else { local.player respawn }

			if(local.passenger_reattach == 1) { thread passenger_reattach local.player local.team local.targetname local.s }

			local.origin = local.player.origin
			while(local.player != NULL && !isalive local.player && local.player.dmteam != "spectator")
			{
				local.player.origin = ( local.origin[0] local.origin[1] local.player.origin[2] ) // for some reason, passengers' dead bodies would move forward across the ground until they hit a wall.
				local.player notsolid
				local.player droptofloor
				waitframe
			}
		}
	}
end

passenger_reattach local.player local.team local.targetname local.s:

	if(isalive local.player && local.player.dmteam == local.team)
	{
		local.c = 0
		while($(local.targetname) == NULL) { local.c++; waitframe } // wait until the vehicle respawns before reattaching player.
		if(local.c > 20) { end }

		if($(local.targetname) != NULL && isalive local.player && local.player.dmteam == local.team) { $(local.targetname) thread passengers local.player local.s }
	}
end

////////////////////////////////////////////////////////////////////////

firegun:

	if(self.firing_gun == 1) { end }
	self.firing_gun = 1

	self thread projectile
	self playsound uboat_snd_fire //panzerschrecksndfire
	self playsound uboat_reload

	self.boatsmokecount = 0
	self thread smokey

	wait 5
	if(self != NULL) { self.firing_gun = 0 }
end

firesecondary:

	if(self.firing_gun2 == 1) { end }
	self.firing_gun2 = 1

	self thread projectile 1
	self playsound grenadethrow

	wait 1
	if(self != NULL) { self.firing_gun2 = 0 }
end

smokey:

	self.boatsmoking = 1
	local.targetname = self.targetname
	local.boatsmokecount = self.boatsmokecount

	local.smoke = spawn script_model
	local.smoke model "fx/fx_cannonsmoke.tik"
	self.gun = $(self.name + "_tag_barrel")
	local.smoke.origin = self.gun.origin

	while(self != NULL && self.boatsmokecount < 120)
	{
		local.smoke.origin = self.gun.origin
		self.boatsmokecount++
		local.boatsmokecount = self.boatsmokecount
		waitframe
	}

	local.c = 0
	while($(local.targetname) == NULL) // boat is always removed after a player exits the boat, wait for the boat to respawn before continuing smokecount
	{
		if(local.c >= 10) // remove the smoke sooner if the boat was destroyed
		{
			if(local.smoke != NULL) { local.smoke remove }
			end
		}
		local.c++
		waitframe
	}

	$(local.targetname).boatsmoking = 1
	$(local.targetname).boatsmokecount = local.boatsmokecount
	$(local.targetname).gun = $(local.targetname + "_tag_barrel")

	while($(local.targetname) != NULL && $(local.targetname).gun != NULL && $(local.targetname).boatsmokecount != NIL && $(local.targetname).boatsmokecount < 120)
	{
		local.smoke.origin = $(local.targetname).gun.origin
		$(local.targetname).boatsmokecount++
		waitframe	
	}

	if(local.smoke != NULL) { local.smoke remove }
	if($(local.targetname) != NULL) { $(local.targetname).boatsmoking = 0; $(local.targetname).boatsmokecount = 0 }
end

projectile local.secondary:

	local.player = self.driver // used for the for-loop later
	self.gun = $(self.name + "_tag_barrel")

	local.rocket = spawn script_model
	if(local.secondary == 1)
	{
		if(local.player.dmteam == "axis") { local.rocket model "projectiles/steilhandgranate_primary.tik" }
		else { local.rocket model "projectiles/M2FGrenade_primary.tik" }
	}
	else { local.rocket model "projectiles/tigercannonshell.tik" } // "projectiles/panzerschreckshell.tik"
	local.rocket.origin = self.gun.origin
	local.rocket light 0 1 0 400
	local.rocket.scale = 1
	local.rocket solid
	local.rocket physics_on    // need this for gravity and waittill touch to work.
	local.rocket.scale = 3
	if(self != NULL) { local.rocket.player_owner = self.driver }

	if(local.secondary == 1)
	{
		local.rocket playsound grenadethrow
		local.rocket.angles = ( -90 self.angles[1] 0 )
		local.rocket thread rotate

		local.rocket gravity .8
		local.fwd_vec = angles_toforward ( 0 self.angles[1] 0 )
		local.rocket.velocity = ( local.fwd_vec[0] local.fwd_vec[1] .500 ) * 950 // local.fwd_vec[2] = .500 = 45 degrees facing upward
	}
	else
	{
		local.rocket loopsound rocketfireloop
		local.rocket.angles = ( self.turretlaser_offset (self.angles[1] + 180) 0 )

		local.rocket gravity 0
		local.rocket.velocity = (angles_toforward ( (self.angles[0] + self.turretlaser_offset) self.angles[1] self.angles[2] )) * 6000
	}

	if(local.secondary == 1) { wait 3 }
	else
	{
		local.rocket thread waittill_touch local self local.player
		local.hitthing = self
		while(local.hitthing == self || (self != NULL && local.hitthing == self.gun))
		{
			local.rocket waittill touch
			local.hitthing = parm.other
		}
	}
	local.rocket.velocity = ( 0 0 0 )

	local.explode = spawn "fx/explosionTIGERshell.tik" // "fx/explosionPANZERIVshell.tik"
	local.explode.origin = local.rocket.origin
	local.explode.scale = 1
	local.explode light 1 0 0 600
	local.explode anim idle
	//local.explode playsound bazooka_exp // already included in explosionPANZERIVshell

	if(self != NULL && local.rocket istouching self) { local.blewup = 0 }
	else { local.blewup = 1 }

	for(local.i = 1; local.i <= $player.size; local.i++) // use this instead of radiusdamage, so rockets can count as score/kills
	{
		if(vector_length(local.explode.origin - $player[local.i].origin) <= 500) // without "cansee", these rockets can kill people through walls
		{
			if(local.player == NIL || local.player == NULL)
			{
				if($player[local.i].driving != 1 && $player[local.i].flying != 1 && $player[local.i] cansee local.rocket 360)
				{
					$player[local.i] damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 1 15 -1
				}
				else if($player[local.i].drivingent != NIL && $player[local.i].drivingent != NULL)
				{
					if($player[local.i].flying == 1) { $("planehit" + $player[local.i].entnum) damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 1 15 -1 }
					else { $player[local.i].drivingent damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 1 15 -1 }
				}
			}
			else if($player[local.i] != local.player && $player[local.i].dmteam == local.player.dmteam && getcvar("g_teamdamage") != "1" && getcvar("g_gametype") != "1") { local.blewup = 0 }
			else
			{
				if($player[local.i].driving != 1 && $player[local.i].flying != 1 && $player[local.i] cansee local.rocket 360)
				{
					$player[local.i] damage local.player 500 local.player (0 0 0) (0 0 0) (0 0 0) 0 1 15 -1 // "damage" does not hurt teammates, but scriptbazookaexplosion.tik does
				}
				else if($player[local.i].drivingent != NIL && $player[local.i].drivingent != NULL)
				{
					$player[local.i].drivingent.shooter = local.player
					if($player[local.i].flying == 1) { $("planehit" + $player[local.i].entnum) damage local.player 500 local.player (0 0 0) (0 0 0) (0 0 0) 0 1 15 -1 }
					else { $player[local.i].drivingent damage local.player 500 local.player (0 0 0) (0 0 0) (0 0 0) 0 1 15 -1 }
				}
			}
		}
	}
	if(local.blewup == 1) { radiusdamage local.explode.origin 500 500 } // 110 200
	waitframe
	local.rocket remove
	wait .2 // keeps the explosion light visible longer
	local.explode remove
end

////////////////////////////////////////////////////////////////////////

waittill_touch local.thread local.turret local.player:

	while(1)
	{
		if(self == NULL || vector_length(self.origin) > 12000) // if moving outside the map or NULL.
		{
			if(local.thread != NULL) { local.thread remove } // prematurely end "waittill touch" and its thread (nothing else runs after it).
			if(self != NULL) { self remove }
			end
		}

		if(self.velocity == ( 0 0 0 )) { end } // self.hitwater not needed, since these projectiles already stop when hitting water.
		waitframe
	}
end

////////////////////////////////////////////////////////////////////////

rotate:

	while(self != NULL && self.velocity != ( 0 0 0 ))
	{
		self.angles = (self.angles + ( 3 0 0 ))
		waitframe
	}
end

turret_laser local.name:

	local.laser = spawn func_beam
	local.laser minoffset 0
	local.laser maxoffset 0
	local.laser numsegments 1
	local.laser life 0
	local.laser color ( 1 0 0 )
	local.laser alpha .4
	local.laser alwaysdraw
	local.laser deactivate	
	local.laser scale 1.0
	local.laser notsolid
	local.laser.origin = $(local.name + "_tag_barrel").origin
	local.laser endpoint $(local.name + "_tag_barrel").origin
	self.turretlaser = local.laser

	local.point = spawn script_model
	local.point model "static/corona_util.tik"
	local.point.origin = $(local.name + "_tag_barrel").origin
	//local.point light 1 0 0 250
	local.point hide
	local.point notsolid
	self.turretlaser_point = local.point

	while(self != NULL) { waitframe }
	local.laser remove
	local.point remove
end

////////////////////////////////////////////////////////////////////////

spawn_driver_seat_and_trigs: // only spawn seats & triggers when needed, otherwise initializing all seats when vehicle spawns will greatly increase map's entity count.

	if(self.damagetrig != NIL && self.damagetrig != NULL) { end }
	if(self.trigshot != NIL && self.trigshot != NULL) { end }

	local.trig = spawn trigger_multiple targetname (self.targetname + "_damagetrig") spawnflags 128 // for calculating how much damage was given (triggers with health will not go to a setthread until it's fully dead).
	local.trig.origin = self.origin
	local.trig.health = self.health		// make sure triggers with health & "spawnflags 128" are slightly larger in setsizes than other "spawnflags 128" triggers,
	local.trig.vehicle = self		// otherwise the overlapping trigger that was last spawned in will have bullet-triggering priority,
	local.trig glue self			// preventing the trigger with health from taking any damage.
	self.damagetrig = local.trig
	local.trig thread removetrig
	local.trig.model = self.model	// any entities that have attachmodels on them will crash the server if those entities do not have a specified model, since there is no "Box01" to attach to;
	local.trig.scale = self.scale	// this also does not print any errors when crashing the server.
	local.trig hide

	local.trigshot = spawn trigger_multiple targetname (self.targetname + "_trigshot") spawnflags 128 // instantly determine the vehicle's shooter (runs setthread each time it's triggered).
	local.trigshot.origin = self.origin
	local.trigshot.vehicle = self
	local.trigshot glue self
	self.trigshot = local.trigshot
	local.trigshot thread removetrig
	local.trigshot setthread shottrig
	local.trigshot.model = self.model
	local.trigshot.scale = self.scale
	local.trigshot hide

	while($("driver_seat_" + self.entnum) != NULL) { $("driver_seat_" + self.entnum) remove; waitframe }

	if(self.model == "models/vehicles/higginsxtrahull.tik") // "Box01", "Box02", or similar is determined by the model's .skc file.
	{
		self attachmodel models/static/jug.tik "Box01" 1 ("driver_seat_" + self.entnum) 1 -1 -1 -1 -1 ( 120 50 58 ) // ( -forward +backward, +up -down, +left -right )
		local.trig setsize ( -91 -91 -1 ) ( 91 91 160 )
		local.trigshot setsize ( -90 -90 0 ) ( 90 90 159 )
	}
	else if(self.model == "models/vehicles/uboat.tik")
	{
		self attachmodel models/static/jug.tik "Box01" 1 ("driver_seat_" + self.entnum) 1 -1 -1 -1 -1 ( 0 323 40 ) // ( -right +left, +up -down, +forward -backward )
		local.trig setsize ( -151 -151 -1 ) ( 151 151 419 )
		local.trigshot setsize ( -150 -150 0 ) ( 150 150 418 )
	}

	if($("driver_seat_" + self.entnum) != NULL)
	{
		$("driver_seat_" + self.entnum).angles = self.angles
		$("driver_seat_" + self.entnum) bind self
		$("driver_seat_" + self.entnum) hide
	}
end

shottrig:

	local.player = parm.other
	if(self.vehicle != NULL && (self.vehicle.driver == NIL || (self.vehicle.driver != NIL && (self.vehicle.driver.dmteam != local.player.dmteam || getcvar("g_gametype") == "1")))) { self.vehicle.shooter = local.player }
end

removetrig:

	while(self != NULL && self.vehicle != NIL && self.vehicle != NULL && self.vehicle.dead != 1) { waitframe }
	if(self != NULL) { self remove }
end

////////////////////////////////////////////////////////////////////////

spawn_passenger_seat local.s: // only spawn seats when needed.

	while($("passenger_seat_" + local.s + "_" + self.entnum) != NULL) { $("passenger_seat_" + local.s + "_" + self.entnum) remove; waitframe }

	local.add = 0
	if(self.model == "models/vehicles/higginsxtrahull.tik") //( +left -right, +up -down, +forward -backward )
	{
		if(local.s == 1) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 120 64 -58 ) } // ( -forward +backward, +up -down, +left -right )
		if(local.s == 2) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 30 64 -40 ) }
		if(local.s == 3) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -50 64 -40 ) }
		if(local.s == 4) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -122 64 -40 ) }
		if(local.s == 5) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -215 64 -40 ) }
		if(local.s == 6) { self.trigshot attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -215 64 40 ) } // each entity can only have 8 attachmodels max,
		if(local.s == 7) { self.trigshot attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -122 64 40 ) } // so attach more seats to the vehicle's glued triggers instead,
		if(local.s == 8) { self.trigshot attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -50 64 40 ) } // and give the triggers identical models.
		if(local.s == 9) { self.trigshot attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 30 64 40 ) }
	}
	else if(self.model == "models/vehicles/uboat.tik") // ( -forward +backward, +up -down, +left -right )
	{
		if(local.s == 1) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -45 321 -111 ) } // ( -right +left, +up -down, +forward -backward )
		if(local.s == 2) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 45 321 -111 ) }
		if(local.s == 3) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 0 321 -270 ); local.add = 180 }
		if(local.s == 4) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -71 234 -407 ); local.add = -90 }
		if(local.s == 5) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 71 234 -407 ); local.add = 90 }
	}

	if($("passenger_seat_" + local.s + "_" + self.entnum) != NULL)
	{
		if(local.add != 0) { self.playerang_offset[local.s] = local.add }
		$("passenger_seat_" + local.s + "_" + self.entnum).angles = self.angles + ( 0 local.add 0 )
		$("passenger_seat_" + local.s + "_" + self.entnum) bind self
		$("passenger_seat_" + local.s + "_" + self.entnum) hide
	}
end

////////////////////////////////////////////////////////////////////////

dummyavatar:

/*
	local.avatar = spawn func_beam
	local.avatar attach self.driver "Bip01 Head"
	local.avatar.origin = self.driver.origin + ( 0 0 100 )
	local.avatar endpoint (local.avatar.origin + ( 0 0 13 ))
	local.avatar minoffset 0
	local.avatar maxoffset 0
	local.avatar color ( 1 1 1 )
	local.avatar scale 7.0
	local.avatar life 0
	if(self.driver.dmteam == "allies") { local.avatar shader ("textures/hud/allies_headicon") }
	if(self.driver.dmteam == "axis") { local.avatar shader ("textures/hud/axis_headicon") }
	local.avatar numsegments 1
	local.avatar alpha .80
	local.avatar activate
	local.heightinc = 0

	self.driver show
	local.team = self.driver.dmteam
	while(self != NULL && isalive self.driver && self.driver.dmteam == local.team && self.driver.dead != 1 && level.change_team_score != 1 && level.bbactive != 0)
	{
		local.avatar.origin = self.driver.origin + self.upvector * (100 + local.heightinc)
		local.avatar endpoint (local.avatar.origin + ( 0 0 13 ))
		waitframe
	}
	local.avatar remove
*/
end

////////////////////////////////////////////////////////////////////////

wallstuck_fix:

	local.c = 0
	local.origin = self.origin
	local.team = self.dmteam

	if(self.wallstuck_fixing == 1) { end }
	self.wallstuck_fixing = 1

	while(self != NULL && isalive self && self.dmteam == local.team) // while player is stuck in a wall (falling) and origin isn't changing, count a few seconds, then respawn the player
	{
		if(local.c >= 60) // about 3 seconds
		{
			if((self getmovement) == falling && self.origin == local.origin) { self respawn }
			if(self.isdog == 1) { self hide }
			break
		}
		local.c++
		waitframe
	}
	if(self != NULL) { self.wallstuck_fixing = 0 }
end

////////////////////////////////////////////////////////////////////////

boatstuck_inwall_fix:

	while(self != NULL)
	{
		if((self.angles[0] <= 340 && self.angles[0] >= 20) || (self.angles[2] <= 340 && self.angles[2] >= 20))
		{
			killent self.entnum
			break
		}
		waitframe
	}
end

////////////////////////////////////////////////////////////////////////

touching_playerboat:

	level.touching_playerboat = 1

	while($player.size < 1) { waitframe }
	while($player.size >= 1)
	{
		for(local.i = 1; local.i <= $player.size; local.i++)
		{
			$player[local.i].touching_playerboat = 0 // ensures that only one boat needs to be touched for touching_playerboat = 1.
		}

		for(local.a = 0; local.a <= level.drivable_entities.size; local.a++)
		{
			for(local.s = 1; $(level.drivable_entities[local.a]) != NULL && local.s <= $(level.drivable_entities[local.a]).size; local.s++) // sometimes, two vehicles with the same targetname can exist
			{													// for 1 or 2 frames. this for-loop prevents any console errors.
				for(local.i = 1; local.i <= $player.size; local.i++)
				{
					if($player[local.i] istouching $(level.drivable_entities[local.a])[local.s]) { $player[local.i].touching_playerboat = 1 }

					if($(level.drivable_entities[local.a])[local.s].doorclip != NIL && $(level.drivable_entities[local.a])[local.s].doorclip != NULL && $player[local.i] istouching $(level.drivable_entities[local.a])[local.s].doorclip)
					{
						$player[local.i].touching_playerboat = 1
					}
				}
			}
		}
		waitframe
	}

	thread touching_playerboat
end

////////////////////////////////////////////////////////////////////////

move_stuck_players:

	waitframe
	for(local.i = 1; local.i <= $player.size; local.i++)
	{
		if(isalive $player[local.i] && $player[local.i].dead != 1 && $player[local.i].dmteam != "spectator" && self != NULL && $player[local.i] istouching self && $player[local.i].driving != 1 && $player[local.i].passenger != 1 && $player[local.i].turreting != 1 && $player[local.i].flying != 1 && $player[local.i].missile == NIL)
		{
			self thread moving_stuck_players $player[local.i]
		}
	}
end

moving_stuck_players local.player:

	if(local.player.moving_stuck_players == 1) { end }
	local.player.moving_stuck_players = 1

	while(self != NULL && isalive local.player && local.player.dmteam != "spectator" && local.player istouching self && local.player.driving != 1 && local.player.passenger != 1 && local.player.turreting != 1 && local.player.flying != 1 && local.player.missile == NIL)
	{
		local.player.origin += (angles_toup self.angles * 20)
		waitframe
	}
	if(local.player != NULL) { local.player.moving_stuck_players = 0 }
end

////////////////////////////////////////////////////////////////////////

keep_at_door local.doorclip local.door_open:

	if(self.door_open != 1) { local.height = 60; local.angle = 0; local.dist = 285 }
	else { local.height = -47; local.angle = 22; local.dist = 235 }
	self.door_count = 0

	while(self != NULL)
	{
		if(self.door_open != local.door_open && self.door_count >= 20)
		{
			self.door_count = 0
			if(self.door_open != 1) { local.height = 60; local.angle = 0; local.dist = 285 }
			else { local.height = -47; local.angle = 22; local.dist = 235 }
		}
		else { self.door_count++ }
		if(self.door_count >= 20) { self.door_count = 20 }

		if(self.movingbackward == 1) { local.direction = -1 }
		else { local.direction = 1 }

		local.doorclip.origin = self.origin + self.forwardvector * local.dist + self.upvector * local.height + self.forwardvector * self.vehiclespeed * 0.075 * local.direction
		local.doorclip.angles = ( (self.angles[2] * -1) self.angles[1] self.angles[0] ) + ( 0 90 local.angle )

		local.door_open = self.door_open
		waitframe
	}
	local.doorclip remove
end

////////////////////////////////////////////////////////////////////////

keep_at_boat local.spray1 local.spray2:

	local.angle_old = self.angles[1]
	while(self != NULL)
	{
		local.touching_water = 0
		local.waterheight = -9999
		if(level.water_volumes != NIL && level.water_volumes != 0)
		{
			for(local.v = 1; local.v <= level.water_volumes.size; local.v++)
			{
				local.X_min[local.v] = level.water_volumes[local.v][1][0] + level.water_volumes[local.v][2][0]
				local.X_max[local.v] = level.water_volumes[local.v][1][0] + level.water_volumes[local.v][3][0]
				local.Y_min[local.v] = level.water_volumes[local.v][1][1] + level.water_volumes[local.v][2][1]
				local.Y_max[local.v] = level.water_volumes[local.v][1][1] + level.water_volumes[local.v][3][1]
				local.Z_min[local.v] = level.water_volumes[local.v][1][2] + level.water_volumes[local.v][2][2]
				local.Z_max[local.v] = level.water_volumes[local.v][1][2] + level.water_volumes[local.v][3][2]
				local.origin = self.origin
	
				if(int(local.origin[0]) >= local.X_min[local.v] && int(local.origin[0]) <= local.X_max[local.v] && int(local.origin[1]) >= local.Y_min[local.v] && int(local.origin[1]) <= local.Y_max[local.v] && int(local.origin[2]) >= local.Z_min[local.v] && int(local.origin[2]) <= local.Z_max[local.v])
				{
					local.touching_water = 1
					local.waterheight = local.Z_max[local.v]
				}
			}
		}

		if(local.touching_water == 1)
		{
			if(self.angles[1] != local.angle_old)
			{
				if(self.model == "models/vehicles/uboat.tik") { self.sprayleft anim start; self.sprayright anim start }
				else
				{
					if(self.movingbackward == 1)
					{
						if(self.angles[1] < local.angle_old) { self.sprayleft anim stop; self.sprayright anim start }
						if(self.angles[1] > local.angle_old) { self.sprayleft anim start; self.sprayright anim stop }
					}
					else
					{
						if(self.angles[1] > local.angle_old) { self.sprayleft anim stop; self.sprayright anim start }
						if(self.angles[1] < local.angle_old) { self.sprayleft anim start; self.sprayright anim stop }
					}
				}
			}
			else { self.sprayleft anim stop; self.sprayright anim stop }
		}
		else { self.sprayleft anim stop; self.sprayright anim stop }

		if(self.movingbackward == 1) { local.direction = -1 }
		else { local.direction = 1 }

		if(self.model == "models/vehicles/uboat.tik")
		{
			self.sprayleft.origin = self.origin + self.forwardvector * -2150 + self.forwardvector * self.vehiclespeed * 0.075 * local.direction
			self.sprayright.origin = self.origin + self.forwardvector * 1970 + self.forwardvector * self.vehiclespeed * 0.075 * local.direction
		}
		else
		{
			self.sprayleft.origin = self.origin + self.leftvector * 100 + self.forwardvector * 300 * local.direction + self.forwardvector * self.vehiclespeed * 0.075 * local.direction
			self.sprayright.origin = self.origin + self.leftvector * -100 + self.forwardvector * 300 * local.direction + self.forwardvector * self.vehiclespeed * 0.075 * local.direction
		}
		self.sprayleft.origin = ( self.sprayleft.origin[0] self.sprayleft.origin[1] local.waterheight )
		self.sprayright.origin = ( self.sprayright.origin[0] self.sprayright.origin[1] local.waterheight )

		local.angle_old = self.angles[1]
		waitframe
	}
	local.spray1 remove
	local.spray2 remove	
end

////////////////////////////////////////////////////////////////////////

display:

	if(game.game != "AA") { local.menu1 = "bastogne1"; local.menu2 = "bastogne2" }
	else { local.menu1 = "dday1"; local.menu2 = "dday2" }

	self stufftext ("globalwidgetcommand " + local.menu1 + " shader townhallwindow")
	self stufftext ("globalwidgetcommand " + local.menu1 + " fgcolor 1.00 1.00 1.00 1.00")
	self stufftext ("globalwidgetcommand " + local.menu1 + " bgcolor 0.50 0.50 0.50 0.00")
	self stufftext ("globalwidgetcommand " + local.menu1 + " fadein 0")
	self stufftext ("globalwidgetcommand " + local.menu1 + " menu " + local.menu1 + " 640 480 NONE 0")
	self stufftext ("globalwidgetcommand " + local.menu1 + " virtualres 1")
	self stufftext ("globalwidgetcommand " + local.menu1 + " fullscreen 1")

	self stufftext "globalwidgetcommand june6 borderstyle NONE"
	self stufftext "globalwidgetcommand june6 shader textures/hud/healthback"
	self stufftext "globalwidgetcommand june6 rect 16 420 16 64"
	self stufftext "globalwidgetcommand june6 fgcolor 1.00 1.00 1.00 1.00"
	self stufftext "globalwidgetcommand june6 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand june6 linkcvar phealth"
	self stufftext "globalwidgetcommand june6 statbar vertical 0 100"
	self stufftext "globalwidgetcommand june6 statbar_shader textures/hud/healthmeter"
	self stufftext "globalwidgetcommand june6 statbar_shader_flash textures/hud/healthmeterflash"

	self stufftext ("globalwidgetcommand " + local.menu2 + " fgcolor 1.00 1.00 1.00 1.00")
	self stufftext ("globalwidgetcommand " + local.menu2 + " bgcolor 0.50 0.50 0.50 0.00")
	self stufftext ("globalwidgetcommand " + local.menu2 + " fadein 0")
	self stufftext ("globalwidgetcommand " + local.menu2 + " menu " + local.menu2 + " 640 480 NONE 0")
	self stufftext ("globalwidgetcommand " + local.menu2 + " virtualres 1")
	self stufftext ("globalwidgetcommand " + local.menu2 + " fullscreen 1")

	self stufftext "globalwidgetcommand charliesector borderstyle NONE"
	self stufftext "globalwidgetcommand charliesector textalign left "
	self stufftext "globalwidgetcommand charliesector rect 40 470 150 20"
	self stufftext "globalwidgetcommand charliesector fgcolor 0.70 0.60 0.05 1.00"
	self stufftext "globalwidgetcommand charliesector bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand charliesector linkcvar phealth"
	self stufftext "globalwidgetcommand charliesector font facfont-20"
	self stufftext "globalwidgetcommand charliesector shader townhallwindow"

	self stufftext ("showmenu " + local.menu2)
	self stufftext ("showmenu " + local.menu1)
	self stufftext ("set phealth " + int(self.health))
end

////////////////////////////////////////////////////////////////////////

vehicle_settings local.gotout local.door_open:

	// if model == uboat, keep desmodel = current model
	switch(self.model)
	{
		case "models/vehicles/higginsxtrahull.tik":
			self.seats = 9 // [1] = front passenger. [2] = back right, [3], [4], [5] = front right. [6] = front left, [7], [8], [9] = back left
			self.desmodel = models/vehicles/higgins_damage.tik
			self.outheight = 1
			self turnrate 5
			self.turningrate = 5.000 // keep at least 3 decimals for better turnrate accuracy.
			if(level.vehiclescriptmaster[self.model] != 1) { cache models/vehicles/jeep_30cal.tik; cache models/vehicles/jeep_30cal_viewmodel.tik }
			if(local.gotout == 1) { self playsound sdkfz_snd_stop }
			break

		case "models/vehicles/uboat.tik":
			self.seats = 5 // [1], [2] = right, left front captain platform, [3] = back of captain platform, [4], [5] = right side (facing forward), left side of middle platform
			self.desmodel = NIL
			self.outheight = -110
			self turnrate 1
			self.turningrate = 1.000
			if(local.gotout == 1) { self playsound sdkfz_snd_stop }
			self thread boatstuck_inwall_fix // blow up the uboat if the angles become too non-horizontal.
			break

		default:
			self.seats = 0
			self.desmodel = NIL
			self.outheight = 100
			self turnrate 5
			self.turningrate = 5.000
			if(local.gotout == 1) { self playsound sdkfz_snd_stop }
			break
	}

	if(level.vehiclescriptmaster[self.model] != 1) // this only runs once
	{
		cache self.model
		if(self.desmodel != NIL) { cache self.desmodel }
		cache models/emitters/fancyfire.tik; cache models/emitters/thin_black_short.tik
		cache models/emitters/mortar_higgins.tik
		cache models/emitters/mortar_dirt_nosound.tik
		cache models/static/jug.tik
		if(self.model == "models/vehicles/higginsxtrahull.tik") { cache models/vehicles/higginsdoor.tik; cache models/vehicles/mercedes.tik; cache models/animate/fx_water_spray.tik }
		else { cache models/static/corona_util.tik }
		thread scriptmaster self.model
		level.vehiclescriptmaster[self.model] = 1
	}

	if(self.model == "models/vehicles/higginsxtrahull.tik")
	{
		self attachmodel models/static/jug.tik "Box01" 1 (self.name + "_doorglue") 1 -1 -1 -1 -1 ( 0 0 0 ) //( -forward +backward, +up -down, +left -right )
		$(self.name + "_doorglue") notsolid
		self.doorglue = $(self.name + "_doorglue")
		$(self.name + "_doorglue") attachmodel models/vehicles/higginsdoor.tik "Box06" 1 (self.name + "_doorclosed") 1 -1 -1 -1 -1 ( 0 0 0 ) //( -forward +backward, +up -down, +left -right )
		$(self.name + "_doorclosed").angles = ( 90 0 0 )
		$(self.name + "_doorclosed") notsolid
		self.doorclosed = $(self.name + "_doorclosed")
		$(self.name + "_doorglue") attachmodel models/vehicles/higginsdoor.tik "Box06" 1 (self.name + "_dooropen") 1 -1 -1 -1 -1 ( 309 0 -225 ) //( +up -down, +left -right, -forward +backward )
		$(self.name + "_dooropen").angles = ( 0 180 180 )
		$(self.name + "_dooropen") notsolid
		self.dooropen = $(self.name + "_dooropen")

		self.door_open = local.door_open
		if(local.door_open == 1) { $(self.name + "_doorclosed") hide; $(self.name + "_dooropen") show }
		else { $(self.name + "_doorclosed") show; $(self.name + "_dooropen") hide }

		local.doorclip = spawn script_model targetname (self.name + "_doorclip")
		local.doorclip model "vehicles/mercedes.tik"
		local.doorclip solid
		local.doorclip hide
		self.doorclip = local.doorclip // do not use self.doorclip = $(self.name + "_doorclip"), otherwise mysterious "array" console errors will occur, even though $(self.name + "_doorclip").size = 1, and even though only 1 entity is inside of .doorclip.
		self thread keep_at_door local.doorclip local.door_open
	}
end

////////////////////////////////////////////////////////////////////////

scriptmaster local.model:

level.mapname = getcvar "mapname"
local.master = spawn scriptmaster

if(level.boatscriptmaster != 1)
{
	local.master aliascache wavelaps sound/amb/Wave_Laps1.wav soundparms 1 0 1 0 200 4000 auto loaded maps level.mapname
	local.master aliascache riverdrive sound/amb/Amb_River.wav soundparms 2.0 0 1 0 200 4000 auto loaded maps level.mapname
	local.master aliascache impact_leavewater sound/null.wav soundparms .7 .4 1 .5 100 1600 auto loaded maps level.mapname

	local.master aliascache boatsinking sound/amb/Amb_RainPuddle_01.wav soundparms 1.5 0.0 1.0 0.0 250 1600 auto loaded maps level.mapname
	local.master aliascache boatsunk sound/amb/Amb_BasementWater.wav soundparms 0.75 0.0 1.0 0.0 200 1600 auto loaded maps level.mapname
	local.master aliascache boatsinkwave1 sound/amb/Amb_Wave_01.wav soundparms 2.0 0.0 1.0 0.0 500 4000 auto loaded maps level.mapname
	local.master aliascache boatsinkwave2 sound/amb/Amb_Wave_02.wav soundparms 2.0 0.0 1.0 0.0 500 4000 auto loaded maps level.mapname
	local.master aliascache boatsinkwave3 sound/amb/Amb_Wave_03.wav soundparms 2.0 0.0 1.0 0.0 500 4000 auto loaded maps level.mapname
	local.master aliascache boatsinkwave4 sound/amb/Amb_Wave_04.wav soundparms 2.0 0.0 1.0 0.0 500 4000 auto loaded maps level.mapname
}

if(level.boatscriptmaster2 != 1 && local.model == "models/vehicles/uboat.tik")
{
	local.master aliascache rocketfireloop sound/amb/Amb_FirePlace.wav soundparms 2.0 0 1 0 400 5000 auto loaded maps level.mapname
	local.master aliascache grenadethrow sound/weapons/foley/Grenade_Throw.wav soundparms .9 .2 .8 .2 400 5000 weapon loaded maps level.mapname
	//local.master aliascache panzerschrecksndfire sound/weapons/fire/PanzershrekFire2.wav soundparms 1.5 0 .92 .15 500 9000 weapon loaded maps level.mapname

	local.master aliascache uboat_reload sound/weapons/fire/TankFire1.wav soundparms 1.5 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache uboat_snd_fire1 sound/weapons/fire/TankCannonFire1.wav soundparms 1.5 0 1 0 2000 5000 weapon loaded maps level.mapname
	local.master aliascache uboat_snd_fire2 sound/weapons/fire/Flak88Fire1.wav soundparms 1.5 0 1 0 2000 5000 weapon loaded maps level.mapname
	local.master aliascache uboat_snd_fire3 sound/weapons/fire/Flak88Fire3.wav soundparms 1.5 0 1 0 2000 5000 weapon loaded maps level.mapname
	local.master aliascache uboat_snd_fire4 sound/weapons/fire/Flak88Fire4.wav soundparms 1.5 0 1 0 2000 5000 weapon loaded maps level.mapname
	level.boatscriptmaster2 = 1
}

if(level.boatscriptmaster3 != 1 && local.model == "models/vehicles/higginsxtrahull.tik")
{
	local.master aliascache higginsdoor_open sound/mechanics/DoorHatchOpen_02.wav soundparms 1.5 0.0 1.0 0.0 160 1600 item loaded maps level.mapname
	local.master aliascache higginsdoor_close1 sound/mechanics/DoorMetalClose_stop1.wav soundparms 1.5 0.2 0.8 0.2 160 1600 item loaded maps level.mapname
	local.master aliascache higginsdoor_close2 sound/mechanics/DoorMetalClose_stop3.wav soundparms 1.5 0.2 0.8 0.2 160 1600 item loaded maps level.mapname
	level.boatscriptmaster3 = 1
}

local.soundtype = 2
if(level.vehiclescriptmaster[local.soundtype] != NIL) { end }
level.vehiclescriptmaster[local.soundtype] = 1

if(local.soundtype == 2 && level.mapname != "training" && level.mapname != "m3l3" && level.mapname != "m5l2a")
{
	local.master aliascache sdkfz_snd_idle sound/vehicle/veh_track_idle.wav soundparms .5 0 1 0 800 4000 auto loaded maps level.mapname
}

if(local.soundtype == 2 && level.mapname != "m3l3" && level.mapname != "m5l2a")
{
	local.master aliascache sdkfz_snd_run sound/vehicle/veh_track_move.wav soundparms 1.5 0 1 0 1000 6000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_revup sound/vehicle/veh_track_revup.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_revdown sound/vehicle/veh_track_revdown.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_shift1 sound/vehicle/veh_track_shiftin.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_shift2 sound/vehicle/veh_track_shiftout.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_on sound/vehicle/veh_track_on.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_start sound/vehicle/veh_track_on.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_off sound/vehicle/veh_track_off.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_stop sound/vehicle/veh_track_off.wav soundparms 1.5 0 1 0 1000 6000 auto loaded maps level.mapname
	local.master aliascache sdkfz_tread_snd_dirt sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_tread_snd_stone sound/vehicle/veh_tread_metal.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_tread_snd_grass sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_tread_snd_wood sound/vehicle/veh_tread_metal.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_tread_snd_mud sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_doorclose sound/null.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_dooropen sound/null.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
}

if(local.soundtype == 2 && level.mapname != "m3l3" && level.mapname != "m5l2a" && level.mapname != "m5l2b")
{
	local.master aliascache sdkfz_vehicle_crash1 sound/null.wav soundparms .7 .4 1 .5 100 1600 auto loaded maps level.mapname
}

if(level.vehiclescriptmaster2 != 1 && level.mapname != "m1l3a" && level.mapname != "m1l3b" && level.mapname != "m4l1")
{
	local.master aliascache explode_truck1 sound/weapons/explo/Explo_MetalMed1.wav soundparms 1.2 .2 .8 .2 1500 8000 weapon loaded maps level.mapname
}

if(level.vehiclescriptmaster2 != 1 && level.mapname != "m1l3a" && level.mapname != "m1l3b")
{
	local.master aliascache explode_truck2 sound/weapons/explo/Explo_MetalMed2.wav soundparms 1.2 .2 .8 .2 1500 8000 weapon loaded maps level.mapname
	local.master aliascache explode_truck3 sound/weapons/explo/Explo_MetalMed3.wav soundparms 1.2 .2 .8 .2 1500 8000 weapon loaded maps level.mapname
	local.master aliascache explode_truck4 sound/weapons/explo/Explo_MetalMed4.wav soundparms 1.2 .2 .8 .2 1500 8000 weapon loaded maps level.mapname
	local.master aliascache explode_truck5 sound/weapons/explo/Explo_MetalMed5.wav soundparms 1.2 .2 .8 .2 1500 8000 weapon loaded maps level.mapname
}

if(level.vehiclescriptmaster2 != 1 && level.mapname != "m5l1a" && level.mapname != "m5l1b" && level.mapname != "m5l2a" && level.mapname != "m5l2b" && level.mapname != "m5l3")
{
	local.master aliascache damage_vehicle1 sound/null.wav soundparms .7 .4 .9 .2 160 1600 auto loaded maps level.mapname
}

if(level.vehiclescriptmaster3 != 1)
{
	local.master aliascache sndfire30cal sound/weapons/fire/50CalFire2.wav soundparms 1.05 .2 .95 .1 800 4000 weapon loaded maps level.mapname

	local.master aliascache vehicledeathfire sound/amb/fire.wav soundparms 1.2 0.0 1.0 0.0 200 2000 auto loaded maps level.mapname
	local.master aliascache vehicledeathwater sound/mechanics/Mec_WaterLoop_03.wav soundparms 1.2 0.0 1.0 0.0 200 2000 auto loaded maps level.mapname
}

level.boatscriptmaster = 1
level.vehiclescriptmaster2 = 1
level.vehiclescriptmaster3 = 1
end
