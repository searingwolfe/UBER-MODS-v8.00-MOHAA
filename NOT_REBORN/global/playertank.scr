main local.name local.model local.origin local.angles local.health local.resettime local.gotout local.groundtarget:

	if(local.model == NIL) { wait 1; println("----- ERROR playertank.scr: 'model' parameter is missing!"); end }
	if(local.model[0] != "m" && local.model[1] != "o" && local.model[2] != "d" && local.model[3] != "e" && local.model[4] != "l" && local.model[5] != "s")
	{
		local.model = "models/" + local.model
		if(level.tankscriptmaster[local.model] != 1) { cache local.model }
	}

	if($(local.name) != NULL) 
	{
		waitframe; if($(local.name) != NULL) { waitframe; if($(local.name) != NULL) { waitframe; if($(local.name) != NULL) { waitframe; if($(local.name) != NULL) { waitframe } } } }
		if($(local.name) != NULL)
		{
			if(level.tankscriptmaster[local.model] != 1) { wait 1; println("----- ERROR playertank.scr: $" + local.name + " must be removed before spawning a drivable tank.") }
			end
		}
	}

	if(local.health == NIL || (local.health != NIL && local.health <= 0 && level.tankscriptmaster[local.model] != 1)) { wait 1; println("----- ERROR playertank.scr: health must be greater than 0."); end }
	if(local.health == NIL || (local.health != NIL && local.health <= 0 && level.tankscriptmaster[local.model] == 1)) { end } // end when in rare cases, a 2nd tank with local.health = 0 could spawn after getting destroyed

	if(local.model == "models/vehicles/kingtank.tik")
	{
		local.turretmodel = models/vehicles/kingcannon.tik
		local.desmodel = models/vehicles/kingtank_all_d.tik
		if(level.tankscriptmaster[local.model] != 1) { cache models/vehicles/kingcannon.tik }
	}
	if(local.model == "models/vehicles/panzer_tank.tik")
	{
		local.turretmodel = models/vehicles/panzer_cannon.tik
		local.desmodel = models/vehicles/panzer_iv_d.tik
		if(level.tankscriptmaster[local.model] != 1) { cache models/vehicles/panzer_cannon.tik }
	}
	if(local.model == "models/vehicles/panzer_tank_europe.tik")
	{
		local.turretmodel = models/vehicles/panzer_cannon_europe.tik
		local.desmodel = models/vehicles/panzer_iv_eud.tik
		if(level.tankscriptmaster[local.model] != 1) { cache models/vehicles/panzer_cannon_europe.tik }
	}
	if(local.model == "models/vehicles/tigertank.tik" || local.model == "models/vehicles/tigertankdsrt.tik")
	{
		local.turretmodel = models/vehicles/tigercannon.tik
		local.desmodel = models/vehicles/tigertank_d.tik
		if(level.tankscriptmaster[local.model] != 1) { cache models/vehicles/tigercannon.tik }
	}
	if(level.tankscriptmaster2 != 1) { cache models/vehicles/jeep_30cal_viewmodel.tik } //{ cache models/vehicles/sdkfz_mg42_viewmodel.tik }

	local.tank = spawn local.model targetname (local.name) // scriptmasters are already added in ubersound.scr
	local.tank.name = local.name
	local.tank.origin = local.origin
	local.tank.originold = local.origin
	local.tank.angles = local.angles
	local.tank.turretmodel = local.turretmodel
	local.tank.desmodel = local.desmodel
	local.tank.health = local.health
	//local.tank.vehiclespeed = local.vehiclespeed // tank speed parameter still does not work, since tank's velocity takes forever to fully reach ( 0 0 0 ), even after the tank has stopped
	local.tank.resettime = local.resettime

	if(local.tank.classname != "VehicleTank") { local.tank remove; wait 1; println("----- ERROR playertank.scr: .tik model is not a VehicleTank."); end }

	if(local.gotout == 1)
	{
		if(local.tank.model == "models/vehicles/kingtank.tik") { local.tank playsound king_snd_stop }
		else { local.tank playsound tank_snd_stop }
	}

	local.tank thread tankreset local.groundtarget
	local.tank thread tankdamage
	local.tank thread tankdeath
	local.tank thread tanktrigger

	if(level.mef_weaponclasses == NIL) { level.mef_weaponclasses = waitthread global/get_player_weaponclass.scr::setup_weapon_classes } // set up weaponclasses for "weaponfix" thread.

	if(level.tank_initorigin[local.name] == NIL) { level.tank_initorigin[local.name] = local.origin } // store the initial origin/angles as level variable arrays
	if(level.tank_initangles[local.name] == NIL) { level.tank_initangles[local.name] = local.angles }
	if(level.tank_inithealth[local.name] == NIL) { level.tank_inithealth[local.name] = local.health }
	local.tank thread tankdamagesmoke

	if(level.tankscriptmaster[local.tank.model] != 1) // this only runs once
	{
		cache local.desmodel
		cache models/emitters/mortar_higgins.tik
		cache models/emitters/mortar_dirt_nosound.tik
		cache models/projectiles/tigercannonshell.tik
		cache models/fx/fx_cannonsmoke.tik
		cache models/emitters/shermansmoke.tik
		thread scriptmaster local.tank.model
		level.tankscriptmaster[local.tank.model] = 1
		level.tankscriptmaster[local.model] = 1
		level.tankscriptmaster2 = 1
	}

	if(level.chainreactors == NIL || (level.chainreactors != NIL && level.chainreactors.size < 1)) { level.chainreactors[1] = local.tank }
	else
	{
		for(local.c = 1; local.c <= 999; local.c++)
		{
			if(level.chainreactors[local.c] == NIL)
			{
				level.chainreactors[local.c] = local.tank
				local.tank thread chainreactors_remove local.c
				break
			}
		}
	}

	if(level.drivable_entities == NIL) { level.drivable_entities[1] = local.name }
	else
	{
		for(local.d = 1; local.d <= level.drivable_entities.size; local.d++)
		{
			if(level.drivable_entities[local.d] == local.name) { end }
		}
		level.drivable_entities[level.drivable_entities.size + 1] = local.name
	}
end

chainreactors_remove local.c:

	while(self != NULL) { waitframe }
	level.chainreactors[local.c] = NIL
end

////////////////////////////////////////////////////////////////////////

tankreset local.groundtarget: // tank turret must be reset each time a new tank spawns (after player exits), otherwise turret will not shoot projectiles.

	self fullstop
	self anim idle // doesn't stop tank treads from moving server-side, only client-side.

	self.gun = self queryturretslotentity 0
	if(self.gun == NIL || self.gun == NULL) { self spawnturret 0 self.turretmodel }
	self.gun = self queryturretslotentity 0
	self.gun solid
	self.gun2 = self queryturretslotentity 1
	if(self.gun2 != NIL && self.gun2 != NULL)
	{
		if(self.gun2.model != "models/vehicles/jeep_30cal.tik")
		{
			self.gun2 remove
			self spawnturret 1 "models/vehicles/jeep_30cal.tik"
			self.gun2 = self queryturretslotentity 1
		}
		self.gun2 notsolid
		self.gun2 pitchcaps ( -60 35 0 )
		self.gun2.scale = 0.5
	}
	self.gun dmprojectile projectiles/tigercannonshell.tik // keep this before any waitframes, otherwise it won't work
	
	if(local.groundtarget == NIL || local.groundtarget == NULL) { wait 1 } // only wait after map initially loads, for turret to get attached to tank after level waittill spawn.
	local.fwd_vec = angles_toforward self.angles
	local.groundtarget_gun2 = spawn script_origin
	local.gun2origin = self gettagposition "turret0"
	local.groundtarget_gun2.origin = trace (local.gun2origin + local.fwd_vec * 56) (local.gun2origin + local.fwd_vec * 10240) 0

	waitframe // need this for setaimtarget to work properly
	if(self != NULL)
	{
		if(local.groundtarget != NIL && local.groundtarget != NULL)
		{
			self.gun turnspeed 9999
			self.gun setaimtarget local.groundtarget
		}
		if(self.gun2 != NIL && self.gun2 != NULL) { self.gun2 setaimtarget local.groundtarget_gun2 }
	}

	waitframe
	if(self != NULL && self.gun != NIL && self.gun != NULL && local.groundtarget != NIL && local.groundtarget != NULL)
	{
		if(self.gun != NIL && self.gun != NULL) { self.gun turnspeed 50 }
		local.groundtarget remove
	}
	local.groundtarget_gun2 remove
	removeclass Camera // also removes PlayerIntermission and other func_cameras
	// when exiting any drivable tanks, a "Camera" entity is left behind (likely from the VehicleTurretGun); remove them to prevent Camera entities from building up over time.
end

tanktrigger:

	if($(self.name + "_trig") != NULL) { $(self.name + "_trig") remove }
	local.trig = spawn trigger_use targetname (self.name + "_trig")
	local.trig.origin = self.origin
	if(self.model != vehicles/kingtank.tik && self.model != models/vehicles/kingtank.tik) { local.trig setsize ( -100 -100 -5 ) ( 100 100 160 ) }
	if(self.model == vehicles/kingtank.tik || self.model == models/vehicles/kingtank.tik) { local.trig setsize ( -140 -140 -5 ) ( 140 140 180 ) }
	local.trig.tank = self
	local.trig glue self
	local.trig setthread triggered
end

triggered:

	local.player = parm.other
	if(local.player.driving == 1 || local.player.passenger == 1 || local.player.flying == 1 || local.player.dead == 1) { end }

	if(self.tank != NULL)
	{
		if(self.tank.driver != NIL)
		{
			if(self.tank.gun2 != NIL && self.tank.gun2 != NULL && (self.tank.turretplayer == NIL || self.tank.turretplayer == NULL)) { self.tank thread turretslot_2nd local.player; end }
			//if(self.tank.passengers.size < self.tank.seats) { self.tank thread passengers } // no passenger seats on tanks
		}
		if(self.tank.driver == NIL)
		{
			if(local.player.isdog != 1) { self.tank thread playergetin }
			if(local.player.isdog == 1) { local.player iprint ("Dogs cannot drive tanks.") } // set other exceptions here
		}
	}
end

playergetin:

	local.player = parm.other
	local.team = local.player.dmteam
	if(self.attachingdriver == 1) { end }
	self.attachingdriver = 1

	local.player.mef_weaponclass = thread global/get_player_weaponclass.scr::main local.player // thread instead of waitthread, but mef_weaponclass should still update in time.
	local.player safeholster 1
	wait 1
	if(self == NULL || local.player == NIL || local.player == NULL || !isalive local.player || local.player.dmteam != local.team || local.player.dead == 1 || level.change_team_score == 1 || level.bbactive == 0 || (self.turretplayer != NIL && self.turretplayer != NULL) || local.player.driving == 1 || local.player.flying == 1)
	{
		if(self != NULL) { self.attachingdriver = 0 }
		end
	}

	self.driver = local.player
	self.driver.driving = 1
	self.driver.drivingent = self
	local.driver = self.driver
	self.player_owner = self.driver

	self.driver forcelegsstate STAND
	self.driver hide
	self.driver nodamage
	self.driver notsolid
	self.driver iprint ("JUMP = exit tank.")
	self.driver iprint ("Hold USE(e) for 3 seconds while not moving tank or turret = repair tank.")
	self.driver.driving_state_jump = 0

	self attachdriverslot 0 self.driver
	self thread dummyavatar
	local.groundtarget = spawn script_origin
	local.turretangles = self.gun.angles
	local.holdtime = 0

	if(self.driver.using_pack == 1)
	{
		self.driver stufftext "globalwidgetcommand june6 linkcvar phealth"
		self.driver stufftext ("globalwidgetcommand june6 statbar vertical 0 " + level.tank_inithealth[self.name] )
		self.driver stufftext "globalwidgetcommand charliesector linkcvar phealth"
		self.driver stufftext "set phealth 100"
	}
	else { self.driver thread display self.name }

	self.attachingdriver = 0
	while(self != NULL && isalive self.driver && self.driver.dmteam == local.team && self.driver.dead != 1 && level.change_team_score != 1 && level.bbactive != 0)
	{
		//if(self.velocity != ( 0 0 0 )) { self.velocity = self.velocity + self.forwardvector * self.vehiclespeed } // does not work properly, so speed increase was removed.

		local.fwd_vec = angles_toforward ( self.driver.viewangles[0] self.gun.angles[1] self.driver.viewangles[2] )
		local.start = self.gun gettagposition "tag_barrel"		// aim the groundtarget from where turret currently is, since turret rotation is slower than player's aim.
		local.groundtarget.origin = trace (local.start + local.fwd_vec * 56) (local.start + local.fwd_vec * 10240) 0

		if(self.driver.driving_state_jump == 1) // Press JUMP to exit.
		{
			self thread driverreset
			self thread tankreset local.groundtarget
			self.driver thread wallstuck_fix
			self.driver stoploopsound
			self.driver = NIL
			break
		}
		else if(self.driving_state_forward != 1 && self.driving_state_backward != 1 && self.driving_state_left != 1 && self.driving_state_right != 1 && self.gun.angles == local.turretangles && self.health < level.tank_inithealth[self.name])
		{
			if(self.driver.useheld == 1) { local.holdtime++ }
			if(local.holdtime >= 30)
			{
				self.health += 1.5	// if the tank is not moving, turret is not moving, and the driver is holding USE(e) for > 1 second, then slowly repair the tank's health.
				self.driver loopsound weldingtorch
			}
		}

		if(self.driver.fireheld == 1 && self.firingshell != 1)
		{
			self thread fire_tank_sound
			self thread projectile
		}
		if(self.shooter != NIL) { self thread shooter_NIL }

		if(self.driver.useheld != 1 || self.driver.fireheld == 1 || self.gun.angles != local.turretangles || self.health >= level.tank_inithealth[self.name]) { local.holdtime = 0; self.driver stoploopsound }
		if(local.holdtime > 9999) { local.holdtime = 9999 }
		local.turretangles = self.gun.angles

		if(self.health > level.tank_inithealth[self.name]) { self.health = level.tank_inithealth[self.name] }
		self.driver stufftext ("set phealth " + int(self.health))
		waitframe
	}

	if(self != NULL) // spawn in the new tank and remove the old one.
	{
		thread main self.name self.model self.origin self.angles self.health self.resettime 1 local.groundtarget

		if(self.driver != NIL && self.driver != NULL)
		{
			if(self.driver.dmteam != local.team) { local.newteam = 1 }
			self thread driverreset 0 local.newteam level.change_team_score
			self thread tankreset local.groundtarget
		}
		if(self.turretplayer != NIL && self.turretplayer != NULL) { self waitthread turretplayer_reset self.turretplayer.dmteam self.turretplayer }

		self.driver = NIL // the old tank must be properly removed, otherwise the server will crash if anyone driving the tank leaves the game (becomes NULL).
		if(self.gun2 != NIL && self.gun2 != NULL) { self.gun2 remove }
		self.gun remove
		self remove
	}
	waitframe
	if(local.driver != NULL)
	{
		local.driver.driving = 0
		local.driver.drivingent = NIL
		local.driver stoploopsound
		if(!isalive local.driver) { local.driver stufftext ("set phealth 0") }

		if(local.driver.using_pack == 1)
		{
			local.driver stufftext "globalwidgetcommand june6 linkcvar fuel"
			local.driver stufftext ("globalwidgetcommand june6 statbar vertical 0 " + level.jetpack_max_fuel)
			local.driver stufftext "globalwidgetcommand charliesector linkcvar fuel"
		}
		else
		{
			local.driver stufftext "hidemenu dday1"
			local.driver stufftext "hidemenu dday2"
		}

		local.origin = local.driver.origin
		while(local.driver != NULL && !isalive local.driver && local.driver.dmteam != "spectator")
		{
			local.driver.origin = ( local.origin[0] local.origin[1] local.driver.origin[2] ) // for some reason, drivers' dead bodies would move forward across the ground until they hit a wall.
			local.driver notsolid
			local.driver droptofloor
			waitframe
		}
	}
end

shooter_NIL:

	waitframe
	if(self != NULL) { self.shooter = NIL }
end

driverreset local.death local.newteam local.changescore:

	if(self.driver == NIL) { end } // if the tank blew up with nobody driving it, end this thread.

	if(local.death != 1) { cueplayer } 				// reattaches camera to player's head
	local.driver = self.driver

	self detachdriverslot 0 self.driver
	if(local.changescore != 1 && level.bbactive != 0) { self.driver thread weaponfix local.newteam } // player's weapon is invisible when they exit the tank. auto-switch their weapons to make them visible again (wait until they're alive)
	else { self.driver thread weaponfix2 }

	if(self.model == "models/vehicles/kingtank.tik") { local.outheight = 170 }
	else { local.outheight = 150 }

	if(self.driver.dmteam != spectator)
	{
		self.driver show
		self.driver solid
		self.driver takedamage
		self.driver forcetorsostate STAND // without this, players will be stuck in noclip mode, even though noclip isn't used for drivers (doing "self.driver noclip; self driver noclip" also works).
		if(local.death != 1 && local.changescore != 1)
		{
			if(local.newteam != 1) { self.driver.origin = self.origin + (angles_toup self.angles * local.outheight) }
			self.driver.viewangles = ( self.angles[0] self.angles[1] 0 )
		}
	}
	waitframe
	if(local.driver != NULL) { local.driver.viewangles = ( 0 local.driver.viewangles[1] 0 ) } // make sure player's camera is horizontal (in case they left while tank was on a sloped terrain.
end

fire_tank_sound:

	if(self.model == "models/vehicles/kingtank.tik")
	{
		if(level.mapname != "m5l3") { self playsound king_snd_fire2 } // firing sound
		if(level.mapname != "m5l2a" && level.mapname != "m5l2b") { self.driver playsound king_snd_fire1 } // reloading sound
	}
	else
	{
		if(level.mapname != "m3l3" && level.mapname != "m5l1a" && level.mapname != "m5l1b" && level.mapname != "m5l2a" && level.mapname != "m5l2b" && level.mapname != "m5l3") { self.driver playsound tank_snd_fire }
		if(level.mapname != "m5l2a" && level.mapname != "m5l2b") { self playsound tank_snd_reload }
	}
	self.firingshell = 1

	self.tanksmokecount = 0
	if(self.tanksmoking != 1) { self thread smokey }
	wait 5.05
	if(self != NULL) { self.firingshell = 0 }
end

projectile:

	local.player = self.driver // used for the for-loop later

	local.rocket = spawn script_model
	local.rocket model "projectiles/tigercannonshell.tik"
	local.rocket.origin = self.gun gettagposition "tag_barrel"
	local.rocket.angles = self.gun.angles
	local.rocket light 0 1 0 250
	local.rocket.scale = 2
	local.rocket solid
	local.rocket physics_on    // need this for gravity and waittill touch to work.

	local.rocket gravity 0
	local.angles = ( self.driver.viewangles[0] self.gun.angles[1] self.driver.viewangles[2] )
	local.rocket.velocity = (angles_toforward local.angles) * 6000

	local.hitthing = self
	while(local.hitthing == self || (self != NULL && local.hitthing == self.gun))
	{
		local.rocket waittill touch
		local.hitthing = parm.other
	}

	local.rocket.velocity = ( 0 0 0 )
	local.explode = spawn "fx/explosionTIGERshell.tik"
	local.explode.origin = local.rocket.origin
	local.explode.scale = 2.5
	local.explode light 1 0 0 500
	local.explode anim idle
	//local.explode playsound bazooka_exp // already included in explosionTIGERshell

	if(self != NULL) { local.rocket.player_owner = self.driver }

	local.blewup = 1
	for(local.i = 1; local.i <= $player.size; local.i++) // use this instead of radiusdamage, so rockets can count as score/kills
	{
		if(vector_length(local.explode.origin - $player[local.i].origin) <= 400) // "local.explode" emitters cannot be used with "cansee"
		{
			if(local.player == NIL || local.player == NULL)
			{
				if($player[local.i].driving != 1 && $player[local.i].flying != 1 && $player[local.i] cansee local.rocket 360)
				{
					$player[local.i] damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0
				}
				else if($player[local.i].drivingent != NIL && $player[local.i].drivingent != NULL)
				{
					if($player[local.i].flying == 1) { $("planehit" + $player[local.i].entnum) damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else { $player[local.i].drivingent damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
				}
			}
			else if($player[local.i] != local.player && $player[local.i].dmteam == local.player.dmteam && getcvar("g_teamdamage") != "1" && getcvar("g_gametype") != "1") { local.blewup = 0 }
			else
			{
				if($player[local.i].driving != 1 && $player[local.i].flying != 1 && $player[local.i] cansee local.rocket 360)
				{
					$player[local.i] damage local.player 500 local.player (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 // "damage" does not hurt teammates, but scriptbazookaexplosion.tik does
				}
				else if($player[local.i].drivingent != NIL && $player[local.i].drivingent != NULL)
				{
					$player[local.i].drivingent.shooter = local.player
					if($player[local.i].flying == 1) { $("planehit" + $player[local.i].entnum) damage local.player 500 local.player (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else { $player[local.i].drivingent damage local.player 500 local.player (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
				}
			}
		}
	}
	local.rocket remove
	if(local.blewup == 1) { radiusdamage local.explode.origin 500 400 } // occurs one frame after impact, otherwise some scorepoints (i.e. killing players using nebelwerfers) will not count properly.
	waitframe
	local.explode remove
end

smokey:

	self.tanksmoking = 1
	local.targetname = self.targetname
	local.tanksmokecount = self.tanksmokecount

	local.smoke = spawn script_model
	local.smoke model "fx/fx_cannonsmoke.tik"
	self.gun = self QueryTurretSlotEntity 0
	local.smoke.origin = self.gun gettagposition "tag_barrel"

	while(self != NULL && self.tanksmokecount < 120)
	{
		local.smoke.origin = self.gun gettagposition "tag_barrel"
		self.tanksmokecount++
		local.tanksmokecount = self.tanksmokecount
		waitframe
	}

	local.c = 0
	while($(local.targetname) == NULL) // tank is always removed after a player exits the tank, wait for the tank to respawn before continuing smokecount
	{
		if(local.c >= 10) // remove the smoke sooner if the tank was destroyed
		{
			if(local.smoke != NULL) { local.smoke remove }
			end
		}
		local.c++
		waitframe
	}

	$(local.targetname).tanksmoking = 1
	$(local.targetname).tanksmokecount = local.tanksmokecount
	$(local.targetname).gun = $(local.targetname) QueryTurretSlotEntity 0

	while($(local.targetname) != NULL && $(local.targetname).gun != NULL && $(local.targetname).tanksmokecount != NIL && $(local.targetname).tanksmokecount < 120)
	{
		local.smoke.origin = $(local.targetname).gun gettagposition "tag_barrel"
		$(local.targetname).tanksmokecount++
		waitframe	
	}

	if(local.smoke != NULL) { local.smoke remove }
	if($(local.targetname) != NULL) { $(local.targetname).tanksmoking = 0; $(local.targetname).tanksmokecount = 0 }
end

tankdamage:

	local.c = 0
	while(self != NULL && self.health > 0)
	{
		if(self != NULL)
		{
			local.previoushealth = self.health
			if(local.c > 0) { local.c-- }
		}
		waitframe
		if(self != NULL && local.previoushealth > self.health)
		{
			local.c = local.c + 2
			self playsound damage_tank
			//if(local.c == 2) { exec global/earthquake.scr .2 3 0 0 } // if tank is getting constantly damaged per frame, stop earthquake from spamming. (removed, since it was still getting annoying)
		}
	}
end

tankdamagesmoke:

	local.smoke = spawn script_model
	local.smoke model "models/emitters/shermansmoke.tik"
	local.smoke.origin = self gettagposition "turret0"
	local.smoke.angles = ( 270 0 0 )
	local.smoke hide
	local.smoke notsolid

	while(self != NULL && self.health > 0)
	{
		local.smoke.origin = self gettagposition "turret0"
		local.smoke.scale = 1.000 - (self.health / level.tank_inithealth[self.name])

		if(int(self.health) < int(level.tank_inithealth[self.name])) { local.smoke show }
		else { local.smoke hide }
		waitframe
	}
	local.smoke remove
end

tankdeath:

	self waittill death // when waiting until "death", tank is not NULL yet
	self playsound explode_tank

	local.destank = spawn script_model
	local.destank model self.desmodel
	local.destank.origin = self.origin
	local.destank.angles = self.angles
	local.destank.scale = self.scale

	self thread driverreset 1 		// local.death = 1
	self thread mainreset local.destank	// waiting self.resettime seconds until a new tank is spawned in

	self thread kill_riders
	self.driver = NIL

	if(self.turretplayer != NIL) { self waitthread turretplayer_reset self.turretplayer.dmteam self.turretplayer 1 } // ensures that the turretplayer is alaways detached after tank dies

	if(self.gun != NIL && self.gun != NULL) { self.gun remove }
	if(self.gun2 != NIL && self.gun2 != NULL) { self.gun2 remove }
	exec global/earthquake.scr .5 3 0 0

	if(self.shooter != NIL && self.shooter != NULL)
	{
		if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { local.shooter = self.shooter.player_owner }
		else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { local.shooter = self.shooter.owner }
		else { local.shooter = self.shooter }
	}
	local.blewup = 1
	for(local.i = 1; local.i <= $player.size; local.i++) // use this instead of radiusdamage, so death explosions can count as score/kills.
	{
		if(vector_length(self.origin - $player[local.i].origin) <= 750) // "local.explode" emitters cannot be used with "cansee"
		{
			if(local.shooter == NIL || local.shooter == NULL)
			{
				if($player[local.i].driving != 1 && $player[local.i].flying != 1 && $player[local.i] cansee local.destank 360) // "cansee self" does not work.
				{
					$player[local.i] damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0
				}
				else if($player[local.i].drivingent != NIL && $player[local.i].drivingent != NULL)
				{
					if($player[local.i].flying == 1) { $("planehit" + $player[local.i].entnum) damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else { $player[local.i].drivingent damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
				}
			}
			else if($player[local.i] != local.shooter && $player[local.i].dmteam == local.shooter.dmteam && getcvar("g_teamdamage") != "1" && getcvar("g_gametype") != "1") { local.blewup = 0 }
			else
			{
				if($player[local.i].driving != 1 && $player[local.i].flying != 1 && $player[local.i] cansee local.destank 360)
				{
					$player[local.i] damage local.shooter 500 local.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 // "damage" does not hurt teammates, but scriptbazookaexplosion.tik does
				}
				else if($player[local.i].drivingent != NIL && $player[local.i].drivingent != NULL)
				{
					$player[local.i].drivingent.shooter = local.shooter
					if($player[local.i].flying == 1) { $("planehit" + $player[local.i].entnum) damage local.shooter 500 local.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else { $player[local.i].drivingent damage local.shooter 500 local.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
				}
			}
		}
	}
	self remove

	local.boom = spawn script_model
	local.boom model "models/emitters/mortar_higgins.tik"
	local.boom.origin = local.destank.origin
	local.boom.angles = ( 0 -90 0 ) + ( 260 0 0 )
	local.boom.scale = 1.5
	local.boom anim start
	local.boom notsolid

	local.debris = spawn script_model targetname "mortar_dirt_nosound"
	local.debris model "emitters/mortar_dirt_nosound.tik" 
	local.debris.origin = local.destank.origin
	local.debris.scale = 1.0
	local.debris anim start
	local.debris notsolid
	waitframe
	local.boom remove
	local.debris remove
	if(local.blewup == 1) { radiusdamage local.destank.origin 500 750 } // this must be one frame after other damages in this thread, otherwise chain-reaction kills will not count.
end

kill_riders:

	if(self.turretplayer != NIL && self.turretplayer != NULL)
	{
		if(self.shooter != NIL)
		{
			if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.turretplayer damage self.shooter.player_owner 9999999 self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.turretplayer damage self.shooter.owner 9999999 self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			else if(self.shooter != NULL) { self.turretplayer damage self.shooter 9999999 self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
		}
		else { self.turretplayer volumedamage 9999999 }
	}

	if(self.passengers.size >= 1)
	{
		for(local.i = 1; local.i <= self.passengers.size; local.i++)
		{
			if(self.shooter != NIL)
			{
				if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.passengers[local.i] damage self.shooter.player_owner 9999999 self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
				else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.passengers[local.i] damage self.shooter.owner 9999999 self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
				else if(self.shooter != NULL) { self.passengers[local.i] damage self.shooter 9999999 self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			}
			else { self.passengers[local.i] volumedamage 9999999 }
		}
	}

	if(self.shooter != NIL)
	{
		if(self.driver != NIL)
		{
			if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.driver damage self.shooter.player_owner 9999999 self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.driver damage self.shooter.owner 9999999 self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			else if(self.shooter != NULL) { self.driver damage self.shooter 9999999 self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
		}
	}
	else if(self.driver != NIL) { self.driver volumedamage 9999999 } // let's make sure the driver is dead.
end

mainreset local.destank:

	if(self.resettime == NIL || self.resettime <= 0) { end }

	local.name = self.name
	local.model = self.model
	local.turretmodel = self.turretmodel
	local.desmodel = self.desmodel
	local.origin = self.originold  // respawns the vehicle where it was destroyed, only by setting "thread main" origin/angles to "local.origin" "local.angles".
	local.angles = self.angles
	local.health = level.tank_inithealth[self.name]
	local.vehiclespeed = self.vehiclespeed
	local.resettime = self.resettime

	while(self != NULL) { waitframe }
	wait local.resettime

	local.destank remove
	thread main local.name local.model level.tank_initorigin[local.name] level.tank_initangles[local.name] local.health local.resettime
end

////////////////////////////////////////////////////////////////////////

turretslot_2nd local.player:

	if(local.player == self.driver || local.player.passenger == 1 || local.player.driving == 1 || local.player.flying == 1 || local.player.dead == 1 || level.change_team_score == 1 || level.bbactive == 0) { end }

	if(local.player.isdog == 1) { local.player iprint ("Dogs cannot use vehicle turrets."); end }

	if(local.player.dmteam != self.driver.dmteam && local.player.dmteam != "spectator" && getcvar("g_gametype") != "1")
	{
		local.player iprint ("An enemy player is driving this vehicle!")
		end
	}

	self.turretplayer = local.player
	//self.turretplayer hide
	self.turretplayer.scale = 0.5
	self.turretplayer.passenger = 1
	self.turretplayer.driving = 1
	self.turretplayer.turreting = 1
	self.turretplayer.remove_viewmodel = 0
	self.turretplayer.driving_state_jump = 0
	self.turretplayer forcetorsostate TURRET_START
	self.turretplayer iprint ("JUMP = exit turret.")
	self.turretplayer.turretingent = self // used with killstreaks/damagehandler.scr to properly give score to shooter if turretplayer's vehicle gets blown up by an enemy bazooka rocket.

	self unlock
	self.gun unlock
	self.gun2 unlock
	self.gun2 douse local.player
	self attachturretslot 1 local.player
	self.gun2 lock
	self.gun lock
	self lock
	self.gun2 show
	local.player glue self.gun2 // keep player's angles aligned with 30cal turret.

	local.driver = self.driver
	local.team = local.player.dmteam

	while(self != NULL && self.driver != NIL && self.driver != NULL && isalive self.driver && isalive local.player && local.player.dmteam == local.team && local.player.dead != 1 && level.change_team_score != 1 && level.bbactive != 0)
	{
		local.player.origin = self.gun2.origin
		if(local.player.fireheld == 1) { self.gun2 playsound tankfire30cal }

		if(self.turretplayer.driving_state_jump == 1)
		{
			self waitthread turretplayer_reset local.team local.player
			end
		}
		waitframe
	}
	if(self != NULL) { self waitthread turretplayer_reset local.team local.player }

	if(local.player != NULL)
	{
		local.player.passenger = 0
		local.player.driving = 0
		local.player.turreting = 0
		local.player.remove_viewmodel = 1
		local.player.scale = 1
		local.player unglue
		//local.player show
	}
end

turretplayer_reset local.team local.player local.dead:

	if(local.player == NIL || local.player == NULL) // if turret player left the game
	{
		self lock
		self.gun lock
		self.gun2 lock
		self.turretplayer = NIL // if turret player leaves, then rejoins, he cannot see the vehicle's turretgun, but everyone else can (weird graphics glitch?).
		end			// for the rejoining player to fix it: enter the turret again, or wait for the vehicle to respawn.
	}

	local.player unglue
	local.player.passenger = 0
	local.player.driving = 0
	local.player.turreting = 0
	local.player.scale = 1
	if(local.player.dmteam != "spectator") { local.player show }
	local.player thread wallstuck_fix
	local.player forcetorsostate STAND
	local.player takedamage // this prevents a rare bug that kept the turret player from ever dying again (player is somehow, but only sometimes given "nodamage"?)
	local.player.turretingent = NIL

	if(isalive local.player && local.player.dmteam != "spectator")
	{
		self unlock
		self.gun unlock
		self.gun2 unlock
		self douse local.player
		local.player exit
		local.player forcelegsstate STAND
	}
	self lock
	self.gun lock
	self.gun2 lock
	self.turretplayer = NIL

	if(local.player.dmteam != local.team && local.player.dmteam != "spectator") { local.player respawn }
	else { local.player.viewangles = ( self.gun.angles[0] self.gun.angles[1] 0 ) }

	if(local.player.dmteam == local.team) { local.player.origin = self.origin + self.forwardvector * -100 + (angles_toup self.angles * 200) }

	if(!isalive local.player || (self.driver != NIL && self.driver != NULL && !isalive self.driver) || local.dead == 1)
	{
		if(self != NULL && self.shooter != NIL)
		{
			if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { local.player damage self.shooter.player_owner 9999999 self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { local.player damage self.shooter.owner 9999999 self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			else { local.player damage self.shooter 9999999 self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
		}
		else { local.player damage $world 9999999 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
	}
end

////////////////////////////////////////////////////////////////////////

weaponfix local.newteam:

	while(self != NULL && self.dmteam == spectator) { waitframe; local.spectator = 1 } // tank drivers who go to spectator still need their invisible weapons fixed if they join a team again.
	if(local.spectator == 1)
	{
		while(self != NULL && self.inventory.size <= 1) { waitframe } // if spectator joined a team but hasn't chosen a weapon yet (not yet spawned), keep waiting until he does.
	}
	if(local.newteam == 1 || local.spectator == 1) { self thread weaponfix2; end } // go to a simpler weaponfix thread if tank driver switched teams or came out of spectator.

	waitframe
	if(self.dmteam == allies) { self give models/weapons/colt45.tik } // make sure they have a pistol to switch to. switching weaopns makes their guns visible again, so do it automatically.
	if(self.dmteam == axis) { self give models/weapons/p38.tik }	// wait 0.5 cannot be any shorter in time, otherwise "useweaponclass" will not work (guns still invisible).
	wait 0.1
	self stufftext "useweaponclass pistol"
	wait 0.55

	if(self.mef_weaponclass != NIL) { self stufftext ("useweaponclass " + self.mef_weaponclass) } // if a player entered the tank with his main weapon (mg, smg, rifle, sniper, heavy), switch to main weapon.
	if(self.mef_weaponclass == NIL)
	{
		if(self.dmteam == allies) { self give models/weapons/m2frag_grenade.tik } // if a player entered the tank with a pistol, grenade, or empty-handed,
		if(self.dmteam == axis) { self give models/weapons/steilhandgranate.tik } // give him a grenade to switch to, after he switches to pistol and waits 0.5 seconds.
		self stufftext ("useweaponclass grenade")
	}
end

weaponfix2:

	self.mef_weaponclass = waitthread global/get_player_weaponclass.scr::main self
	self stufftext "useweaponclass pistol"
	wait 0.55
	self stufftext ("useweaponclass " + self.mef_weaponclass)
end

////////////////////////////////////////////////////////////////////////

dummyavatar:

	local.avatar = spawn func_beam
	local.avatar attach self.driver "Bip01 Head"
	local.avatar.origin = self.driver.origin + ( 0 0 100 )
	local.avatar endpoint (local.avatar.origin + ( 0 0 13 ))
	local.avatar minoffset 0.0
	local.avatar maxoffset 0.0
	local.avatar color ( 1 1 1 )
	local.avatar scale 7.0
	local.avatar life 0
	if(self.driver.dmteam == "allies") { local.avatar shader ("textures/hud/allies_headicon") }
	if(self.driver.dmteam == "axis") { local.avatar shader ("textures/hud/axis_headicon") }
	local.avatar numsegments 1
	local.avatar alpha 0.80
	local.avatar activate

	local.team = self.driver.dmteam
	while(self != NULL && isalive self.driver && self.driver.dmteam == local.team && self.driver.dead != 1 && level.change_team_score != 1 && level.bbactive != 0)
	{
		local.avatar.origin = self.driver.origin + ( 0 0 100 )
		local.avatar endpoint (local.avatar.origin + ( 0 0 13 ))
		waitframe
	}
	local.avatar remove
end

////////////////////////////////////////////////////////////////////////

wallstuck_fix:

	local.c = 0
	local.origin = self.origin
	local.team = self.dmteam

	if(self.wallstuck_fixing == 1) { end }
	self.wallstuck_fixing = 1

	while(self != NULL && isalive self && self.dmteam == local.team) // while player is stuck in a wall (falling) and origin isn't changing, count a few seconds, then respawn the player
	{
		if(local.c >= 60) // about 3 seconds
		{
			if((self getmovement) == falling && self.origin == local.origin) { self respawn }
			if(self.isdog == 1) { self hide }
			break
		}
		local.c++
		waitframe
	}
	if(self != NULL) { self.wallstuck_fixing = 0 }
end

////////////////////////////////////////////////////////////////////////

display local.name:

	if(game.game != "AA") { local.menu1 = "bastogne1"; local.menu2 = "bastogne2" }
	else { local.menu1 = "dday1"; local.menu2 = "dday2" }

	self stufftext ("globalwidgetcommand " + local.menu1 + " shader townhallwindow")
	self stufftext ("globalwidgetcommand " + local.menu1 + " fgcolor 1.00 1.00 1.00 1.00")
	self stufftext ("globalwidgetcommand " + local.menu1 + " bgcolor 0.50 0.50 0.50 0.00")
	self stufftext ("globalwidgetcommand " + local.menu1 + " fadein 0")
	self stufftext ("globalwidgetcommand " + local.menu1 + " menu " + local.menu1 + " 640 480 NONE 0")
	self stufftext ("globalwidgetcommand " + local.menu1 + " virtualres 1")
	self stufftext ("globalwidgetcommand " + local.menu1 + " fullscreen 1")

	self stufftext "globalwidgetcommand june6 borderstyle NONE"
	self stufftext "globalwidgetcommand june6 shader textures/hud/healthback"
	self stufftext "globalwidgetcommand june6 rect 16 420 16 64"
	self stufftext "globalwidgetcommand june6 fgcolor 1.00 1.00 1.00 1.00"
	self stufftext "globalwidgetcommand june6 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand june6 linkcvar phealth"
	self stufftext ("globalwidgetcommand june6 statbar vertical 0 " + level.tank_inithealth[local.name] )
	self stufftext "globalwidgetcommand june6 statbar_shader textures/hud/healthmeter"
	self stufftext "globalwidgetcommand june6 statbar_shader_flash textures/hud/healthmeterflash"

	self stufftext ("globalwidgetcommand " + local.menu2 + " fgcolor 1.00 1.00 1.00 1.00")
	self stufftext ("globalwidgetcommand " + local.menu2 + " bgcolor 0.50 0.50 0.50 0.00")
	self stufftext ("globalwidgetcommand " + local.menu2 + " fadein 0")
	self stufftext ("globalwidgetcommand " + local.menu2 + " menu " + local.menu2 + " 640 480 NONE 0")
	self stufftext ("globalwidgetcommand " + local.menu2 + " virtualres 1")
	self stufftext ("globalwidgetcommand " + local.menu2 + " fullscreen 1")

	self stufftext "globalwidgetcommand charliesector borderstyle NONE"
	self stufftext "globalwidgetcommand charliesector textalign left "
	self stufftext "globalwidgetcommand charliesector rect 40 470 150 20"
	self stufftext "globalwidgetcommand charliesector fgcolor 0.70 0.60 0.05 1.00"
	self stufftext "globalwidgetcommand charliesector bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand charliesector linkcvar phealth"
	self stufftext "globalwidgetcommand charliesector font facfont-20"
	self stufftext "globalwidgetcommand charliesector shader townhallwindow"

	self stufftext ("showmenu " + local.menu2)
	self stufftext ("showmenu " + local.menu1)
	self stufftext "set phealth 100"
end

////////////////////////////////////////////////////////////////////////

scriptmaster local.model:

level.mapname = getcvar "mapname"
local.master = spawn scriptmaster

if(level.scriptmaster[weldingtorch] != 1 && level.scriptmaster[detonator_switch] != 1)
{
	local.master aliascache weldingtorch sound/mechanics/WeldingTorch.wav soundparms 1.0 0.0 1.0 0.0 400 1000 item loaded maps level.mapname
	level.scriptmaster[weldingtorch] = 1
}

if(local.model == "models/vehicles/kingtank.tik")
{
	local.soundtype = 1
}
else { local.soundtype = 2 }

if(level.tankscriptmaster[local.soundtype] != NIL) { end }
level.tankscriptmaster[local.soundtype] = 1

if(local.soundtype == 1 && level.mapname != "m5l1a" && level.mapname != "m5l1b" && level.mapname != "m5l2a" && level.mapname != "m5l2b" && level.mapname != "m5l3")
{
	local.master aliascache king_snd_idle sound/vehicle/veh_tank_idle1.wav soundparms .5 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_revup sound/vehicle/veh_tank_revup1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_revdown sound/vehicle/veh_tank_revdown1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_shift1 sound/vehicle/veh_tank_shift1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_shift2 sound/vehicle/veh_tank_shift2.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_shift3 sound/vehicle/veh_tank_shift3.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_on sound/vehicle/veh_tank_on1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_start sound/vehicle/veh_tank_on1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_off sound/vehicle/veh_tank_off1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_stop sound/vehicle/veh_tank_off1.wav soundparms 1.5 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_tread_snd_dirt sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_tread_snd_stone sound/vehicle/veh_tread_metal.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_tread_snd_grass sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_tread_snd_wood sound/vehicle/veh_tread_metal.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_tread_snd_mud sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_doorclose sound/mechanics/DoorHatchClose_02.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_vehicle_crash1 sound/mechanics/damage_vehicle_1.wav soundparms .5 .5 .7 .5 160 1600 auto loaded maps level.mapname
	local.master aliascache king_vehicle_crash2 sound/mechanics/damage_vehicle_2.wav soundparms .5 .5 .7 .5 160 1600 auto loaded maps level.mapname
	local.master aliascache king_vehicle_crash3 sound/mechanics/damage_vehicle_3.wav soundparms .5 .5 .7 .5 160 1600 auto loaded maps level.mapname
	local.master aliascache king_vehicle_crash4 sound/mechanics/damage_vehicle_4.wav soundparms .5 .5 .7 .5 160 1600 auto loaded maps level.mapname
	local.master aliascache king_snd_turret_up sound/null.wav soundparms .7 0 1.3 .2 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_reload sound/null.wav soundparms .9 .2 .9 .2 800 4000 auto loaded maps level.mapname
}
if(local.soundtype == 1 && level.mapname != "m5l2a" && level.mapname != "m5l2b")
{
	local.master aliascache king_snd_fire1 sound/weapons/fire/TankFire1.wav soundparms 1.5 0 1 0 2000 4000 weapon loaded maps level.mapname
}
if(local.soundtype == 1 && level.mapname != "m5l3")
{
	local.master aliascache king_snd_fire2 sound/weapons/fire/TankCannonFire1.wav soundparms 1.5 0 1 0 2000 4000 weapon loaded maps level.mapname
}
if(local.soundtype == 1)
{
	local.master aliascache king_snd_dooropen sound/null.wav soundparms .9 .2 .9 .2 800 4000 auto loaded maps level.mapname
}

if(local.soundtype == 2 && level.mapname != "m5l2a" && level.mapname != "m5l2b")
{
	local.master aliascache tank_snd_reload sound/weapons/fire/TankFire1.wav soundparms 1.5 0 1 0 800 4000 weapon loaded maps level.mapname
}

if(local.soundtype == 2 && level.mapname != "m3l3" && level.mapname != "m5l1a" && level.mapname != "m5l1b" && level.mapname != "m5l2a" && level.mapname != "m5l2b" && level.mapname != "m5l3")
{
	local.master aliascache tank_tread_snd_dirt sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache tank_tread_snd_grass sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache tank_tread_snd_wood sound/vehicle/veh_tread_metal.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache tank_tread_snd_mud sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache tank_snd_fire1 sound/weapons/fire/TankCannonFire1.wav soundparms 1.5 0 1 0 2000 4000 weapon loaded maps level.mapname
	local.master aliascache tank_snd_fire2 sound/weapons/fire/Flak88Fire1.wav soundparms 1.5 0 1 0 2000 4000 weapon loaded maps level.mapname
	local.master aliascache tank_snd_fire3 sound/weapons/fire/Flak88Fire3.wav soundparms 1.5 0 1 0 2000 4000 weapon loaded maps level.mapname
	local.master aliascache tank_snd_fire4 sound/weapons/fire/Flak88Fire4.wav soundparms 1.5 0 1 0 2000 4000 weapon loaded maps level.mapname

	if(level.mapname != "m1l2b")
	{
		local.master alias tank_snd_run sound/vehicle/veh_tank_run1.wav soundparms 1 0 1 0 800 4000 auto streamed maps level.mapname
		local.master aliascache tank_snd_revup sound/vehicle/veh_tank_revup1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
		local.master aliascache tank_snd_revdown sound/vehicle/veh_tank_revdown1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
		local.master aliascache tank_snd_shift1 sound/vehicle/veh_tank_shift1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
		local.master aliascache tank_snd_shift2 sound/vehicle/veh_tank_shift2.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
		local.master aliascache tank_snd_shift3 sound/vehicle/veh_tank_shift3.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
		local.master aliascache tank_snd_on sound/vehicle/veh_tank_on1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
		local.master aliascache tank_snd_start sound/vehicle/veh_tank_on1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
		local.master aliascache tank_snd_off sound/vehicle/veh_tank_off1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
		local.master aliascache tank_snd_stop sound/vehicle/veh_tank_off1.wav soundparms 1 0 1 0 1000 4000 auto loaded maps level.mapname
		local.master aliascache tank_tread_snd_stone sound/vehicle/veh_tread_metal.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname

		if(level.mapname != "training")
		{
			local.master alias tank_idle_training sound/vehicle/veh_tank_idle1.wav soundparms 1 0 1 0 800 4000 auto streamed maps level.mapname
			local.master alias tank_snd_idle sound/vehicle/veh_tank_idle1.wav soundparms .5 0 1 0 800 4000 auto streamed maps level.mapname
		}
	}
}

if(level.tankscriptmaster2 != 1 && level.mapname != "m3l3" && level.mapname != "m5l1a" && level.mapname != "m5l1b" && level.mapname != "m5l2a" && level.mapname != "m5l2b" && level.mapname != "m5l3")
{
	local.master aliascache tank_snd_move sound/vehicle/veh_tank_turret1.wav soundparms .9 .2 .9 .2 800 4000 auto loaded maps level.mapname
}

if(level.tankscriptmaster2 != 1 && level.mapname != "m5l1a" && level.mapname != "m5l1b" && level.mapname != "m5l2a" && level.mapname != "m5l2b" && level.mapname != "m5l3")
{
	local.master aliascache king_snd_move sound/vehicle/veh_tank_turret1.wav soundparms .9 .2 .9 .2 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_run sound/vehicle/veh_tank_run1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
}

if(level.tankscriptmaster2 != 1 && level.mapname != "m5l1a" && level.mapname != "m5l1b" && level.mapname != "m5l2a" && level.mapname != "m5l2b" && level.mapname != "m5l3")
{
	local.master aliascache tank_vehicle_crash1 sound/null.wav soundparms .7 .4 1 .5 160 1600 auto loaded maps level.mapname
	local.master aliascache damage_tank1 sound/null.wav soundparms .7 .4 .9 .2 160 1600 auto loaded maps level.mapname
}

if(level.tankscriptmaster2 != 1 && level.mapname != "m1l3a" && level.mapname != "m1l3b" && level.mapname != "m3l3" && level.mapname != "m4l2" && level.mapname != "m5l1a" && level.mapname != "m5l1b" && level.mapname != "m5l2a" && level.mapname != "m5l2b" && level.mapname != "m5l3" && level.mapname != "m6l3c")
{
	local.master aliascache explode_tank4 sound/weapons/explo/Explo_MetalMed4.wav soundparms .9 .2 .8 .2 1500 9000 weapon loaded maps level.mapname

	if(level.mapname != "m4l3" && level.mapname[3] != "/")
	{
		local.master aliascache explode_tank3 sound/weapons/explo/Explo_MetalMed3.wav soundparms .9 .2 .8 .2 1500 9000 weapon loaded maps level.mapname
	}

	if(level.mapname != "m1l2b" && level.mapname[3] != "/")
	{
		local.master aliascache explode_tank2 sound/weapons/explo/Explo_MetalMed2.wav soundparms .9 .2 .8 .2 1500 9000 weapon loaded maps level.mapname
	}

	if(level.mapname != "m1l2b" && level.mapname != "m4l3" && level.mapname != "m6l1c" && level.mapname != "training")
	{
		local.master aliascache explode_tank1 sound/weapons/explo/Explo_MetalMed1.wav soundparms .9 .2 .8 .2 1500 9000 weapon loaded maps level.mapname
	}
}

if(level.tankscriptmaster2 != 1 && level.mapname == "training" || level.mapname[2] == "/" || level.mapname[3] == "/")
{
	local.master aliascache tank_snd_doorclose sound/mechanics/DoorHatchClose_02.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
}
if(level.tankscriptmaster2 != 1 && level.mapname[2] == "/" || level.mapname[3] == "/")
{
	local.master aliascache tank_snd_dooropen sound/mechanics/DoorHatchClose_02.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
}

if(level.tankscriptmaster2 != 1)
{
	local.master aliascache tankfire30cal sound/weapons/fire/50CalFire2.wav soundparms 1.05 .2 .95 .1 800 4000 weapon loaded maps level.mapname
}
if(level.scriptmaster_sndmove != 1)
{
	local.master aliascache snd_move sound/null.wav soundparms .4 .2 .9 .2 160 1600 auto loaded maps level.mapname
}
level.scriptmaster_sndmove = 1
level.tankscriptmaster2 = 1
end
