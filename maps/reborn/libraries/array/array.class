/**
 Medal of Honor: Allied Assault v1.12 REBORN
 ================================================================
 GAME.SYSTEM.ARRAY CLASS;
 ================================================================
 BY Sor
 VERSION 1.5.0
 =-------------------------------------------------------------=		
 Copyright (c) 2008-2014  Lenny Knockx
 All rights reserved.
 =-------------------------------------------------------------=
 Permission to use, copy, modify, and/or distribute this software 
 for any purpose with or without fee is hereby granted, provided 
 that the above copyright notice and this permission notice appear
 in all copies.
 ---------------
 THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL 
 WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED 
 WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL 
 THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR 
 CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
 LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, 
 NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR 
 IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 =-------------------------------------------------------------=
 CONTACT: 	http://www.x-null.net/forums/member.php?185-Sor
 WEBSITE: 	http://www.x-null.net
 ================================================================
*/
// argument that supplies an optional lower and upper index bounds?
__init:
	if !(self && self.objectType == game.System.Object.CLASS) {
		end;
	}
	
	//<functions>
	self.GetType = 				self.path::GetType;
	self.GetDepth =				self.path::GetDepth;
	self.GetBounds = 			self.path::GetBounds;
	self.GetLowerBound = 		self.path::GetLowerBound;
	self.GetUpperBound = 		self.path::GetUpperBound;
	self.IsConstant = 			self.path::IsConstantArray;
	self.IsMutable = 			self.path::IsMutableArray;
	self.IsAssociative = 		self.path::IsAssociativeArray;
	self.IsEntityArray = 		self.path::IsEntityArray;
	self.IsComposite = 			self.path::IsCompositeType;
	self.IsArray = 				self.path::IsArray;
	self.IsIndexed = 			self.path::IsIndexed;
	self.IsMultiDimensional = 	self.path::IsMultiDimensional;
	self.IsConcatenated = 		self.path::IsConcatenated;
	self.New = 					self.path::New;
	self.Convert = 				self.path::Convert;
	self.Copy = 				self.path::Copy;
	self.Serialize = 			self.path::Serialize;
	self.Deserialize = 			self.path::Deserialize;
	self.Print = 				self.path::Print;
	self.Stringify = 			self.path::Stringify;
	self.Equals =				self.path::Equals;
	self.Push = 				self.path::Push;
	self.Pop = 					self.path::Pop;
	self.Unshift =				self.path::Unshift;
	self.Shift = 				self.path::Shift;
	self.Splice = 				self.path::Splice;
	self.Reconcatenate = 		self.path::Reconcatenate;
	self.Concatenate = 			self.path::Concatenate;
	self.Merge = 				self.path::Merge;
	self.Shuffle = 				self.path::Shuffle;
	self.Reverse = 				self.path::Reverse;
	self.ForEach = 				self.path::ForEach;
	self.Filter = 				self.path::Filter;
	self.Map = 					self.path::Map;
	self.Every = 				self.path::Every;
	self.Some = 				self.path::Some;
	self.Sort =					self.path::Sort;
	self.QuickSort = 			self.path::QuickSort;
	self.IndexOf = 				self.path::IndexOf;
	self.LastIndexOf = 			self.path::LastIndexOf;
	self.Search = 				self.path::Search;
	//</functions>
	
	//<properties>
	self.sparsityFactor = 		4;
	//</properties>
	
	self.initialized = 1; // init complete!
end;

__meta:
	self.author = "Sor";
	self.version = 1.5;
end;

/**
 arrayType GetType(<array> array)
 =================================================================
 OVERVIEW|: Examines the array and returns a value that corresponds with 
			an $ArrayType constant.
 RETURN	 |: <arrayType>; 
			or NIL upon failure.
*/
GetType local.array:
	switch (typeof(local.array)) {
		case "vector":
		case "string":
		case "const string":
			local.result = game.System.Array.ArrayType.COMPOSITE;
		break;
		case "const array":
			local.result = game.System.Array.ArrayType.CONSTANT;
		break;
		case "array":
			local.result = game.System.Array.ArrayType.MUTABLE;
			local.lb = waitthread GetLowerBound local.array;
			
			// Special cases..
			if (local.lb == NIL && local.array.size != 0) {
				local.result = game.System.Array.ArrayType.ASSOCIATIVE;
			} 
			else if (local.lb == 1 && (waitthread IsEntityArray local.array)) {
				local.result = game.System.Array.ArrayType.ENTITY;
			}
		break;
		default:
			if (level.DEBUG) {
				conprintf ("~^~^~^~ ERROR[System.Array.GetType()]: specified array (arg1) is of an invalid type ('" + typeof(local.array) + "')! ~^~^~^~ \n");
			}
		break;
	}
end local.result;

/**
 array[1] GetDepth(<array> array)
 =================================================================
 OVERVIEW|: Scans array to determine how many dimensions deep it is and  
			returns the minimum and maximum recorded dimension depth.
 RETURN	 |: constant array with two <int> =>	[1] = minimum depth;
												[2] = maximum depth;
			or NIL upon failure.
*/
GetDepth local.array:
	switch(typeof(local.array)) {
		case "vector":
		case "string":
		case "const string":
			local.depth = 1::1;
		break;
		case "const array":
		case "array":
			group.depth = 0;
			group.max_depth = 0;
			group.min_depth = game.System.Maths.Int.MAX_VALUE;
			
			waitthread __GetDepth local.array;
			local.depth = group.min_depth::group.max_depth;
			
			group.depth = NIL;
			group.max_depth = NIL;
			group.min_depth = NIL;
		break;
		default:
			if (level.DEBUG) {
				conprintf ("~^~^~^~ ERROR[System.Array.GetDepth()]: specified array (arg1) is of an invalid type '" + typeof(local.array) + "'! ~^~^~^~ \n");
			}
		break;
	}
end local.depth;

__GetDepth local.array:
	group.depth++;
	local.bounds = waitthread GetBounds local.array;
	if (!local.bounds) {
		end; 
	}
	
	for (local.i = local.bounds[1]; local.i <= local.bounds[2]; local.i++) {
		if (waitthread IsArray local.array[local.i]) {
			waitthread __GetDepth local.array[local.i];
		} 
		else if (local.array[local.i] != NIL) 
		{
			if (group.max_depth < group.depth) {
				group.max_depth = group.depth;
			} 
			if (group.depth < group.min_depth) {
				group.min_depth = group.depth;
			}
		}
	}
	group.depth--;
end;

/**
 bool IsConstantArray(<type> var)
 =================================================================
 OVERVIEW|: Determines whether the specified argument is a Constant array.
 RETURN	 |: <bool>
*/
IsConstantArray local.array:
	if (typeof(local.array) == "const array") {
		end 1;
	}
end 0;

/**
 bool IsMutableArray(<type> var)
 =================================================================
 OVERVIEW|: Determines whether the specified argument is a Mutable array.
 RETURN	 |: <bool>
*/
IsMutableArray local.array:
	if ((typeof local.array)[0] == "a") {
		local.lb = waitthread GetLowerBound local.array;
		
		if (local.lb == NIL && local.array.size != 0) {
			end 0; // ASSOCIATIVE
		} 
		else if (local.lb == 1 && (waitthread IsEntityArray local.array)) {
			end 0; // ENTITY
		}
	} else {
		end 0;
	}
end 1;

/**
 bool IsAssociativeArray(<type> var)
 =================================================================
 OVERVIEW|: Determines whether the specified argument is an Associative array.
 RETURN	 |: <bool>
*/
IsAssociativeArray local.array:
	if ((typeof local.array)[0] == "a" && local.array.size != 0) {
		if ((waitthread GetLowerBound local.array) == NIL) {
			end 1;
		}
	}
end 0;

/**
 bool IsEntityArray(<type> var)
 =================================================================
 OVERVIEW|: Determines whether the specified argument is an Entity array;
			also known as a 'Targetname array'.
 RETURN	 |: <bool>
*/
IsEntityArray local.array:
	if ((typeof local.array)[0] != "a") {
		end 0;
	}
	if ((typeof local.array[1])[0] != "l") {
		end 0;
	}
	
	local.entArr = $(local.array[1].targetname);
	
	if ((typeof local.entArr)[0] != "a" || local.entArr.size != local.array.size) {
		end 0;
	}
	
	local.arrSize = local.array.size;
	local.cnt = 0;
	
	for (local.i = 1; local.i <= local.arrSize; local.i++) {
		if (local.entArr[local.i] != local.array[local.i]) {
			end 0;
		}
	}
end 1;

/**
 bool IsCompositeType(<type> var)
 =================================================================
 OVERVIEW|: Determines whether the specified argument is a non-array type
			where its individual elements can be accessed like an array.
			Like a string or vector, for instance.
 RETURN	 |: <bool>
*/
IsCompositeType local.array:
	switch(typeof(local.array)) {
		case "vector":
		case "string":
		case "const string":
			local.result = 1;
		break;
		default:
			local.result = 0;
		break;
	}
end local.result; 

/**
 bool IsArray(<type> var)
 =================================================================
 OVERVIEW|: Determines whether the specified variable of type 'array'
			or 'const array'.
 RETURN	 |: <bool>
*/
IsArray local.array:
	local.type = typeof(local.array);
end (local.type[local.type.size-1] == "y");

/**
 bool IsIndexed(<type> var)
 =================================================================
 OVERVIEW|: Determines whether the specified variable is a type of which 
			its elements are accessible by index (like array, vector...).
 RETURN	 |: <bool>
*/
IsIndexed local.array:
	local.type = typeof(local.array);
	switch(local.type[local.type.size-1]) {
		case "y": // 'array', 'const array'
		case "g": // 'string', 'const string'
			end 1;
		default:
			if (local.type[0] == "v") {
				end 1;
			}
		break;
	}
end 0;

/**
 bool IsMultiDimensional(<array> array)
 =================================================================
 OVERVIEW|: Determines whether the specified variable is an array that 
			contains other arrays (or 'dimensions'). 
 RETURN	 |: <bool>
*/
IsMultiDimensional local.array:
	if !(waitthread IsArray local.array) {
		end 0;
	}
	
	local.bounds = waitthread GetBounds local.array;
	if (!local.bounds) {
		end 0;
	}
		
	for (local.i = local.bounds[1]; local.i <= local.bounds[2]; local.i++) {
		if (waitthread IsArray local.array[local.i]) {
			end 1;
		}
	}
end 0;

/**
 bool IsConcatenated(<array> array, [<bool> allDimensions])
 =================================================================
 OVERVIEW|: Determines whether the specified array contains no 
			unassigned elements when iterating from its lower bound 
			up to its upper bound. 
			Optionally, all dimensions can be checked instead of 
			only the first.
 RETURN	 |: <bool>
*/
IsConcatenated local.array local.allDimensions:
	if !(waitthread IsArray local.array) {
		end 1;
	}

	if (local.allDimensions) {
		group.returnThread = local;
		end (waitthread __IsConcatenated local.array);
	}
end (waitthread _IsConcatenated local.array (waitthread GetBounds local.array));

_IsConcatenated local.array local.bounds:
	if (!local.bounds) {
		end 0; 
	}
	if ((local.bounds[2] - local.bounds[1] + 1) != local.array.size) {
		end 0;
	}
end 1;

__IsConcatenated local.array:
	local.bounds = waitthread GetBounds local.array;
	if !(waitthread _IsConcatenated local.array local.bounds) {
		group.returnThread end 0; // ends user-called thread and the threads it called
	}
	
	for (local.i = local.bounds[1]; local.i <= local.bounds[2]; local.i++) {
		if (waitthread IsArray local.array[local.i]) {
			waitthread __IsConcatenated local.array[local.i];
		}
	}
end 1;

/**
 array[] New()
 =================================================================
 OVERVIEW|: Returns an empty, mutable array.
 RETURN	 |: <array>
*/
New:
	// The following instruction initializes local.arr as type 'array' and has 
	// a .size of 0 elements (as opposed to -1 if it were still nonexistent).
	local.arr[0] = NIL;
end local.arr;

/**
 void Shuffle(<array> array)
 =================================================================
 OVERVIEW|: Randomly shuffles the order of the elements in the 
			specified array.
 RETURN	 |: NIL;
*/
Shuffle local.array:
	if (level.DEBUG) {
		if (waitthread IsAssociativeArray local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Shuffle()]: shuffling the order of elements of an associative array is absurd! ~^~^~^~ \n");
			end;
		} if (waitthread IsEntityArray local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Shuffle()]: shuffling the order of elements of an entity array is not supported! ~^~^~^~ \n");
			end;
		}
	}
	
	local.bounds = waitthread GetBounds local.array;
	if (!local.bounds) {
		end;
	}
	
	for (local.i = local.bounds[2]; local.bounds[1] <= local.i; local.i--) {
		local.swapIdx = randomint(abs(local.i)) + local.bounds[1];
		local.tmp = local.array[local.i];
		local.array[local.i] = local.array[local.swapIdx];
		local.array[local.swapIdx] = local.tmp;
	}
end;

/**
 void Reverse(<array> array)
 =================================================================
 OVERVIEW|: Reverses the order of the elements in the specified array.
 RETURN	 |: NIL;
*/
Reverse local.array:
	if (level.DEBUG) {
		if (waitthread IsAssociativeArray local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Reverse()]: reversing the order of elements of an associative array is absurd! ~^~^~^~ \n");
			end;
		} if (waitthread IsEntityArray local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Reverse()]: reversing the order of elements of an entity array is not supported! ~^~^~^~ \n");
			end;
		}
	}
	
	local.bounds = waitthread GetBounds local.array;
	if (!local.bounds) {
		end;
	}
	
	local.j = local.bounds[2];
	for (local.i = local.bounds[1]; local.i < local.j; local.i++) {
		local.temp = local.array[local.i];
		local.array[local.i] = local.array[local.j];
		local.array[local.j] = local.temp;
		local.j--;
	}
end;

/**
 void Reconcatenate(<array> array)
 =================================================================
 OVERVIEW|: Reconcatenates specified mutable array by removing  
			intermittent empty elements, while still retaining  
			the relative order of the other elements.
 RETURN	 |: NIL;
*/
Reconcatenate local.array:
	if (level.DEBUG) {
		if !(waitthread IsArray local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Reconcatenate()]: specified array (arg1) is invalid! ~^~^~^~ \n");
			end;
		}
	}
	waitthread __Reconcatenate local.array;
end;

__Reconcatenate local.array:
	local.bounds = waitthread GetBounds local.array;
	if (!local.bounds) { 
		end;
	}
	if ((local.bounds[2] - local.bounds[1] + 1) == local.array.size) {
		end; // already concatenated or is constant
	}
	
	local.j = local.bounds[1];
	for (local.i = local.bounds[1]; local.i <= local.bounds[2]; local.i++) {
		if (local.array[local.i] == NIL) {
			// Get next non-empty element.
			for (local.j = local.i + 1; local.j <= local.bounds[2]; local.j++) {
				if (local.array[local.j] != NIL) {
					break;
				}
			}
			
			// Switch positions...
			if (local.j <= local.bounds[2]) {
				local.array[local.i] = local.array[local.j];
				local.array[local.j] = NIL;
				
			}
		} 
		if (waitthread IsArray local.array[local.i]) {
			waitthread __Reconcatenate local.array[local.i];
		}
		
		// Either the last element has been handled or all empty elements have been moved 
		// to the back of the array. In any case, we can end our algorithm prematurely now.
		if (local.bounds[2] <= local.j) {
			break;
		}
	}
end;

/**
 array[] Merge([<int> index], <array> array1, <array> array2,
			   [<array> array3], [<array> array4], [<array> array5])
 =================================================================
 OVERVIEW|: Merges two or more arrays by moving their elements into
			a single, concatenated array.
			Optionally, you can specify the starting index which the
			new array should use (default: 1).
 RETURN	 |: <array>;
			or NIL upon failure.

 NOTE 1	 |: Only elements assigned with a value are copied.
	  2	 |: Elements are moved, thus the input arrays become empty.
	  3  |: Input arrays are merged such that elements from one
			are appended to the previous one.
*/
Merge local.index local.array1 local.array2 local.array3 local.array4 local.array5:
	local.arrays[0] = NIL;
	if (waitthread IsArray local.array1) {
		local.arrays[local.arrays.size] = local.array1;
		
		if (waitthread IsArray local.array2) {
			local.arrays[local.arrays.size] = local.array2;
			
			if (waitthread IsArray local.array3) {
				local.arrays[local.arrays.size] = local.array3;
				
				if (waitthread IsArray local.array4) {
					local.arrays[local.arrays.size] = local.array4;
					
					if (waitthread IsArray local.array5) {
						local.arrays[local.arrays.size] = local.array5;
					}
				}
			}
		} 
	}
	
	local.arrSize = local.arrays.size;
	
	if (local.arrSize < 2) {
		if (level.DEBUG) {
			conprintf ("~^~^~^~ ERROR[System.Array.Merge()]: At least two arrays are needed! ~^~^~^~ \n");
		}
		end;
	}
	
	if ((typeof local.index)[0] != "i") {
		local.index = 1;
	}
	
	local.result[0] = NIL;
	for (local.i = 0; local.i < local.arrSize; local.i++) {
		local.bounds = waitthread GetBounds local.arrays[local.i];
		if (!local.bounds) {
			continue;
		}
		
		for (local.j = local.bounds[1]; local.j <= local.bounds[2]; local.j++) {
			if (local.arrays[local.i][local.j] == NIL) {
				continue;
			}
			local.result[local.index] = local.arrays[local.i][local.j];
			local.arrays[local.i][local.j] = NIL;
			local.index++;
		}
	}
end local.result;

/**
 array[] Concatenate([<int> index], <array> array1, <array> array2,
			   [<array> array3], [<array> array4], [<array> array5])
 =================================================================
 OVERVIEW|: Merges two or more arrays by copying their elements into
			a single, concatenated array.
			Optionally, you can specify the starting index which the
			new array should use (default: 1).
 RETURN	 |: <array>;
			or NIL upon failure.

 NOTE 1	 |: Only elements assigned with a value are copied.
	  2	 |: Input arrays are not altered in any way.
	  3  |: Input arrays are merged such that elements from one
			are appended to the previous one.
*/
Concatenate local.index local.array1 local.array2 local.array3 local.array4 local.array5:
	local.arrays[0] = NIL;
	if (waitthread IsArray local.array1) {
		local.arrays[local.arrays.size] = local.array1;
		
		if (waitthread IsArray local.array2) {
			local.arrays[local.arrays.size] = local.array2;
			
			if (waitthread IsArray local.array3) {
				local.arrays[local.arrays.size] = local.array3;
				
				if (waitthread IsArray local.array4) {
					local.arrays[local.arrays.size] = local.array4;
					
					if (waitthread IsArray local.array5) {
						local.arrays[local.arrays.size] = local.array5;
					}
				}
			}
		} 
	}
	
	local.arrSize = local.arrays.size;
	
	if (local.arrSize < 2) {
		if (level.DEBUG) {
			conprintf ("~^~^~^~ ERROR[System.Array.Concatenate()]: At least two arrays are needed! ~^~^~^~ \n");
		}
		end;
	}
	
	if ((typeof local.index)[0] != "i") {
		local.index = 1;
	}
	
	local.result[0] = NIL;
	for (local.i = 0; local.i < local.arrSize; local.i++) {
		local.bounds = waitthread GetBounds local.arrays[local.i];
		if (!local.bounds) {
			continue;
		}
		
		for (local.j = local.bounds[1]; local.j <= local.bounds[2]; local.j++) {
			if (local.arrays[local.i][local.j] == NIL) {
				continue;
			}
			local.result[local.index] = local.arrays[local.i][local.j];
			local.index++;
		}
	}
end local.result;

/**
 array[1] Convert(<array> array)
 =================================================================
 OVERVIEW|: Converts specified Composite or Constant array to a Mutable array.
 RETURN	 |: <array>;
			or NIL upon failure;
*/
Convert local.array:
	if (level.DEBUG) {
		if !(waitthread IsIndexed local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Convert()]: specified array (arg1) is invalid! ~^~^~^~ \n");
			end;
		}
	}
	if (typeof(local.array) == "array") {
		end local.array;
	}
	
	local.result[1] = NIL; // Initialize array
	waitthread __Convert local.array local.result;
end local.result;

__Convert local.array local.result:
	local.bounds = waitthread GetBounds local.array;
	if (!local.bounds) { 
		end;
	}
	
	for (local.i = local.bounds[1]; local.i <= local.bounds[2]; local.i++) {
		if (waitthread IsArray local.array[local.i]) {
			local.result[local.i][1] = NIL; // Initialize array
			waitthread __Convert local.array[local.i] local.result[local.i]
		} 
		else {
			local.result[local.i] = local.array[local.i];
		}
	}
end;

/**
 void ForEach([<self>], <array> array, <array:string> callbackThread)
 =================================================================
 OVERVIEW|: Executes the provided callback thread once for each  
			element, in order, (in each dimension) of the specified  
			array with an assigned value.
 RETURN	 |: NIL;
 
 NOTE 1	 |: Arguments for the callback threads are the element's 
			value, index and array being traversed (respectively).
	  2	 |: If an entity initiated the call to this function, then
			it will be 'self' in the callback thread.
*/
ForEach local.array group.callback:
	if (level.DEBUG) {
		if !(waitthread IsIndexed local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.ForEach()]: specified array (arg1) is invalid! ~^~^~^~ \n");
			end;
		}
		if !(group.callback) {
			conprintf ("~^~^~^~ ERROR[System.Array.ForEach()]: specified callback thread (arg2) is invalid! ~^~^~^~ \n");
			end;
		}
	}

	/*self*/ waitthread __ForEach local.array;
	group.callback = NIL;
end;

__ForEach local.array:
	local.bounds = waitthread GetBounds local.array;
	if (!local.bounds) { // empty or associative array
		end;
	}
	
	for (local.i = local.bounds[1]; local.i <= local.bounds[2]; local.i++) {
		if (waitthread IsArray local.array[local.i]) {
			/*self*/ waitthread __ForEach local.array[local.i];
		} 
		else if (local.array[local.i] != NIL) {
			/*self*/ waitthread group.callback local.array[local.i] local.i local.array;
		}
	}
end;

/**
 void Filter([<self>], <array> array, <array:string> callbackThread, 
			 [<int> index])
 =================================================================
 OVERVIEW|: Executes the provided callback thread once for each  
			element, in order, (in each dimension) of the specified  
			array with an assigned value and constructs a new array 
			of all the values for which a true value is returned.
			Optionally, a starting index for the filtered array may
			be specified (default: 1).
 RETURN	 |: NIL;
 
 NOTE 1	 |: Arguments for the callback threads are the element's 
			value, index and array being traversed (respectively).
	  2	 |: If an entity initiated the call to this function, then
			it will be 'self' in the callback thread.
*/
Filter local.array group.callback group.index:
	if (level.DEBUG) {
		if !(waitthread IsIndexed local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Filter()]: specified array (arg1) is invalid! ~^~^~^~ \n");
			end;
		}
		if !(group.callback) {
			conprintf ("~^~^~^~ ERROR[System.Array.Filter()]: specified callback thread (arg2) is invalid! ~^~^~^~ \n");
			end;
		}
	}
	
	if ((typeof group.index)[0] != "i") {
		group.index = 1;
	}
	
	group.result[0] = NIL;
	
	/*self*/ waitthread __Filter local.array;
	group.callback = NIL;
	group.index = NIL;
end group.result;

__Filter local.array:
	local.bounds = waitthread GetBounds local.array;
	if (!local.bounds) { // empty or associative array
		end;
	}
	
	for (local.i = local.bounds[1]; local.i <= local.bounds[2]; local.i++) {
		if (waitthread IsArray local.array[local.i]) {
			/*self*/ waitthread __Filter local.array[local.i];
		} 
		else if (local.array[local.i] != NIL) {
			if (/*self*/ waitthread group.callback local.array[local.i] local.i local.array) {
				group.result[group.index] = local.array[local.i];
				group.index++;
			}
		}
	}
end;

/**
 void Map([<self>], <array> array, <array:string> callbackThread,
		  [<int> index])
 =================================================================
 OVERVIEW|: Executes the provided callback thread once for each  
			element, in order, (in each dimension) of the specified  
			array with an assigned value and constructs a new array 
			from the results.
			Optionally, a starting index for the new array may be
			specified (default: 1).
 RETURN	 |: NIL;
 
 NOTE 1	 |: Arguments for the callback threads are the element's 
			value, index and array being traversed (respectively).
	  2	 |: If an entity initiated the call to this function, then
			it will be 'self' in the callback thread.
*/
Map local.array group.callback group.index:
	if (level.DEBUG) {
		if !(waitthread IsIndexed local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Map()]: specified array (arg1) is invalid! ~^~^~^~ \n");
			end;
		}
		if !(group.callback) {
			conprintf ("~^~^~^~ ERROR[System.Array.Map()]: specified callback thread (arg2) is invalid! ~^~^~^~ \n");
			end;
		}
	}
	
	if ((typeof group.index)[0] != "i") {
		group.index = 1;
	}
	
	group.result[0] = NIL;
	
	/*self*/ waitthread __Map local.array;
	group.callback = NIL;
	group.index = NIL;
end group.result;

__Map local.array:
	local.bounds = waitthread GetBounds local.array;
	if (!local.bounds) { // empty or associative array
		end;
	}
	
	for (local.i = local.bounds[1]; local.i <= local.bounds[2]; local.i++) {
		if (waitthread IsArray local.array[local.i]) {
			/*self*/ waitthread __Map local.array[local.i];
		} 
		else if (local.array[local.i] != NIL) {
			group.result[group.index] = /*self*/ waitthread group.callback local.array[local.i] local.i local.array;
			group.index++;
		}
	}
end;

/**
 bool Every([<self>], <array> array, <array:string> callbackThread)
 =================================================================
 OVERVIEW|: Executes the provided callback thread once for each  
			element, in order, (in each dimension) of the specified  
			array with an assigned value and returns false as soon
			as the callback returns a false value.
 RETURN	 |: <bool>;
			or NIL upon failure.
			
 NOTE	 |: If an entity initiated the call to this function, then
			it will be 'self' in the callback thread.
*/
Every local.array group.callback:
	if (level.DEBUG) {
		if !(waitthread IsIndexed local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Every()]: specified array (arg1) is invalid! ~^~^~^~ \n");
			end;
		}
		if !(group.callback) {
			conprintf ("~^~^~^~ ERROR[System.Array.Every()]: specified callback thread (arg2) is invalid! ~^~^~^~ \n");
			end;
		}
	}
	
	group.returnThread = local;
	waitthread __Every local.array;
end 1;

__Every local.array:
	local.bounds = waitthread GetBounds local.array;
	if (!local.bounds) { // empty or associative array
		end;
	}
	
	for (local.i = local.bounds[1]; local.i <= local.bounds[2]; local.i++) {
		if (waitthread IsArray local.array[local.i]) {
			/*self*/ waitthread __Every local.array[local.i];
		} 
		else if (local.array[local.i] != NIL) {
			if !(/*self*/ waitthread group.callback local.array[local.i] local.i local.array) {
				group.returnThread end 0;
			}
		}
	}
end;

/**
 bool Some([<self>], <array> array, <array:string> callbackThread)
 =================================================================
 OVERVIEW|: Executes the provided callback thread once for each  
			element, in order, (in each dimension) of the specified  
			array with an assigned value and returns true as soon
			as the callback returns a true value.
 RETURN	 |: <bool>;
			or NIL upon failure.
			
 NOTE	 |: If an entity initiated the call to this function, then
			it will be 'self' in the callback thread.
*/
Some local.array group.callback:
	if (level.DEBUG) {
		if !(waitthread IsIndexed local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Some()]: specified array (arg1) is invalid! ~^~^~^~ \n");
			end;
		}
		if !(group.callback) {
			conprintf ("~^~^~^~ ERROR[System.Array.Some()]: specified callback thread (arg2) is invalid! ~^~^~^~ \n");
			end;
		}
	}
	
	group.returnThread = local;
	waitthread __Some local.array;
end 0;

__Some local.array:
	local.bounds = waitthread GetBounds local.array;
	if (!local.bounds) { // empty or associative array
		end;
	}
	
	for (local.i = local.bounds[1]; local.i <= local.bounds[2]; local.i++) {
		if (waitthread IsArray local.array[local.i]) {
			/*self*/ waitthread __Every local.array[local.i];
		} 
		else if (local.array[local.i] != NIL) {
			if (/*self*/ waitthread group.callback local.array[local.i] local.i local.array) {
				group.returnThread end 1;
			}
		}
	}
end;

/**
 int IndexOf(<array> array, <type> value, [<int> index], 
			 [<bool> compareMode], [<bool> strict])
 =================================================================
 OVERVIEW|: Finds the first element in the specified array that 
			corresponds with the specified value in either value 
			or type and returns its index in the array.
			An index to start searching from can be specified.
			
 INPUT 	 |: If 'compareMode' is false (default), the function will 
			compare by value; otherwise if true, by type.
			
			If 'strict' is false (default), the comparison only 
			requires equal values or compatible types; otherwise if 
			true, equal values must have equal types and likewise
			types must be equal as well.
			
 RETURN	 |: <int>;
			or NIL when nothing was found.
*/
IndexOf local.array local.var local.index group.compare group.strict:
	if (level.DEBUG) {
		if !(waitthread IsIndexed local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.IndexOf()]: specified array (arg1) is invalid! ~^~^~^~ \n");
			end;
		}
	}
	
	if ((typeof local.index)[0] != "i") {
		local.bounds = waitthread GetBounds local.array;
	} else {
		local.upper = waitthread GetUpperBound local.array;
		if (local.upper != NIL && local.index <= local.upper) {
			local.bounds = local.index::local.upper
			local.upper = NIL;
		}
	}
	
	if (!local.bounds) {
		end;
	}
	
	for (local.i = local.bounds[1]; local.i <= local.bounds[2]; local.i++) {
		if (waitthread __Is local.array[local.i] local.var) {
			end local.i;
		}
	}
end;

/**
 int LastIndexOf(<array> array, <type> value, [<int> index], 
			 [<bool> compareMode], [<bool> strict])
 =================================================================
 OVERVIEW|: Finds the last element in the specified array that 
			corresponds with the specified value in either value 
			or type and returns its index in the array.
			An index to start searching from can be specified.
			
 INPUT 	 |: If 'compareMode' is false (default), the function will 
			compare by value; otherwise if true, by type.
			
			If 'strict' is false (default), the comparison only 
			requires equal values or compatible types; otherwise if 
			true, equal values must have equal types and likewise
			types must be equal as well.
			
 RETURN	 |: <int>;
			or NIL when nothing was found.
*/
LastIndexOf local.array local.var local.index group.compare group.strict:
	if (level.DEBUG) {
		if !(waitthread IsIndexed local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.LastIndexOf()]: specified array (arg1) is invalid! ~^~^~^~ \n");
			end;
		}
	}
	
	if ((typeof local.index)[0] != "i") {
		local.bounds = waitthread GetBounds local.array;
	} else {
		local.lower = waitthread GetLowerBound local.array;
		if (local.lower != NIL && local.lower <= local.index) {
			local.bounds = local.lower::local.index;
			local.lower = NIL;
		}
	}
	
	if (!local.bounds) {
		end;
	}
	
	for (local.i = local.bounds[2]; local.bounds[1] <= local.i; local.i--) {
		if (waitthread __Is local.array[local.i] local.var) {
			end local.i;
		}
	}
end;

/**
 int Search(<array> array, <type> value, [<bool> compareMode], 
			[<bool> strict])
 =================================================================
 OVERVIEW|: Finds the all elements (in each dimension) in the 
			specified array that correspond with the specified value 
			in either value or type and returns an array of tuples 
			index and its array for each found element.
			
 INPUT 	 |: If 'compareMode' is false (default), the function will 
			compare by value; otherwise if true, by type.
			
			If 'strict' is false (default), the comparison only 
			requires equal values or compatible types; otherwise if 
			true, equal values must have equal types and likewise
			types must be equal as well.
			
 RETURN	 |: <array>	->	[X] ->  [1] = index of found element;
								[2] = array it was found in;
			or NIL when nothing was found.
 NOTE	 |: Unlike other functions, arrays in arrays are also
			considered 'elements'.
*/
Search local.array group.var group.compare group.strict:
	if (level.DEBUG) {
		if !(waitthread IsIndexed local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Search()]: specified array (arg1) is invalid! ~^~^~^~ \n");
			end;
		}
	}
	
	group.i = 1;
	group.result[0] = NIL;
	waitthread __Search local.array;
	
	//group.i = NIL;
	//group.compare = NIL;
	//group.strict = NIL;
end group.result;

__Search local.array:
	local.bounds = waitthread GetBounds local.array;
	if (!local.bounds) {
		end;
	}
	
	for (local.i = local.bounds[1]; local.i <= local.bounds[2]; local.i++) {
		if (waitthread IsArray local.array[local.i]) {
			waitthread __Search local.array[local.i];
		}
		if (waitthread __Is local.array[local.i] group.var) {
			group.result[group.i][1] = local.i;
			group.result[group.i][2] = local.array;
			group.i++;
		}
	}
end;

__Is local.elem1 local.elem2:
	if (!group.compare) {
		if (!group.strict) {
			end (local.elem1 == local.elem2);
		}
		end (local.elem1 == local.elem2 && typeof(local.elem1) == typeof(local.elem2));
	} else if (group.strict) {
		end (typeof(local.elem1) == typeof(local.elem2));
	}
end (waitthread game.System.Common.AreTypesCompatible local.elem1 local.elem2);


/**
 void QuickSort(<array> array, [<bool> descending], [<array:string compareThread])
 =================================================================
 OVERVIEW|: Quickly sorts the specified array in ascending order.
			Alternatively, the array can be sorted in descending
			order. 
			Number arrays and string arrays are handled by default.
			To sort other datatypes or to sort with other criteria, 
			you can specify a compare thread the function will use.
 RETURN	 |: NIL;
 
 NOTE 1	 |: If a custom comparison thread is specified, it must 
			return -1 if the first argument is smaller than the
			second; 1 if the first argument is larger or 0 in 
			case they are equal.
	  2	 |: This function uses a custom QuickSort implementation 
			where InsertionSort is used to further sort small 
			enough partitions. And as such, it is best used for 
			larger arrays.
*/
QuickSort group.array local.descending group.compareThread:
	if (level.DEBUG) {
		if !(waitthread IsIndexed group.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.QuickSort()]: specified array (arg1) is invalid! ~^~^~^~ \n");
			end;
		}
	}
	
	local.bounds = waitthread GetBounds group.array;
	if (!local.bounds) {
		// error
		end;
	}
	
	if (!group.compareThread) {
		local.type = typeof(group.array[local.bounds[1]]);
		
		if (local.type[local.type.size-1] == "t") {
			group.compareThread = game.System.Maths.Compare;
		} 
		else if (local.type[local.type.size-1] == "g" || local.type[1] == "h") {
			group.compareThread = game.System.String.Compare;
		} 
		else {
			if (level.DEBUG) {
				conprintf ("~^~^~^~ ERROR[System.Array.QuickSort()]: cannot sort '" + local.type + "' elements without a user-specified compareThread! ~^~^~^~ \n");
			}
			end;
		}
		
		local.type = NIL;
	}
	
	if (local.descending) {
		group.smallerThan = 1;
		group.greaterThan = -1;
	} else {
		group.smallerThan = -1;
		group.greaterThan = 1;
	}

	waitthread __QuickSort local.bounds[1] local.bounds[2];
end;

__QuickSort local.lower local.upper:
	// InsertionSort the small partitions:
	if ((local.upper - local.lower) < 9) {
		waitthread __InsertionSort group.array local.lower local.upper;
		end;
	}
	
	local.pivot = group.array[int(local.lower + (local.upper - local.lower) / 2)];
	local.left = local.lower;
	local.right = local.upper;
	
	while (local.left <= local.right) {
		if ((waitthread group.compareThread group.array[local.left] local.pivot) == group.smallerThan) {
			local.left++;
			continue;
		}
		if ((waitthread group.compareThread group.array[local.right] local.pivot) == group.greaterThan) {
			local.right--;
			continue;
		}
		
		// Swap entries in place
		if (local.left <= local.right) {
			local.tmp = group.array[local.left];
			group.array[local.left] = group.array[local.right];
			group.array[local.right] = local.tmp;

			local.left++;
			local.right--;
		}
	}
	
	local.tmp = NIL;
	
	// recursive calling
	if (local.left < local.upper) {
		waitthread __QuickSort local.left local.upper;
	} if (local.lower < local.right) {
		waitthread __QuickSort local.lower local.right;
	}
end;

/**
 void Sort(<array> array, [<bool> descending], [<array:string compareThread])
 =================================================================
 OVERVIEW|: Sorts the specified array in ascending order.
			Alternatively, the array can be sorted in descending
			order. 
			Number arrays and string arrays are handled by default.
			To sort other datatypes or to sort with other criteria, 
			you can specify a compare thread the function will use.
 RETURN	 |: NIL;
 
 NOTE 1	 |: If a custom comparison thread is specified, it must 
			return -1 if the first argument is smaller than the
			second; 1 if the first argument is larger or 0 in 
			case they are equal.
	  2	 |: This function uses a InsertionSort to sort the array  
			elements. As such, it is best used for smaller arrays.
*/
Sort local.array local.descending group.compareThread:
	if (level.DEBUG) {
		if !(waitthread IsIndexed local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Sort()]: specified array (arg1) is invalid! ~^~^~^~ \n");
			end;
		}
	}
	
	local.bounds = waitthread GetBounds local.array;
	if (!local.bounds) {
		// error
		end;
	}
	
	if (!group.compareThread) {
		local.type = typeof(local.array[local.bounds[1]]);
		
		if (local.type[local.type.size-1] == "t") {
			group.compareThread = game.System.Maths.Compare;
		} 
		else if (local.type[local.type.size-1] == "g" || local.type[1] == "h") {
			group.compareThread = game.System.String.Compare;
		} 
		else {
			if (level.DEBUG) {
				conprintf ("~^~^~^~ ERROR[System.Array.Sort()]: cannot sort '" + local.type + "' elements without a user-specified compareThread! ~^~^~^~ \n");
			}
			end;
		}
		
		local.type = NIL;
	}
	
	if (local.descending) {
		group.smallerThan = 1;
		group.greaterThan = -1;
	} else {
		group.smallerThan = -1;
		group.greaterThan = 1;
	}

	waitthread __InsertionSort local.array local.bounds[1] local.bounds[2];
end;

/// NOTE: Despite it's time complexity of O(n^2) in the worst case, for smaller arrays 
/// insertion sort is quite fast. This not only saves us a lot of needless recursions 
/// and the associated overhead but it also prevents QuickSort from degrading to its 
/// O(n^2) worst case. In general, insertion sort is simple and effective, making it 
/// great to finish off a quicksort of mergesort recursion branch.
__InsertionSort local.array local.lower local.upper:
	for (local.i = local.lower; local.i <= local.upper; local.i++) {
		local.value = local.array[local.i];
		local.j = local.i - 1;
		while (local.j >= local.lower && (waitthread group.compareThread local.array[local.j] local.value) == group.greaterThan) {
			local.array[(local.j + 1)] = local.array[local.j];
			local.j--;
		}
		local.array[(local.j + 1)] = local.value;
	}
end;

/*__CompareNum local.num local.piv:
	if (local.num < local.piv) {
		end -1;
	} else if (local.piv < local.num) {
		end 1;
	}
end 0;*/

/**
 array[] Copy(<array> array)
 =================================================================
 OVERVIEW|: Copies specified array in its entirety (i.e. each 
			element in each dimension).
 RETURN	 |: <array>;
			or NIL upon failure;
 NOTE	 |: Entities cannot be copied, so NULL-entity is used instead.
*/
Copy local.array:
	if (level.DEBUG) {
		if (waitthread IsAssociativeArray local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Copy()]: copying an associative array is not supported! ~^~^~^~ \n");
			end;
		} if (waitthread IsEntityArray local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Copy()]: copying an entity array is not supported! ~^~^~^~ \n");
			end;
		}
	}
	
	if (waitthread IsArray local.array) {
		local.result[1] = NIL; // initialize new dynamic array
		waitthread __Copy local.array local.result;
	} 
	else {
		local.result = local.array;
	}
end local.result;

__Copy local.array local.result:
	local.bounds = waitthread GetBounds local.array;
	if (!local.bounds) {
		end;
	}
	
	for (local.i = local.bounds[1]; local.i <= local.bounds[2]; local.i++) {
		if (waitthread IsArray local.array[local.i]) {
			local.result[local.i][1] = NIL; // Initialize array
			waitthread __Copy local.array[local.i] local.result[local.i];
		} 
		else {
			if ((typeof local.array[local.i])[0] != "l") {
				local.result[local.i] = local.array[local.i];
			} else {
				local.result[local.i] = NULL; // cannot copy entities
			}
		}
	}
end;

/**
 void Print(<array> array, [<string> prefix], [<bool> printTypeOnly])
 =================================================================
 OVERVIEW|: Prints the value of each element, in order, in each  
			dimension of the specified array.
			A prefix can be specified which will precede each 
			printed element.
			Optionally, the function can print the element's type
			instead of its value.
 RETURN	 |: NIL;
*/
Print local.array local.prefix group.typeOnly:
	if !(waitthread game.System.String.IsString local.prefix) {
		local.prefix = "";
	}
	if (waitthread IsArray local.array) {
			waitthread __Print local.array local.prefix;
	} 
	else {
		if (local.prefix) {
			local.prefix += " = ";
		}
		conprintf(local.prefix + (waitthread game.System.Common.CastToString local.array) + "\n");
	}
	//conprintf("\n");
end;

__Print local.array local.prefix:
	local.bounds = waitthread GetBounds local.array;
	if (!local.bounds) { // associative or empty array
		end;
	}
	
	for (local.i = local.bounds[1]; local.i <= local.bounds[2]; local.i++) {
		if (waitthread IsArray local.array[local.i]) {
			waitthread __Print local.array[local.i] (local.prefix + "[" + local.i + "]");
		}
		else if (!group.typeOnly) {
			conprintf(local.prefix + "[" + local.i + "] = " + (waitthread game.System.Common.CastToString local.array[local.i]) + "\n");
		}
		else {
			conprintf(local.prefix + "[" + local.i + "] = '" + typeof(local.array[local.i]) + "'\n");
		}
	}
end;

/**
 string Stringify(<array> array, [<string> prefix])
 =================================================================
 OVERVIEW|: Stringifies array into MorpheusScript so it can be outputted
			to the console or written to disk.
 RETURN	 |: <string>;
			or NIL upon failure.
*/
Stringify local.array local.prefix:
	if (level.DEBUG) {
		if (waitthread IsAssociativeArray local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Stringify()]: stringifying an associative array is not supported! ~^~^~^~ \n");
			end;
		} if (waitthread IsEntityArray local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Stringify()]: stringifying an entity array is not supported! ~^~^~^~ \n");
			end;
		}
	}

	if !(waitthread game.System.String.IsString local.prefix) {
		local.prefix = "local.arr";
	}
	
	group.result = "";
	if (waitthread IsArray local.array) {
		waitthread __Stringify local.array local.prefix;
	} else {
		group.result = local.prefix + (waitthread game.System.Common.CastToString local.array) + "\n";
	}
end group.result;

__Stringify local.array local.prefix:
	local.bounds = waitthread GetBounds local.array;
	if (!local.bounds) {
		end;
	}
	
	for (local.i = local.bounds[1]; local.i <= local.bounds[2]; local.i++) {
		if (waitthread IsArray local.array[local.i]) {
			waitthread __Stringify local.array[local.i] (local.prefix + "[" + local.i + "]");
		}
		else {
			group.result += (local.prefix + "[" + local.i + "] = " + (waitthread game.System.Common.CastToString local.array[local.i]) + "\n");
		}
	}
end;

/**
 bool Equals(<array> array1, <array> array2, [<bool> strictMode])
 =================================================================
 OVERVIEW|: Compares two given arrays and determines whether they are equal.
			Optionally, if 'strictMode' is true, elements must have equal 
			types, not just equal values.
 RETURN	 |: <bool>;
 
 NOTE 1	 |: By default size, boundaries and element values are checked to  
			determine equality. 
	  2	 |:	Entities are compared by reference; so only references to the
			same entity are considered 'true'.
*/
Equals local.arr1 local.arr2 group.strict:
	group.returnThread = local;
	
	if (waitthread IsArray local.arr1) {
		waitthread __Equals local.arr1 local.arr2;
	}
	else {
		waitthread _Equals local.arr1 local.arr2;
	}

	group.strict = NIL;
end 1;

_Equals local.elem1 local.elem2:
	if (local.elem1 != local.elem2) {
		group.returnThread end 0;
	}
	if (group.strict) {
		if (typeof(local.elem1) != typeof(local.elem2)) {
			group.returnThread end 0;
		}
	}
end;

__Equals local.arr1 local.arr2:
	if !(waitthread IsArray local.arr2) { // one is an array but the other is not
		group.returnThread end 0;
	}
	if (local.arr1.size != local.arr2.size) { // both array are not equal in size
		group.returnThread end 0;
	}
	if (group.strict) {
		if (typeof(local.arr1) != typeof(local.arr2)) { // one is constant, the other is not
			group.returnThread end 0;
		}
	}
	
	local.bounds = waitthread GetBounds local.arr1;
	local.bounds2 = waitthread GetBounds local.arr2;
	if (!local.bounds && !local.bounds2) { // both arrays are either empty; or associative
		end;
	}
	
	if (local.bounds[1] != local.bounds2[1]) { // lower bounds are not equal
		group.returnThread end 0;
	} if (local.bounds[2] != local.bounds2[2]) { // upper bounds are not equal
		group.returnThread end 0;
	}
	
	local.bounds2 = NIL;
	for (local.i = local.bounds[1]; local.i <= local.bounds[2]; local.i++) {
		if (waitthread IsArray local.arr1[local.i]) {
			waitthread __Equals local.arr1[local.i] local.arr2[local.i];
		} 
		else {
			waitthread _Equals local.arr1[local.i] local.arr2[local.i];
		}
	}
end;

/**
 string Serialize(<array> array)
 =================================================================
 OVERVIEW|: Serializes specified array as a string that can be saved
			in primitive datatypes such a cvar. 
 RETURN	 |: <string>;
			or NIL upon failure.
			
 NOTE 1	 |: Serializing entities/listeners is not supported and they 
			will be deserialized as a NULL listener.
	  2	 |: The array must not contain strings that consist of non-
			printable character or the Deserialization process will 
			produce unexpected results.
	  3	 |: The value or order of the array elements will remain 
			unchanged but the indexing of those elements isn't saved.
*/
Serialize local.array:
	if (level.DEBUG) {
		if !(waitthread IsArray local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Serialize()]: it's pointless to serialize something other than an array! ~^~^~^~ \n");
			end;
		} if (waitthread IsAssociativeArray local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Serialize()]: serializing an associative array is not supported! ~^~^~^~ \n");
			end;
		} if (waitthread IsEntityArray local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Serialize()]: serializing an entity array is not supported! ~^~^~^~ \n");
			end;
		}
	}

	waitthread __SerializationInfo;
	
	group.result = "";
	waitthread __Serialize local.array;
	
	waitthread __DereferenceInfo;
end group.result;

__Serialize local.array:
	local.bounds = waitthread GetBounds local.array;
	if (!local.bounds) {
		end;
	}
	
	group.result += group.array_open;
	for (local.i = local.bounds[1]; local.i <= local.bounds[2]; local.i++) {
		if (waitthread IsArray local.array[local.i]) {
			waitthread __Serialize local.array[local.i];
		}
		else {
			group.result += (group.type_c[(typeof(local.array[local.i]))] + \
							(waitthread game.System.Common.CastToString local.array[local.i]));
		}
		group.result += group.separator;
	}
	group.result += group.array_close;
end;

/**
 array[] Deserialize(<string> serializedArray, [<int> startIdx])
 =================================================================
 OVERVIEW|: Deserializes a previously serialized array back to an array.
			By default, the array indexing starts at index 1, but you may
			specify otherwise.
 RETURN	 |: <array>;
 			or NIL upon failure.
			
 NOTE 1	 |: Deserialized elements will be auto-casted back to their  
			respective types. 
	  2	 |: The array returned and all the arrays it contains are 
			mutable arrays.
*/
Deserialize group.string group.startIdx:
	if (level.DEBUG) {
		if (!group.string || !(waitthread game.System.String.IsString group.string)) {
			conprintf ("~^~^~^~ ERROR[System.Array.Deserialize()]: specified string is invalid! ~^~^~^~ \n");
			end;
		}
	}
	if ((typeof group.startIdx)[0] != "i") {
		group.startIdx = 1;
	}
	
	waitthread __DeserializationInfo;
	
	if (group.string[0] == group.array_open) {
		group.strSize = group.string.size;
		group.j = 0;
		
		local.result[1] = NIL; // initialize new array
		waitthread __Deserialize local.result;
		
		group.j = NIL;
		group.strSize = NIL;
	} else {
		if (level.DEBUG) {
			conprintf ("~^~^~^~ ERROR[System.Array.Deserialize()]: specified string is not a serialized array! ~^~^~^~ \n");
		}
	}

	waitthread __DereferenceInfo;
	group.string = NIL;
	group.startIdx = NIL;
end local.result;

__Deserialize local.result:
	local.i = group.startIdx;
	local.elem = "";
	local.type = "";
	
	for (group.j += 1; group.j < group.strSize; group.j++) {
		local.char = string(group.string[group.j]);
		
		if (local.char == group.array_open) {
			local.result[local.i][1] = NIL; 
			waitthread __Deserialize local.result[local.i];
			local.i++;
		}
		else if (local.char == group.array_close) {
			group.j++;
			break;
		}
		else if (local.char == group.separator) {
			local.result[local.i] = waitthread game.System.Common.path::("CastTo" + local.type) local.elem;
			local.i++;
			local.elem = "";
		} 
		else if (group.type_c[local.char]) {
			local.type = group.type_c[local.char];
		} 
		else {
			local.elem += local.char;
		}
	}
end;

__SerializationInfo:
	waitthread __GlobalInfo;
	
	group.type_c["int"] = ;
	group.type_c["float"] = ;
	group.type_c["vector"] = ;
	group.type_c["string"] = ;
	group.type_c["const string"] = ;
	group.type_c["char"] = ;
	group.type_c["NIL"] = ;
	group.type_c["listener"] = ;
end; 

__DeserializationInfo:
	waitthread __GlobalInfo;
	
	group.type_c[] = "Int";
	group.type_c[] = "Float";
	group.type_c[] = "Vector";
	group.type_c[] = "String";
	group.type_c[] = "Char";
	group.type_c[] = "Void";
	group.type_c[] = "Entity";
end;

__GlobalInfo:
	group.separator = ;
	group.array_open = ;
	group.array_close = ;
end;

__DereferenceInfo:
	group.separator = NIL;
	group.array_open = NIL;
	group.array_close = NIL;
	group.type_c = NIL;
end;

/**
 void Push(<array> array, <type/array> element(s))
 =================================================================
 OVERVIEW|: Adds one or more element(s) at the end of specified array.
 RETURN	 |: NIL;
*/
Push local.array local.elements:
	if (level.DEBUG) {
		if !(waitthread IsMutableArray local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Push()]:specified array (arg1) is invalid; it is not a mutable array! ~^~^~^~ \n");
			end;
		}
		if (local.elements == NIL) {
			conprintf ("~^~^~^~ ERROR[System.Array.Push()]: no elements specified! ~^~^~^~ \n");
			end;
		}
	}
	
	if (waitthread IsArray local.elements) {
		local.elemBounds = waitthread GetBounds local.elements;
	}
	
	// In case of associative array or non-array type
	if (local.elemBounds == NIL) {
		local.elemBounds = 0::0;
		local.elemToAdd[0] = local.elements; 
	} else {
		local.elemToAdd = local.elements;
	}
	
	if (local.array.size == 0) {
		local.j = 1;
	} else {
		local.j = (waitthread GetUpperBound local.array) + 1;
	}
	for (local.i = local.elemBounds[1]; local.i <= local.elemBounds[2]; local.i++) {
		local.array[local.j] = local.elemToAdd[local.i];
		local.j++;
	}
end;

/**
 array[] Pop(<array> array, [<int> howMany])
 =================================================================
 OVERVIEW|: Removes one or more elements from the end of the specified array
			and returns them.
			If 'howMany' is not specified, the function will return the last
			element as is and not an array.
 RETURN	 |: <array> or <type>;
			or NIL upon failure.
*/
Pop local.array local.howMany:
	if (level.DEBUG) {
		if !(waitthread IsMutableArray local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Pop()]: specified array (arg1) is invalid; it is not a mutable array! ~^~^~^~ \n");
			end;
		} 
	}
	
	if (local.array.size == 0) {
		end;
	}
	
	local.upper = (waitthread GetUpperBound local.array);
	
	if ((typeof local.howMany)[0] != "i") {
		local.result = local.array[local.upper];
		local.array[local.upper] = NIL;
	} 
	else {
		if (local.array.size < local.howMany) {
			local.howMany = local.array.size;
		}
		
		for (local.i = 0; local.i < local.howMany; local.i++) {
			local.j = local.upper - local.i;
			local.result[local.howMany - local.i] = local.array[local.j];
			local.array[local.j] = NIL;
		}
	} 
end local.result;

/**
 void Unshift(<array> array, <type/array> element(s))
 =================================================================
 OVERVIEW|: Adds one or more element(s) to the beginning of specified array.
 RETURN	 |: NIL;
*/
Unshift local.array local.elements:
	if (level.DEBUG) {
		if !(waitthread IsMutableArray local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Unshift()]: specified array (arg1) is invalid; it is not a mutable array! ~^~^~^~ \n");
			end;
		}
		if (local.elements == NIL) {
			conprintf ("~^~^~^~ ERROR[System.Array.Unshift()]: no elements specified! ~^~^~^~ \n");
			end;
		}
	}
	
	if (waitthread IsArray local.elements) {
		local.elemBounds = waitthread GetBounds local.elements;
	}
	
	// In case of associative array or non-array type
	if (local.elemBounds == NIL) {
		local.elemBounds = 0::0;
		local.elemToAdd[0] = local.elements; 
	} else {
		local.elemToAdd = local.elements;
	}
	
	if (local.array.size == 0) {
		local.j = 1;
	} else {
		local.j = (waitthread GetLowerBound local.array);
		waitthread __ShiftIndicesUp local.array local.j local.elemToAdd.size;
	}

	for (local.i = local.elemBounds[1]; local.i <= local.elemBounds[2]; local.i++) {
		local.array[local.j] = local.elemToAdd[local.i];
		local.j++;
	}
end;

/**
 array[] Shift(<array> array, [<int> howMany])
 =================================================================
 OVERVIEW|: Removes one or more elements from the beginning of the specified 
			array and returns them.
			If 'howMany' is not specified, the function will return the last
			element as is and not an array.
 RETURN	 |: <array> or <type>;
			or NIL upon failure.
*/
Shift local.array local.howMany:
	if (level.DEBUG) {
		if !(waitthread IsMutableArray local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Shift()]: specified array (arg1) is invalid; it is not a mutable array! ~^~^~^~ \n");
			end;
		}
	}
	
	if (local.array.size == 0) {
		end;
	}
	
	local.lower = (waitthread GetLowerBound local.array);
	
	if ((typeof local.howMany)[0] != "i") {
		local.result = local.array[local.lower];
		local.array[local.lower] = NIL;
		local.howMany = 1;
	} 
	else {
		if (local.array.size < local.howMany) {
			local.howMany = local.array.size;
		}

		for (local.i = 0; local.i < local.howMany; local.i++) {
			local.j = local.lower + local.i;
			local.result[local.i + 1] = local.array[local.j];
			local.array[local.j] = NIL;
		}
	}
	waitthread __ShiftIndicesDown local.array (local.lower + local.howMany) local.howMany;
end local.result;

/**
 array[1] Splice(<array> array, <int> index, <int> howMany, [<type/array> element(s)])
 =================================================================
 OVERVIEW|: Removes a number of elements from a mutable array starting at 
			the specified index and returns an array of the removed elements. 
			
			Optionally, one can insert one or more elements starting at 
			the specified index. 
			If 'howMany' is <=0 and no elements are removed, you should  
			at least add new elements.
			
 RETURN	 |: <array> of the removed elements (empty if none were removed);
			or NIL upon failure.
			
 NOTE 	 |: In any case, this function does not alter the order or value 
			of other elements but their indices may be shifted in order to
			accommodate the removal and/or insertion of elements.
*/
Splice local.array local.index local.howMany local.elements:
	if (level.DEBUG) {
		if !(waitthread IsMutableArray local.array) {
			conprintf ("~^~^~^~ ERROR[System.Array.Splice()]: specified array (arg1) is invalid; it is not a mutable array! ~^~^~^~ \n");
			end;
		}
		if ((typeof local.index)[0] != "i") {
			conprintf ("~^~^~^~ ERROR[System.Array.Splice()]: specified index (arg2) is not an integer! ~^~^~^~ \n");
			end;
		}
		if ((typeof local.howMany)[0] != "i") {
			conprintf ("~^~^~^~ ERROR[System.Array.Splice()]: specified howMany (arg3) is not an integer! ~^~^~^~ \n");
			end;
		}
	}
	
	if (local.howMany < 0) {
		local.howMany = 0;
	}
	
	local.endIndex = local.index + local.howMany;
	local.result[0] = NIL;
	
	// STEP 1: REMOVAL
	if (0 < local.howMany) {
		for (local.i = local.index; local.i < local.endIndex; local.i++) {
			local.result[local.result.size + 1] = local.array[local.i];
			local.array[local.i] = NIL;
		}
	}

	if (local.elements == NIL) {
		waitthread __ShiftIndicesDown local.array local.endIndex local.howMany;
		end local.result;
	}
	
	// STEP 2: INSERTION
	if (waitthread IsArray local.elements) {
		local.elemBounds = waitthread GetBounds local.elements;
	}
	
	// In case of associative array or non-array type
	if (local.elemBounds == NIL) {
		local.elemBounds = 0::0;
		local.elemToAdd[0] = local.elements; 
	} else {
		local.elemToAdd = local.elements;
	}

	local.elements = NIL;
	local.shift = local.elemToAdd.size - local.howMany;

	if (0 < local.shift) {
		waitthread __ShiftIndicesUp local.array local.endIndex local.shift;
	} 
	else if (local.shift < 0) {
		waitthread __ShiftIndicesDown local.array local.endIndex (abs(local.shift));
	}

	// COPY
	for (local.i = local.elemBounds[1]; local.i <= local.elemBounds[2]; local.i++) {
		local.array[local.index] = local.elemToAdd[local.i];
		local.index++;
	}
end local.result;

// <index> argument specifies from which index to start shifting elements upwards
// <howMany> specified how many indices we should shift the elements upward
// <index> to <index + howMany> determines the indices of the empty elements that were inserted.
__ShiftIndicesUp local.array local.index local.howMany:
	if (local.howMany <= 0) {
		end;
	}
	if (local.array.size == 0) {
		end;
	}
	
	for (local.i = (waitthread GetUpperBound local.array); 
		 local.index <= local.i; local.i--) 
	{
		local.array[local.i + local.howMany] = local.array[local.i];
		local.array[local.i] = NIL;
	}
end;

// <index> argument specifies at which index to start shifting elements downwards.
// <howMany> specified how many indices we should shift the elements downward
// <index - howMany> to <index> determines the indices of the empty elements that were filled.
__ShiftIndicesDown local.array local.index local.howMany:
	if (local.howMany <= 0) {
		end;
	}
	if (local.array.size == 0) {
		end;
	}
	
	local.upperBound = (waitthread GetUpperBound local.array);
	
	for (local.i = local.index; local.i <= local.upperBound; local.i++) {
		local.array[local.i - local.howMany] = local.array[local.i];
		local.array[local.i] = NIL;
	}
end;

/**
 array[1] GetBounds(<type> array)
 =================================================================
 OVERVIEW|: Returns an array with the lower and upper bounds of the specified array.
			If a lower or upper bound is already known, it can be used to speed up
			and influence the process.
 RETURN	 |: <array>	=>	[1] = lower bound
						[2] = upper bound
			or NIL upon failure.
*/
GetBounds local.array local.lower local.upper:
	if (local.lower != NIL) {
		if (local.upper != NIL) {
			end local.lower::local.upper;
		}
		end local.lower::(waitthread GetUpperBound local.array local.lower);
	} 
	if (local.upper != NIL) {
		end (waitthread GetLowerBound local.array local.upper)::local.upper;
	}
	
	switch(typeof(local.array)) {
		case "vector":
			local.bounds = 0::2; // .size property of vectors will always return 1.
		break;
		case "string":
		case "const string":
			local.bounds = 0::(local.array.size - 1);
		break;
		case "const array":
			local.bounds = 1::local.array.size;
		break;
		case "array":
			local.end = local.array.size * game.System.Array.sparsityFactor;
			// Look for lower bound.
			for (local.i = 0; local.i <= local.end; local.i++) {
				if (local.array[local.i] != NIL) {
					local.lower = local.i;
					break;
				}
			}
			// Associative array...
			if (local.lower == NIL) {
				break;
			}
			// Continue looking for the upper bound.
			local.cnt = 0;
			for (/*padding*/; local.i <= local.end; local.i++) {
				if (local.array[local.i] != NIL) {
					local.cnt++;
					local.upper = local.i;
					if (local.cnt >= local.array.size) {
						break;
					}
				}
			}
			local.bounds = local.lower::local.upper;
		break;
		default:
			if (1 < level.DEBUG) {
				conprintf ("~^~^~^~ ERROR[System.Array.GetBounds()]: specified array (arg1) is of an invalid type '" + typeof(local.array) + "'! ~^~^~^~ \n");
			}
		break;
	}
end local.bounds;

/**
 int GetLowerBound(<type> array)
 =================================================================
 OVERVIEW|: Returns the lower bound of the specified array.
			If an upper bound is already known, it can be used to 
			speed up and influence the process.
 RETURN	 |: <int>
			or NIL upon failure.
*/
GetLowerBound local.array local.upper:
	switch(typeof(local.array)) {
		case "vector":
		case "string":
		case "const string":
			local.lower = 0;
		break;
		case "const array":
			local.lower = 1;
		break;
		case "array":
			if !(local.upper) {
				local.upper = local.array.size * game.System.Array.sparsityFactor;
			}
			local.start = local.upper - (local.array.size * game.System.Array.sparsityFactor);
			
			for (local.i = local.start; local.i <= local.upper; local.i++) {
				if (local.array[local.i] != NIL) {
					local.lower = local.i;
					break;
				}
			}
		break;
		default:
			if (1 < level.DEBUG) {
				conprintf ("~^~^~^~ ERROR[System.Array.GetLowerBound()]: specified array (arg1) is of an invalid type '" + typeof(local.array) + "'! ~^~^~^~ \n");
			}
		break;
	}
end local.lower;

/**
 int GetUpperBound(<type> array)
 =================================================================
 OVERVIEW|: Returns the upper bound of the specified array.
			If an lower bound is already known, it can be used to 
			speed up and influence the process.
 RETURN	 |: <int>
			or NIL upon failure.
*/
GetUpperBound local.array local.lower:
	switch(typeof(local.array)) {
		case "vector":
			local.upper = 2;
		break;
		case "string":
		case "const string":
			local.upper = local.array.size - 1;
		break;
		case "const array":
			local.upper = 1;
		break;
		case "array":
			if !(local.lower) {
				local.lower = 0;
			}
			local.end = local.lower + (local.array.size * game.System.Array.sparsityFactor);
			local.cnt = 0;
			
			for (local.i = local.lower; local.i <= local.end; local.i++) {
				if (local.array[local.i] != NIL) {
					local.cnt++;
					local.upper = local.i;
					if (local.cnt >= local.array.size) {
						break;
					}
				}
			}
		break;
		default:
			if (1 < level.DEBUG) {
				conprintf ("~^~^~^~ ERROR[System.Array.GetUpperBound()]: specified array (arg1) is of an invalid type '" + typeof(local.array) + "'! ~^~^~^~ \n");
			}
		break;
	}
end local.upper;

/** General note on types 'array' & 'const array':
 NOTE 1	|: These are references to the actual arrays in memory, so if they are copied into another variable or passed on as arguments, only the reference is copied. 
 NOTE 2	|: Bizarrely, unlike the 'listener' reference-type, if the same array is compared to itself (using ==) it will always return false.
*/

/** Regarding index-boundary detection:
 NOTE 1	|:  In case of type 'array'; negative indices will only be covered if an argument is supplied to base calculations on.
 NOTE 2	|:	By default, if an array is more sparse than factor 4 (i.e. for a set of 4 elements, at least 3 elements are empty), the results may not be accurate.
 NOTE 3	|: 	If you look carefully, then the case of arr.size==0 is handled quite elegantly in both functions :)
*/

/** Regarding the use of 'group.returnThread = local;'
 NOTE 1	|: In this recursive situation, this allows the threads that branch out in a tree 
			to remotely control the user-called thread that triggered the recursion.
			They can end it at will with any output variable. I chose a group variable 
			over a local parameter, since the latter needs to be passed on to each 
			new thread in the recursion.
 NOTE 2	|: Once a thread has been terminated/deleted, all other threads it was waiting on 
			are terminated and deleted as well. In turn, the threads that those deleted
			threads were waiting on are also deleted; and so on.
*/