main local.name local.model local.origin local.angles local.health local.boatspeed local.resettime local.scale local.gotout:

	if(local.model == NIL) { wait 1; println("----- ERROR playerboat.scr: 'model' parameter is missing!"); end }
	if(local.model[0] != "m" && local.model[1] != "o" && local.model[2] != "d" && local.model[3] != "e" && local.model[4] != "l" && local.model[5] != "s")
	{
		local.model = "models/" + local.model
		if(local.model == "models/vehicles/higgins.tik") { local.model = "models/vehicles/higginsxtrahull.tik" }
		if(level.vehiclescriptmaster[local.model] != 1) { cache local.model }
	}

	if($(local.name) != NULL) 
	{
		waitframe; if($(local.name) != NULL) { waitframe; if($(local.name) != NULL) { waitframe; if($(local.name) != NULL) { waitframe; if($(local.name) != NULL) { waitframe } } } }
		if($(local.name) != NULL)
		{
			if(level.vehiclescriptmaster[local.model] != 1) { wait 1; println("----- ERROR playerboat.scr: $" + local.name + " must be removed before spawning a drivable boat.") }
			end
		}
	}

	if(local.health == NIL || (local.health != NIL && local.health <= 0 && level.vehiclescriptmaster[local.model] != 1)) { wait 1; println("----- ERROR playerboat.scr: health must be greater than 0."); end }
	if(local.health == NIL || (local.health != NIL && local.health <= 0 && level.vehiclescriptmaster[local.model] == 1)) { end } // end when in rare cases, a 2nd vehicle with local.health = 0 could spawn after getting destroyed

	if(local.model == "models/vehicles/higginsxtrahull.tik") { local.desmodel = models/vehicles/higgins_damage.tik }

	local.vehicle = spawn local.model targetname (local.name) // scriptmasters are already added in ubersound.scr
	local.vehicle.name = local.name
	local.vehicle.origin = local.origin
	local.vehicle.angles = local.angles
	local.vehicle.desmodel = local.desmodel
	local.vehicle.health = local.health
	local.vehicle.boatspeed = local.boatspeed
	local.vehicle.boatspeed_max = local.boatspeed
	local.vehicle.resettime = local.resettime
	if(local.scale == NIL || local.vehicle.model != "models/vehicles/uboat.tik") { local.vehicle.scale = 1 }
	else
	{
		local.vehicle.scale = local.scale
		local.vehicle setsize ( -(2000 * local.scale) -(150 * local.scale) 0 ) ( (1820 * local.scale) (150 * local.scale) (140 * local.scale) )
	}

	if(local.vehicle.classname != "DrivableVehicle") { local.vehicle remove; wait 1; println("----- ERROR playerboat.scr: .tik model is not a DrivableVehicle."); end }

	local.vehicle turnrate 5; local.vehicle.turningrate = 5.000
	if(local.gotout == 1) { local.vehicle playsound sdkfz_snd_stop }

	local.vehicle.seats = 1		// initialize this before adding seats in "seatstuff" thread to avoid NIL errors
	local.vehicle thread vehiclereset
	local.vehicle thread vehicledamage
	local.vehicle thread vehicledeath
	local.vehicle thread vehicletrigger

	if(level.boat_initorigin[local.name] == NIL) { level.boat_initorigin[local.name] = local.origin } // store the initial origin/angles as level variable arrays
	if(level.boat_initangles[local.name] == NIL) { level.boat_initangles[local.name] = local.angles }
	if(level.boat_inithealth[local.name] == NIL) { level.boat_inithealth[local.name] = local.health }

	if(level.vehiclescriptmaster[local.vehicle.model] != 1) // this only runs once
	{
		cache local.vehicle.model
		cache local.desmodel
		cache models/emitters/fancyfire.tik; cache models/emitters/thin_black_short.tik
		cache models/emitters/mortar_higgins.tik
		cache models/emitters/mortar_dirt_nosound.tik
		thread scriptmaster local.vehicle.model
		level.vehiclescriptmaster[local.vehicle.model] = 1
		level.vehiclescriptmaster[local.model] = 1
	}

	if(local.vehicle.model == "models/vehicles/uboat.tik")
	{
		local.vehicle turnrate 1; local.vehicle.turningrate = 1.000
		local.vehicle attachmodel models/emitters/fancyfire.tik "Box01" 1 (local.name + "_tag_barrel") 1 -1 -1 -1 -1 ( 0 211 565 ) //( +left -right, +up -down, +forward -backward )
		$(local.name + "_tag_barrel") notsolid
		$(local.name + "_tag_barrel") hide
		local.vehicle.gun = $(local.name + "_tag_barrel")

		local.vehicle thread boatstuck_inwall_fix
		local.vehicle thread turret_laser local.name
	}
/*
	if(local.vehicle.model == "models/vehicles/higginsxtrahull.tik")
	{
		local.vehicle attachmodel models/vehicles/higginsdoor.tik "Box01" 1 (local.name + "_door") 1 -1 -1 -1 -1 ( 0 0 0 )
		$(local.name + "_door").angles = ( 180 0 -90 )
		$(local.name + "_door") notsolid
	}
*/
										// "local.player.touching_playerboat" or "$player[1].touching_playerboat" can be included in trigger setthreads
	if(level.touching_playerboat != 1) { thread touching_playerboat }	// to exclude teleporting players that are touching "$ocean" or similar water-surface triggers.

	if(level.check_player_kills != 1) { local.result = registerev damage killstreaks/damagehandler.scr } // for giving kills/score when players shoot/kill passengers.
	level.check_player_kills = 1

	if(level.chainreactors == NIL || (level.chainreactors != NIL && level.chainreactors.size < 1)) { level.chainreactors[1] = local.vehicle }
	else
	{
		for(local.c = 1; local.c <= 999; local.c++)
		{
			if(level.chainreactors[local.c] == NIL)
			{
				level.chainreactors[local.c] = local.vehicle
				local.vehicle thread chainreactors_remove local.c
				break
			}
		}
	}
end

chainreactors_remove local.c:

	while(self != NULL) { waitframe }
	level.chainreactors[local.c] = NIL
end

////////////////////////////////////////////////////////////////////////

vehiclereset:

	self thread healthboost
	//removeclass Camera // also removes PlayerIntermission and other func_cameras
	if(level.removeclass_camera != 1) { thread removeclass_camera }
end

healthboost: // shotgun: 340 damage, bazooka: 105 damage, sniper: 106 damage, one grenade: 200 damage, two grenades: 400 damage

	local.health = self.health
	while(self != NULL && self.health > 0)
	{
		if(self.health < local.health && self.shooter != NIL && self.shooter != NULL)
		{
			if(self.passengers != NIL && self.passengers.size >= 1)
			{
				local.damage = ((local.health - self.health) / self.passengers.size)
				for(local.i = 1; local.i <= self.passengers.size; local.i++)
				{
					self.passengers[local.i] takedamage
					if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.passengers[local.i] damage self.shooter.player_owner local.damage self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.passengers[local.i] damage self.shooter.owner local.damage self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					else { self.passengers[local.i] damage self.shooter local.damage self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					self.passengers[local.i] nodamage
				}
			}
			if(self.driver != NIL && self.driver != NULL && self.model != "models/vehicles/uboat.tik")
			{
				if(self.driver.health > 1)
				{
					self.driver takedamage
					if(self.passengers != NIL && self.passengers.size >= 1) { local.damage = ((local.health - self.health) / (2 + self.passengers.size)) }
					else { local.damage = ((local.health - self.health) / 2) }

					if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.driver damage self.shooter.player_owner local.damage self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.driver damage self.shooter.owner local.damage self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					else { self.driver damage self.shooter local.damage self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					self.driver nodamage
				}
				else
				{
					self thread driverreset 1
					self thread vehiclereset
					if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.driver damage self.shooter.player_owner 9999999 self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.driver damage self.shooter.owner 9999999 self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					else { self.driver damage self.shooter 9999999 self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					self.driver = NIL
				}
			}

			for(local.i = 1; local.i <= $player.size; local.i++)
			{
				if($player[local.i].isdog == 1 && $("dogmouthtrig_" + $player[local.i].entnum).biting == 1 && $("dogmouthtrig_" + $player[local.i].entnum) istouching self && $player[local.i].passenger != 1)
				{
					for(local.i = 1; local.i <= self.passengers.size; local.i++)
					{
						self.passengers[local.i] damage $player[local.i] 15000 $player[local.i] (0 0 0) (0 0 0) (0 0 0) 0 9 0 0
					}
				}
			}
		}
		if(isalive self) { self.health = local.health } // need "isalive" check to avoid "cannot give health to dead entities" error
		if(self.shooter != NIL) { self thread shooter_NIL }
		waitframe
	}
end

shooter_NIL:

	waitframe
	if(self != NULL) { self.shooter = NIL }
end

vehicletrigger:

	if($(self.name + "_trig") != NULL) { $(self.name + "_trig") remove }
	local.trig = spawn trigger_use targetname (self.name + "_trig")
	local.trig.origin = self.origin
	if(self.model != "models/vehicles/uboat.tik") { local.trig setsize ( -130 -130 -100 ) ( 130 130 100 ) }
	else { local.trig setsize ( -(2000 * self.scale) -(150 * self.scale) -(10 * self.scale) ) ( (1820 * self.scale) (150 * self.scale) (200 * self.scale) ) }
	local.trig.vehicle = self
	local.trig glue self
	local.trig setthread triggered
end

triggered:

	local.player = parm.other
	if(local.player.driving == 1 || local.player.passenger == 1 || local.player.flying == 1) { end }

	if(self.vehicle != NULL)
	{
		if(self.vehicle.driver != NIL && self.vehicle.passengers.size < self.vehicle.seats)
		{
			self.vehicle thread passengers
		}
		if(self.vehicle.driver == NIL)
		{
			if(local.player.isdog != 1) { self.vehicle thread playergetin }
			if(local.player.isdog == 1) { local.player iprint ("Dogs cannot drive vehicles.") } // set other exceptions here
		}
	}
end

playergetin:

	local.player = parm.other
	local.team = local.player.dmteam
	if(self.attachingdriver == 1) { end }
	self.attachingdriver = 1

	local.player safeholster 1
	wait 1
	if(self == NULL || local.player == NIL || local.player == NULL || !isalive local.player || local.player.dmteam != local.team || local.player.dead == 1 || level.change_team_score == 1 || level.bbactive == 0 || (self.turretplayer != NIL && self.turretplayer != NULL) || local.player.driving == 1 || local.player.flying == 1)
	{
		if(self != NULL) { self.attachingdriver = 0 }
		end
	}

	self.driver = local.player
	self.driver.driving = 1
	self.driver.drivingent = self
	local.driver = self.driver
	self.player_owner = self.driver

	self.passengers[1] = NIL // initialize as array to make size = 0 instead of size = -1
	self thread seatstuff

	self.driver forcelegsstate STAND
	//self.driver hide
	self.driver nodamage // keep this off until the player receives damage, then quickly do "takedamage" and give damage, before doing "nodamage" again in "healthboost" thread (allows for more damage types such as bazooka rockets to count as kills).
	self.driver notsolid
	self.driver.driving_state_jump = 0
	if(self.model == "models/vehicles/uboat.tik")
	{
		self.driver iprint ("Lean Left/Right = aim turret down/up. Lean Left/Right (while not moving) = look behind.")
		self.driver iprint ("JUMP = exit boat. FIRE Primary = shoot rockets. FIRE Secondary = throw grenades.")
	}
	else { self.driver iprint ("JUMP = exit boat. Hold FIRE = look behind.") }

	self attachdriverslot 0 self.driver
	self thread dummyavatar
	self.driver loopsound wavelaps
	self.turretlaser_offset = 0

	if(local.driver.using_pack == 1)
	{
		local.driver stufftext "globalwidgetcommand june6 linkcvar phealth"
		local.driver stufftext "globalwidgetcommand june6 statbar vertical 0 100"
		local.driver stufftext "globalwidgetcommand charliesector linkcvar phealth"
		local.driver stufftext "set phealth 100"
	}
	else { local.driver thread display }

	ihuddraw_alpha local.player 111 0
	ihuddraw_virtualsize local.player 111 1
	ihuddraw_alpha local.player 111 .8
	ihuddraw_font local.player 111 "verdana-12"
	ihuddraw_color local.player 111 .85 .85 0
	ihuddraw_rect local.player 111 330 212 200 14 
	ihuddraw_string local.player 111 "" // "Passengers:   0"
	local.passengers_hud = 0

	local.c = 5.000		// boat speed divisor; Higher = starting speed is much slower (total change is larger), Lower = starting speed is closer to max speed (total change is smaller).
	local.decel_rate = 30	// how many divisions of local.c for deceleration/acceleration. Higher = more time to reach max speed, Lower = less time to reach max speed.
	local.deceleration = local.c
	local.drivervelocity_old = ( 0 0 0 )
	local.forward = 0
	local.backward = 0
	local.d = local.c	// vehicle turnrate will increase equally when accelerating, but will decrease 4x as fast when decelerating.

	self.attachingdriver = 0
	while(self != NULL && isalive self.driver && self.driver.dmteam == local.team && self.driver.dead != 1 && level.change_team_score != 1 && level.bbactive != 0)
	{
		if(self.driver.driving_state_left == 1 && self.driver.driving_state_right != 1)
		{
			if(self.angles[2] > 180) { self.driver.viewangles = ( (self.angles[2] * -1 + 360 + 10) (self.angles[1] + 90) (self.angles[0] * -1) ) }
			else if(self.angles[2] < -180) { self.driver.viewangles = ( (self.angles[2] * -1 - 360 + 10) (self.angles[1] + 90) (self.angles[0] * -1) ) }
			else { self.driver.viewangles = ( (self.angles[2] * -1 + 10) (self.angles[1] + 90) (self.angles[0]) ) }
		}
		if(self.driver.driving_state_left != 1 && self.driver.driving_state_right == 1)
		{
			if(self.angles[2] > 180) { self.driver.viewangles = ( (self.angles[2] - 360 + 10) (self.angles[1] - 90) (self.angles[0] * -1) ) }
			else if(self.angles[2] < -180) { self.driver.viewangles = ( (self.angles[2] + 360 + 10) (self.angles[1] - 90) (self.angles[0] * -1) ) }
			else { self.driver.viewangles = ( (self.angles[2] + 10) (self.angles[1] - 90) (self.angles[0] * -1) ) }
			
		}
		if(self.driver.driving_state_left != 1 && self.driver.driving_state_right != 1) { self.driver.viewangles = ( (self.angles[0] + 10) self.angles[1] self.angles[2] ) }

		if(self.driver.driving_state_jump == 1) // Press JUMP to exit.
		{
			self thread driverreset
			self thread vehiclereset
			self.driver thread wallstuck_fix
			self.driver = NIL
			break
		}

		if(self.passengers.size != local.passengers_hud)
		{
			if(self.passengers.size > 0) { ihuddraw_string local.player 111 ("Passengers:   " + self.passengers.size) }
			else { ihuddraw_string local.player 111 "" }
			local.passengers_hud = self.passengers.size
		}

		if(self.model == "models/vehicles/uboat.tik")
		{
			if(self.turretlaser != NIL && self.turretlaser != NULL)
			{
				local.fwd_vec = angles_toforward ( (self.angles[0] + self.turretlaser_offset) self.angles[1] self.angles[2] )
				local.start = $(self.targetname + "_tag_barrel").origin
				local.groundtarget = trace (local.start + local.fwd_vec * 56) (local.start + local.fwd_vec * 10240) 0

				self.turretlaser.origin = $(self.targetname + "_tag_barrel").origin
				self.turretlaser endpoint local.groundtarget
			}

			if(self.driver.useheld != 1)
			{
				if(self.driver.fireheld == 1)
				{
					if(self.driver.secfireheld != 1) { self thread firegun } 
					else { self thread firesecondary }
				}
	
				if(self.driver.fireheld != 1 && (self.driver.leanleftheld == 1 || self.driver.leanrightheld == 1))
				{
					if(self.velocity == ( 0 0 0 )) { self.driver.viewangles = ( (10 + self.angles[0] * -1) (self.angles[1] + 180) (self.angles[2] * -1) ) }
					else if(self.turretlaser != NIL && self.turretlaser != NULL)
					{
						if(self.driver.leanleftheld != 1 && self.driver.leanrightheld == 1)
						{
							if(self.turretlaser_offset > -15) { self.turretlaser activate; self.turretlaser_offset -= .25 }
							else { self.turretlaser deactivate; self.turretlaser_offset = -15 }
						}
	
						if(self.driver.leanleftheld == 1 && self.driver.leanrightheld != 1)
						{
							if(self.turretlaser_offset < 3) { self.turretlaser activate; self.turretlaser_offset += .25 }
							else { self.turretlaser deactivate; self.turretlaser_offset = 3 }
						}
						if(self.driver.leanleftheld != 1 && self.driver.leanrightheld != 1) { self.turretlaser deactivate }
					}
				}
				else { self.turretlaser deactivate }
			}
		}
		else if(self.driver.fireheld == 1) { self.driver.viewangles = ( (10 + self.angles[0] * -1) (self.angles[1] + 180) (self.angles[2] * -1) ) }

		if(self.driver.viewangles[0] > 180) { self.driver.viewangles = ( (10 + (self.angles[0] - 360)) self.driver.viewangles[1] self.driver.viewangles[2] ) } // any viewangles[0] +/- 180 will cause camera issues (going under vehicle).
		if(self.driver.viewangles[0] < -180) { self.driver.viewangles = ( (self.driver.viewangles[0] + 360) self.driver.viewangles[1] self.driver.viewangles[2] ) } // prevent camera from moving too far down.

		if(self.velocity != ( 0 0 0 )) // make boats drive faster in reverse, only when holding S (walk backwards key) and when holding FIRE (looking behind).
		{
			self.driver loopsound riverdrive

			if(self.driver.driving_state_backward == 1)
			{
				if(local.forward == 1 && local.c < local.deceleration) // slowing down, before reversing begins.
				{
					local.c += local.deceleration * 2.000 / local.decel_rate
					local.d += 4.000 * local.deceleration / local.decel_rate
					if(local.c > local.deceleration) { local.c = local.deceleration; self.boatspeed = 0 }
					if(local.d > local.deceleration) { local.d = local.deceleration }
					self.boatspeed = self.boatspeed_max / local.c
					self.velocity = self.driver.velocity * (self.boatspeed / self.boatspeed_max * -1) + self.forwardvector * self.boatspeed
				}
				else
				{
					local.c -= local.deceleration / local.decel_rate
					local.d -= local.deceleration / local.decel_rate
					if(local.c < 1) { local.c = 1 }
					if(local.d < 1) { local.d = 1 }
					self.boatspeed = self.boatspeed_max / local.c
					self.velocity = self.driver.velocity + self.forwardvector * self.boatspeed * -0.500 // only reverse at half the maximum boat speed
					local.forward = 0
					local.backward = 1
				}
			}
			else // make boats drive faster, only when holding W (forward key).
			{
				if(local.backward == 1 && local.c < local.deceleration) // slowing down, before driving forward begins.
				{
					local.c += local.deceleration * 2.000 / local.decel_rate
					local.d += 4.000 * local.deceleration / local.decel_rate
					if(local.c > local.deceleration) { local.c = local.deceleration; self.boatspeed = 0 }
					if(local.d > local.deceleration) { local.d = local.deceleration }
					self.boatspeed = self.boatspeed_max / local.c
					self.velocity = self.driver.velocity * (self.boatspeed / self.boatspeed_max * -1) + self.forwardvector * self.boatspeed * -0.500 // only reverse at half the maximum boat speed
				}
				else
				{
					local.c -= local.deceleration / local.decel_rate
					local.d -= local.deceleration / local.decel_rate
					if(local.c < 1) { local.c = 1 }
					if(local.d < 1) { local.d = 1 }
					self.boatspeed = self.boatspeed_max / local.c
					self.velocity = self.driver.velocity + self.forwardvector * self.boatspeed
					local.forward = 1
					local.backward = 0
				}
			}

			if(self.turningrate / local.d < 1) { self.turnrate = 1 }
			else if(self.turningrate / local.d < self.turningrate) { self turnrate (self.turningrate / (local.d * 0.500)) }
			else { self turnrate self.turningrate }
		}
		else
		{
			self.driver loopsound wavelaps
			if(local.c == 1) { self playsound sdkfz_snd_shift2 }

			local.d += 4.000 * local.deceleration / local.decel_rate
			if(local.d > local.deceleration) { local.d = local.deceleration }

			local.c += local.deceleration / local.decel_rate
			if(local.c > local.deceleration) { local.c = local.deceleration; self.boatspeed = 0 }
			else { self.boatspeed = self.boatspeed_max / local.c }

			if(self.driver.driving_state_backward == 1) { self.velocity = local.drivervelocity_old + self.forwardvector * self.boatspeed * -1 }
			else { self.velocity = local.drivervelocity_old + self.forwardvector * self.boatspeed }
		}

		local.drivervelocity_old = self.driver.velocity
		local.driver stufftext ("set phealth " + int(local.driver.health))
		waitframe
	}

	if(self != NULL) // spawn in the new vehicle and remove the old one.
	{
		thread main self.name self.model self.origin self.angles self.health self.boatspeed_max self.resettime self.scale 1

		if(self.driver != NIL && self.driver != NULL)
		{
			if(self.driver.dmteam == local.team && level.change_team_score != 1 && level.bbactive != 0) { self thread driverreset }
			else { self thread driverreset 2 } // if the player switched teams without dying, make sure they don't tele back to the vehicle.
			self thread vehiclereset
		}
		if(self.turretplayer != NIL && self.turretplayer != NULL) { self waitthread turretplayer_reset self.turretplayer.dmteam self.turretplayer }

		self.driver = NIL // the old vehicle must be properly removed, otherwise the server will crash if anyone driving the vehicle leaves the game (becomes NULL).
		self remove
	}
	waitframe
	if(local.driver != NULL)
	{
		local.driver.driving = 0
		local.driver.drivingent = NIL
		local.driver stoploopsound
		if(!isalive local.driver) { local.driver stufftext ("set phealth 0") }
		ihuddraw_string local.player 111 ""

		if(local.driver.using_pack == 1)
		{
			local.driver stufftext "globalwidgetcommand june6 linkcvar fuel"
			local.driver stufftext ("globalwidgetcommand june6 statbar vertical 0 " + level.jetpack_max_fuel)
			local.driver stufftext "globalwidgetcommand charliesector linkcvar fuel"
		}
		else
		{
			local.driver stufftext "hidemenu dday1"
			local.driver stufftext "hidemenu dday2"
		}

		local.origin = local.driver.origin
		while(local.driver != NULL && !isalive local.driver && local.driver.dmteam != "spectator")
		{
			local.driver.origin = ( local.origin[0] local.origin[1] local.driver.origin[2] ) // for some reason, drivers' dead bodies would move forward across the ground until they hit a wall.
			local.driver notsolid
			local.driver droptofloor
			waitframe
		}
	}
end

driverreset local.status:

	if(self.driver == NIL) { end } // if the vehicle blew up with nobody driving it, end this thread.

	if(local.status != 1) { cueplayer }				// reattaches camera to player's head
	self detachdriverslot 0 self.driver
	self.driver.viewangles = ( 0 self.driver.viewangles[1] 0 )

	if(self.model == "models/vehicles/uboat.tik") { local.outheight = 180 }
	else { local.outheight = 120 } // if this is 100 or lower and the boat is still moving after the player gets out, the player will be run over by the boat and killed.

	if(self.driver.dmteam != spectator)
	{
		self.driver show
		if(local.status != 1) { self.driver solid }
		self.driver takedamage
		self.driver forcetorsostate STAND // without this, players will be stuck in noclip mode, even though noclip isn't used for drivers (doing "self.driver noclip; self driver noclip" also works).
		if(local.status != 1 && local.status != 2)
		{
			self.driver.origin = self.origin + (angles_toup self.angles * local.outheight)
			self.driver.viewangles = ( self.driver.viewangles[0] self.driver.viewangles[1] 0 )
		}
	}
end

vehicledamage:

	local.c = 0
	while(self != NULL && self.health > 0)
	{
		if(self != NULL)
		{
			local.previoushealth = self.health
			if(local.c > 0) { local.c-- }
		}
		waitframe
		if(self != NULL && local.previoushealth > self.health)
		{
			local.c = local.c + 2
			self playsound damage_vehicle
			//if(local.c == 2) { exec global/earthquake.scr .2 3 0 0 } // if boat is getting constantly damaged per frame, stop earthquake from spamming. (removed, since it was still getting annoying)
		}
	}
end

vehicledeath:

	self waittill death // when waiting until "death", vehicle is not NULL yet
	self stoploopsound
	self playsound explode_truck

	if(self.desmodel == NIL) { self.desmodel = self.model }
	local.desvehicle = spawn script_model
	local.desvehicle.origin = self.origin + ( 0 0 -25 )
	local.desvehicle.scale = self.scale
	local.desvehicle model self.desmodel
	local.desvehicle loopsound vehicledeathfire

	if(self.model != "models/vehicles/uboat.tik") { local.distance = -100 }
	else { local.distance = 355; local.distance2 = 675 }

	local.PI = 3.14159265359
	local.degrees = self.angles[1]
	if(local.degrees >= 180) { local.degrees -= 360 }
	local.radians = local.degrees * (local.PI / 180)

	local.sin = (sin local.radians) * local.distance * local.desvehicle.scale
	local.cos = (cos local.radians) * local.distance * local.desvehicle.scale

	local.r = randomint(2)
	if(local.r == 0) { local.one = 1 }
	if(local.r == 1) { local.one = -1 }

	if(self.model == "models/vehicles/uboat.tik")
	{
		local.desvehicle.angles = self.angles + ( 0 0 ((randomint(20) + 15) * local.one) )
		local.sin2 = (sin local.radians) * local.distance2 * -1 * local.desvehicle.scale
		local.cos2 = (cos local.radians) * local.distance2 * -1 * local.desvehicle.scale
		local.height = 150 * local.desvehicle.scale

		local.degrees0 = self.angles[0]
		if(local.degrees0 >= 180) { local.degrees0 -= 360 }
		local.radians0 = local.degrees0 * (local.PI / 180)
		local.offset = (tan local.radians0) * local.distance * local.desvehicle.scale
		local.offset2 = (tan local.radians0) * local.distance2 * -1 * local.desvehicle.scale

		local.fire = spawn script_model
		local.fire model "models/emitters/fancyfire.tik"
		local.fire.origin = local.desvehicle.origin + ( local.cos local.sin (local.height - local.offset) )
		local.fire.angles = ( 0 0 0 )
		local.fire.scale = 5 * local.desvehicle.scale
		local.fire anim start
		local.fire notsolid
		local.smoke = spawn script_model
		local.smoke model "models/emitters/thin_black_short.tik"
		local.smoke.origin = local.desvehicle.origin + ( local.cos local.sin (local.height - local.offset) )
		local.smoke.angles = ( 0 0 0 )
		local.smoke.scale = 3.5 * local.desvehicle.scale
		local.smoke anim start
		local.smoke notsolid
		local.fire2 = spawn script_model
		local.fire2 model "models/emitters/fancyfire.tik"
		local.fire2.origin = local.desvehicle.origin + ( local.cos2 local.sin2 (local.height - local.offset2) )
		local.fire2.angles = ( 0 0 0 )
		local.fire2.scale = 5 * local.desvehicle.scale
		local.fire2 anim start
		local.fire2 notsolid
		local.smoke2 = spawn script_model
		local.smoke2 model "models/emitters/thin_black_short.tik"
		local.smoke2.origin = local.desvehicle.origin + ( local.cos2 local.sin2 (local.height - local.offset2) )
		local.smoke2.angles = ( 0 0 0 )
		local.smoke2.scale = 3.5 * local.desvehicle.scale
		local.smoke2 anim start
		local.smoke2 notsolid
	}
	else
	{
		local.desvehicle.angles = self.angles + ( 0 0 ((randomint(30) + 5) * local.one) )

		local.fire = spawn script_model
		local.fire model "models/emitters/fancyfire.tik"
		local.fire.origin = local.desvehicle.origin + ( local.cos local.sin 42 )
		local.fire.angles = ( 0 0 0 )
		local.fire.scale = 1
		local.fire anim start
		local.fire notsolid
		local.smoke = spawn script_model
		local.smoke model "models/emitters/thin_black_short.tik"
		local.smoke.origin = local.desvehicle.origin + ( local.cos local.sin 42 )
		local.smoke.angles = ( 0 0 0 )
		local.smoke.scale = .7
		local.smoke anim start
		local.smoke notsolid
	}

	self thread driverreset 1								// local.status = 1
	self thread mainreset local.desvehicle local.fire local.smoke local.fire2 local.smoke2	// waiting self.resettime seconds until a new vehicle is spawned in

	self thread kill_riders
	self.driver = NIL

	if($(self.name + "_trig") != NULL) { $(self.name + "_trig") remove }
	exec global/earthquake.scr .35 2 0 0
	if(local.desvehicle.model == "models/vehicles/uboat.tik") { local.radius = 1000 }
	else { local.radius = 600 }

	if(self.shooter != NIL && self.shooter != NULL)
	{
		if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { local.shooter = self.shooter.player_owner }
		else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { local.shooter = self.shooter.owner }
		else { local.shooter = self.shooter }
	}
	local.blewup = 1
	for(local.i = 1; local.i <= $player.size; local.i++) // use this instead of radiusdamage, so death explosions can count as score/kills.
	{
		if(vector_length(self.origin - $player[local.i].origin) <= local.radius) // "local.explode" emitters cannot be used with "cansee"
		{
			if(local.shooter == NIL || local.shooter == NULL)
			{
				if($player[local.i].driving != 1 && $player[local.i].flying != 1 && $player[local.i] cansee local.desvehicle 360) // "cansee self" does not work.
				{
					$player[local.i] damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0
				}
				else if($player[local.i].drivingent != NIL && $player[local.i].drivingent != NULL)
				{
					if($player[local.i].flying == 1) { $("planehit" + $player[local.i].entnum) damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else { $player[local.i].drivingent damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
				}
			}
			else if($player[local.i] != local.shooter && $player[local.i].dmteam == local.shooter.dmteam && getcvar("g_teamdamage") != "1" && getcvar("g_gametype") != "1") { local.blewup = 0 }
			else
			{
				if($player[local.i].driving != 1 && $player[local.i].flying != 1 && $player[local.i] cansee local.desvehicle 360)
				{
					$player[local.i] damage local.shooter 500 local.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 // "damage" does not hurt teammates, but scriptbazookaexplosion.tik does
				}
				else if($player[local.i].drivingent != NIL && $player[local.i].drivingent != NULL)
				{
					$player[local.i].drivingent.shooter = local.shooter
					if($player[local.i].flying == 1) { $("planehit" + $player[local.i].entnum) damage local.shooter 500 local.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else { $player[local.i].drivingent damage local.shooter 500 local.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
				}
			}
		}
	}
	self remove

	local.boom = spawn script_model
	local.boom model "models/emitters/mortar_higgins.tik"
	local.boom.origin = local.desvehicle.origin + ( 0 0 25 )
	local.boom.angles = ( 0 -90 0 ) + ( 260 0 0 )
	if(local.desvehicle.model == "models/vehicles/uboat.tik") { local.boom.scale = 2.5 }
	else { local.boom.scale = 1 }
	local.boom anim start
	local.boom notsolid

	local.debris = spawn script_model targetname "mortar_dirt_nosound"
	local.debris model "emitters/mortar_dirt_nosound.tik" 
	local.debris.origin = local.desvehicle.origin + ( 0 0 25 )
	if(local.desvehicle.model == "models/vehicles/uboat.tik") { local.debris.scale = 2.0 }
	else { local.debris.scale = .8 }
	local.debris anim start
	local.debris notsolid
	waitframe
	local.boom remove
	local.debris remove
	if(local.blewup == 1) { radiusdamage local.desvehicle.origin 500 local.radius } // this must be one frame after other damages in this thread, otherwise chain-reaction kills will not count.
end

kill_riders:

	if(self.passengers.size >= 1)
	{
		for(local.i = 1; local.i <= self.passengers.size; local.i++)
		{
			if(self.passengers[local.i] != NIL && self.passengers[local.i] != NULL)
			{
				if(self.shooter != NIL)
				{
					self.passengers[local.i] takedamage
					if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.passengers[local.i] damage self.shooter.player_owner 9999999 self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.passengers[local.i] damage self.shooter.owner 9999999 self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else if(self.shooter != NULL) { self.passengers[local.i] damage self.shooter 9999999 self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					self.passengers[local.i] nodamage
				}
				else { self.passengers[local.i] volumedamage 9999999 }
			}
		}
	}

	if(self.shooter != NIL)
	{
		if(self.driver != NIL)
		{
			self.driver takedamage
			if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.driver damage self.shooter.player_owner 9999999 self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.driver damage self.shooter.owner 9999999 self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			else if(self.shooter != NULL) { self.driver damage self.shooter 9999999 self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			self.driver nodamage
		}
	}
	else if(self.driver != NIL) { self.driver volumedamage 9999999 } // let's make sure the driver is dead.
end

mainreset local.desvehicle local.fire local.smoke local.fire2 local.smoke2:

	if(self.resettime == NIL || self.resettime <= 0) { end }

	local.name = self.name
	local.model = self.model
	local.origin = self.originold  // respawns the vehicle where it was destroyed, only by setting "thread main" origin/angles to "local.origin" "local.angles".
	local.angles = self.angles
	local.health = level.boat_inithealth[self.name]
	local.boatspeed = self.boatspeed_max
	local.resettime = self.resettime
	local.scale = self.scale

	while(self != NULL) { waitframe }
	wait local.resettime

	if(local.fire != NIL && local.fire != NULL) { local.fire remove }
	if(local.smoke != NIL && local.smoke != NULL) { local.smoke remove }
	if(local.fire2 != NIL && local.fire2 != NULL) { local.fire2 remove }
	if(local.smoke2 != NIL && local.smoke2 != NULL) { local.smoke2 remove }
	local.desvehicle remove
	thread main local.name local.model level.boat_initorigin[local.name] level.boat_initangles[local.name] local.health local.boatspeed local.resettime local.scale
end

////////////////////////////////////////////////////////////////////////

passengers:
	
	local.player = parm.other
	local.team = local.player.dmteam
	waitframe	// need this here, otherwise driver & passenger could be attached to the same seat!

	if(local.player == NIL || local.player == NULL || !isalive local.player || local.player.dmteam != local.team || local.player == self.driver || local.player == self.turretplayer || local.player.passenger == 1 || local.player.driving == 1 || local.player.flying == 1 || local.player.dead == 1 || level.change_team_score == 1 || level.bbactive == 0) { end }

	for(local.s = 1; local.s <= self.seats; local.s++)
	{
		if(self.passengers[local.s] == NIL) { self.passengers[local.s] = local.player; break } // assign player to the 1st available passenger seat
	}
	if(local.s > self.seats) { end } // no seats available.

	if(local.player.dmteam != self.driver.dmteam && local.player.dmteam != "spectator" && getcvar("g_gametype") != "1")
	{
		self.passengers[local.s] = NIL
		local.player iprint ("An enemy player is driving this vehicle!")
		end
	}

	if(self.dist_offset[local.s] == NIL) { end }
	local.distoffset = self.dist_offset[local.s]
	local.outheight = 150

	local.player take "models/items/binoculars.tik" // using these will cause camera jittering again.
	local.player forcetorsostate VEHICLE_PASSENGER // prevents camera jittering.
	local.player forcelegsstate STAND
	//local.player hide
	//local.player noclip
	local.player nodamage // keep this off until the player receives damage, then quickly do "takedamage" and give damage, before doing "nodamage" again in "healthboost" thread (allows for more damage types such as bazooka rockets to count as kills).
	local.player notsolid // need this, otherwise vehicles cannot reverse properly.
	local.player iprint ("Press JUMP = exit vehicle. Hold FIRE(zoom) = look around.")
	local.player.origin = self.origin
	local.player.passenger = 1
	local.player.ridingent = self
	local.player.driving = 1 // should help with other scripts.
	local.player.driving_state_jump = 0
	local.PI = 3.14159265359
	local.driver = self.driver

	while(self != NULL && isalive self.driver && self.driver.dmteam == local.team && self.driver.dead != 1 && isalive local.player && local.player.dmteam == local.team && local.player.dead != 1 && level.change_team_score != 1 && level.bbactive != 0)
	{
		local.player anim unarmed_stand_idle // need this, since VEHICLE_PASSENGER state uses "movetype anim" instead of "movetype legs", which omits all legs animations (player will landshark without this).

		local.degrees = self.angles[1] + 180 + self.degree_offset[local.s] // 180 degrees added in "local.degrees" to find origin of passenger's seat, instead of driver's seat.
		if(local.degrees >= 180) { local.degrees = local.degrees - 360 }
		local.radians = local.degrees * (local.PI / 180)
		local.sin = (sin local.radians) * self.dist_offset[local.s]
		local.cos = (cos local.radians) * self.dist_offset[local.s]

		if(self.driver.driving_state_backward == 1) { local.direction = -1 }
		else { local.direction = 1 }
		if(self.velocity != ( 0 0 0 ))
		{
			local.player.origin = self.origin + ( local.cos local.sin self.height_offset[local.s] ) + self.forwardvector * self.boatspeed * .075 * local.direction
		}
		else { local.player.origin = self.origin + ( local.cos local.sin self.height_offset[local.s] ) }

		if(local.player.fireheld != 1)
		{
			if(self.playerang_offset[local.s] != NIL) { local.player.viewangles = ( 0 self.angles[1] self.angles[2] ) + ( 0 self.playerang_offset[local.s] 0 ) } // some vehicles' passengers should not face forward (view is blocked)
			else { local.player.viewangles = ( 0 self.angles[1] self.angles[2] ) }
		}

		if(local.player.driving_state_jump == 1) // Press JUMP to exit vehicle.
		{
			if(local.player.isdog != 1) { local.player show }
			local.player give "models/items/binoculars.tik"
			local.player solid
			local.player takedamage
			//local.player noclip
			local.player forcetorsostate STAND
			local.player.origin += angles_toforward( self.angles[0] (self.angles[1] + 180 + self.degree_offset[local.s]) self.angles[2] ) * (self.dist_offset[local.s]) + (angles_toup self.angles * local.outheight)
			local.player.viewangles = ( local.player.viewangles[0] local.player.viewangles[1] 0 )

			local.player thread wallstuck_fix
			self.passengers[local.s] = NIL
			local.player.passenger = 0
			local.player.ridingent = NIL
			local.player.driving = 0
			end
		}
		waitframe
	}
	if(self != NULL) { self.passengers[local.s] = NIL }

	if(local.player != NULL)
	{
		local.player.viewangles = ( 0 local.player.viewangles[1] 0 ) // passenger reset
		local.player.passenger = 0
		local.player.ridingent = NIL
		local.player.driving = 0
		if(local.player.dmteam != spectator)
		{
			if(isalive local.player) { local.player give "models/items/binoculars.tik" }
			if(local.player.isdog != 1) { local.player show }
			local.player solid
			local.player takedamage
			//local.player noclip
			local.player forcetorsostate STAND
			if(local.player.dmteam == local.team) // if the passenger did not switch teams
			{
				local.sin = local.sin / local.distoffset * 25 // when all passengers get out at the same time, make sure they're spaced out a few more units
				local.cos = local.cos / local.distoffset * 25
	
				if(self != NULL) { local.player.origin += angles_toforward( self.angles[0] (self.angles[1] + 180 + self.degree_offset[local.s]) self.angles[2] ) * (self.dist_offset[local.s]) + (angles_toup self.angles * local.outheight) }
				else { local.player.origin += ( local.cos local.sin local.outheight ) }
				local.player.viewangles = ( local.player.viewangles[0] local.player.viewangles[1] 0 )
				local.player thread wallstuck_fix

				if(local.driver != NULL && (!isalive local.driver || local.driver.dead == 1))
				{
					if(self != NULL && self.shooter != NIL)
					{
						if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { local.player damage self.shooter.player_owner 9999999 self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
						else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { local.player damage self.shooter.owner 9999999 self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
						else { local.player damage self.shooter 9999999 self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					}
					else { local.player damage $world 9999999 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
				}
			}

			local.origin = local.player.origin
			while(local.player != NULL && !isalive local.player && local.player.dmteam != "spectator")
			{
				local.player.origin = ( local.origin[0] local.origin[1] local.player.origin[2] ) // for some reason, passengers' dead bodies would move forward across the ground until they hit a wall.
				local.player notsolid
				local.player droptofloor
				waitframe
			}
		}
	}
end

////////////////////////////////////////////////////////////////////////

firegun:

	if(self.firing_gun == 1) { end }
	self.firing_gun = 1

	self thread projectile
	self playsound uboat_snd_fire //panzerschrecksndfire
	self playsound uboat_reload

	self.boatsmokecount = 0
	self thread smokey

	wait 5
	if(self != NULL) { self.firing_gun = 0 }
end

firesecondary:

	if(self.firing_gun2 == 1) { end }
	self.firing_gun2 = 1

	self thread projectile 1
	self playsound grenadethrow

	wait 1
	if(self != NULL) { self.firing_gun2 = 0 }
end

smokey:

	self.boatsmoking = 1
	local.targetname = self.targetname
	local.boatsmokecount = self.boatsmokecount

	local.smoke = spawn script_model
	local.smoke model "fx/fx_cannonsmoke.tik"
	self.gun = $(self.name + "_tag_barrel")
	local.smoke.origin = self.gun.origin

	while(self != NULL && self.boatsmokecount < 120)
	{
		local.smoke.origin = self.gun.origin
		self.boatsmokecount++
		local.boatsmokecount = self.boatsmokecount
		waitframe
	}

	local.c = 0
	while($(local.targetname) == NULL) // boat is always removed after a player exits the boat, wait for the boat to respawn before continuing smokecount
	{
		if(local.c >= 10) // remove the smoke sooner if the boat was destroyed
		{
			if(local.smoke != NULL) { local.smoke remove }
			end
		}
		local.c++
		waitframe
	}

	$(local.targetname).boatsmoking = 1
	$(local.targetname).boatsmokecount = local.boatsmokecount
	$(local.targetname).gun = $(local.targetname + "_tag_barrel")

	while($(local.targetname) != NULL && $(local.targetname).gun != NULL && $(local.targetname).boatsmokecount != NIL && $(local.targetname).boatsmokecount < 120)
	{
		local.smoke.origin = $(local.targetname).gun.origin
		$(local.targetname).boatsmokecount++
		waitframe	
	}

	if(local.smoke != NULL) { local.smoke remove }
	if($(local.targetname) != NULL) { $(local.targetname).boatsmoking = 0; $(local.targetname).boatsmokecount = 0 }
end

projectile local.secondary:

	local.player = self.driver // used for the for-loop later
	self.gun = $(self.name + "_tag_barrel")

	local.projectile = spawn script_model
	if(local.secondary == 1)
	{
		if(local.player.dmteam == "axis") { local.projectile model "projectiles/steilhandgranate_primary.tik" }
		else { local.projectile model "projectiles/M2FGrenade_primary.tik" }
	}
	else { local.projectile model "projectiles/tigercannonshell.tik" } // "projectiles/panzerschreckshell.tik"
	local.projectile.origin = self.gun.origin
	local.projectile light 0 1 0 400
	local.projectile.scale = 1
	local.projectile solid
	local.projectile physics_on    // need this for gravity and waittill touch to work.
	local.projectile.scale = 3

	if(self != NULL) { local.projectile.player_owner = self.driver }

	if(local.secondary == 1)
	{
		local.projectile playsound grenadethrow
		local.projectile.angles = ( -90 self.angles[1] 0 )
		local.projectile thread rotate

		local.projectile gravity .8
		local.fwd_vec = angles_toforward ( 0 self.angles[1] 0 )
		local.projectile.velocity = ( local.fwd_vec[0] local.fwd_vec[1] .500 ) * 950 // local.fwd_vec[2] = .500 = 45 degrees facing upward
	}
	else
	{
		local.projectile loopsound rocketfireloop
		local.projectile.angles = ( self.turretlaser_offset (self.angles[1] + 180) 0 )

		local.projectile gravity 0
		local.projectile.velocity = (angles_toforward ( (self.angles[0] + self.turretlaser_offset) self.angles[1] self.angles[2] )) * 6000
	}

	if(local.secondary == 1) { wait 3 }
	else
	{
		local.hitthing = self
		while(local.hitthing == self || (self != NULL && local.hitthing == self.gun))
		{
			local.projectile waittill touch
			local.hitthing = parm.other
		}
	}

	local.projectile.velocity = ( 0 0 0 )
	local.explode = spawn "fx/explosionTIGERshell.tik" // "fx/explosionPANZERIVshell.tik"
	local.explode.origin = local.projectile.origin
	local.explode.scale = 1
	local.explode light 1 0 0 600
	local.explode anim idle
	//local.explode playsound bazooka_exp // already included in explosionPANZERIVshell

	if(self != NULL && local.projectile istouching self) { local.blewup = 0 }
	else { local.blewup = 1 }

	for(local.i = 1; local.i <= $player.size; local.i++) // use this instead of radiusdamage, so rockets can count as score/kills
	{
		if(vector_length(local.explode.origin - $player[local.i].origin) <= 500) // without "cansee", these rockets can kill people through walls
		{
			if(local.player == NIL || local.player == NULL)
			{
				if($player[local.i].driving != 1 && $player[local.i].flying != 1 && $player[local.i] cansee local.projectile 360)
				{
					$player[local.i] damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 1 15 -1
				}
				else if($player[local.i].drivingent != NIL && $player[local.i].drivingent != NULL)
				{
					if($player[local.i].flying == 1) { $("planehit" + $player[local.i].entnum) damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 1 15 -1 }
					else { $player[local.i].drivingent damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 1 15 -1 }
				}
			}
			else if($player[local.i] != local.player && $player[local.i].dmteam == local.player.dmteam && getcvar("g_teamdamage") != "1" && getcvar("g_gametype") != "1") { local.blewup = 0 }
			else
			{
				if($player[local.i].driving != 1 && $player[local.i].flying != 1 && $player[local.i] cansee local.projectile 360)
				{
					$player[local.i] damage local.player 500 local.player (0 0 0) (0 0 0) (0 0 0) 0 1 15 -1 // "damage" does not hurt teammates, but scriptbazookaexplosion.tik does
				}
				else if($player[local.i].drivingent != NIL && $player[local.i].drivingent != NULL)
				{
					$player[local.i].drivingent.shooter = local.player
					if($player[local.i].flying == 1) { $("planehit" + $player[local.i].entnum) damage local.player 500 local.player (0 0 0) (0 0 0) (0 0 0) 0 1 15 -1 }
					else { $player[local.i].drivingent damage local.player 500 local.player (0 0 0) (0 0 0) (0 0 0) 0 1 15 -1 }
				}
			}
		}
	}
	local.projectile remove
	if(local.blewup == 1) { radiusdamage local.explode.origin 500 500 } // 110 200
	waitframe
	wait .2 // keeps the explosion light visible longer
	local.explode remove
end

rotate:

	while(self != NULL && self.velocity != ( 0 0 0 ))
	{
		self.angles = (self.angles + ( 3 0 0 ))
		waitframe
	}
end

turret_laser local.name:

	local.laser = spawn func_beam
	local.laser minoffset 0
	local.laser maxoffset 0
	local.laser numsegments 1
	local.laser life 0
	local.laser color ( 1 0 0 )
	local.laser alpha .4
	local.laser alwaysdraw
	local.laser deactivate	
	local.laser scale 1.0
	local.laser notsolid
	local.laser.origin = $(local.name + "_tag_barrel").origin
	local.laser endpoint $(local.name + "_tag_barrel").origin
	self.turretlaser = local.laser

	while(self != NULL) { waitframe }
	local.laser remove
end

////////////////////////////////////////////////////////////////////////

seatstuff:

	if(self.model == "models/vehicles/higginsxtrahull.tik")
	{
		self.seats = 9

		self.degree_offset[1] = 25.796		// [1] = front passenger. [2] = back right, [3], [4], [5] = front right. [6] = front left, [7], [8], [9] = back left
		self.dist_offset[1] = 133.282
		self.height_offset[1] = 50

		self.degree_offset[5] = 170.198 // very front right
		self.dist_offset[5] = 218.976
		self.height_offset[5] = 50
		self.degree_offset[4] = 137.859
		self.dist_offset[4] = 163.920
		self.height_offset[4] = 50
		self.degree_offset[3] = 142.595
		self.dist_offset[3] = 63.107
		self.height_offset[3] = 50
		self.degree_offset[2] = 51.896
		self.dist_offset[2] = 48.277
		self.height_offset[2] = 50 // back right

		self.degree_offset[6] = -168.554 // very front left
		self.dist_offset[6] = 218.308
		self.height_offset[6] = 50
		self.degree_offset[7] = -161.461
		self.dist_offset[7] = 136.358
		self.height_offset[7] = 50
		self.degree_offset[8] = -136.768
		self.dist_offset[8] = 63.300
		self.height_offset[8] = 50
		self.degree_offset[9] = -54.647
		self.dist_offset[9] = 53.714
		self.height_offset[9] = 50 // back left
	}
	if(self.model == "models/vehicles/uboat.tik")
	{
		self.seats = 5

		self.degree_offset[1] = 22.158		// [1], [2] = right, left front captain platform, [3] = back of captain platform, [4], [5] = right side (facing forward), left side of middle platform
		self.dist_offset[1] = 120
		self.height_offset[1] = 322
		self.degree_offset[2] = -22.158
		self.dist_offset[2] = 120
		self.height_offset[2] = 322

		self.degree_offset[3] = 0
		self.dist_offset[3] = 270
		self.height_offset[3] = 322
		self.playerang_offset[3] = 180	// this keeps the passenger facing 180 behind the driver's angles by default

		self.degree_offset[4] = 10
		self.dist_offset[4] = 413
		self.height_offset[4] = 235
		self.playerang_offset[4] = -90
		self.degree_offset[5] = -10
		self.dist_offset[5] = 413
		self.height_offset[5] = 235
		self.playerang_offset[5] = 90
	}
end
			// run "exec global/playerboat.scr::test boat_01" in any map .scr script, or any boat's targetname other than "boat_01". make sure the boat's angles is ( 0 0 0 )
test local.targetname:	// player[1] can now stand anywhere on the boat and easily calculate the desired passenger seat's "degree_offset" and "dist_offset" for the "seatstuff" thread.

	while($player.size < 1) { waitframe }
	while($player.size >= 1)
	{
		if($(local.targetname) == NULL) { wait 2; iprintlnbold("$" + local.targetname + " = NULL"); println("$" + local.targetname + " = NULL"); break }

		local.v1 = ( $(local.targetname).origin[0] $(local.targetname).origin[1] 0 )
		local.v2 = ( $player[1].origin[0] $player[1].origin[1] 0 )

		local.v = vector_length(local.v1 - local.v2)
		local.a = vector_toangles(local.v1 - local.v2)
		if($(local.targetname).model != "models/vehicles/uboat.tik") { local.a2 = local.a[1] + 180 }
		else { local.a2 = local.a[1] }
		if(local.a2 >= 180) { local.a2 -= 360 }

		iprintlnbold("degree = " + local.a2 + " ... dist = " + local.v)
		wait 2
	}
	thread test local.targetname
end

////////////////////////////////////////////////////////////////////////

dummyavatar:

	local.avatar = spawn func_beam
	local.avatar attach self.driver "Bip01 Head"
	local.avatar.origin = self.driver.origin + ( 0 0 100 )
	local.avatar endpoint (local.avatar.origin + ( 0 0 13 ))
	local.avatar minoffset 0
	local.avatar maxoffset 0
	local.avatar color ( 1 1 1 )
	local.avatar scale 7.0
	local.avatar life 0
	if(self.driver.dmteam == "allies") { local.avatar shader ("textures/hud/allies_headicon") }
	if(self.driver.dmteam == "axis") { local.avatar shader ("textures/hud/axis_headicon") }
	local.avatar numsegments 1
	local.avatar alpha .80
	local.avatar activate
	local.heightinc = 0

	self.driver show
	local.team = self.driver.dmteam
	while(self != NULL && isalive self.driver && self.driver.dmteam == local.team && self.driver.dead != 1 && level.change_team_score != 1 && level.bbactive != 0)
	{
		local.avatar.origin = self.driver.origin + ( 0 0 (100 + local.heightinc) )
		local.avatar endpoint (local.avatar.origin + ( 0 0 13 ))
		waitframe
	}
	local.avatar remove
end

////////////////////////////////////////////////////////////////////////

wallstuck_fix:

	local.c = 0
	local.origin = self.origin
	local.team = self.dmteam

	if(self.wallstuck_fixing == 1) { end }
	self.wallstuck_fixing = 1

	while(self != NULL && isalive self && self.dmteam == local.team) // while player is stuck in a wall (falling) and origin isn't changing, count a few seconds, then respawn the player
	{
		if(local.c >= 60) // about 3 seconds
		{
			if((self getmovement) == falling && self.origin == local.origin) { self respawn }
			if(self.isdog == 1) { self hide }
			break
		}
		local.c++
		waitframe
	}
	if(self != NULL) { self.wallstuck_fixing = 0 }
end

////////////////////////////////////////////////////////////////////////

boatstuck_inwall_fix:

	while(self != NULL)
	{
		if((self.angles[0] <= 340 && self.angles[0] >= 20) || (self.angles[2] <= 340 && self.angles[2] >= 20))
		{
			killent self.entnum
			break
		}
		waitframe
	}
end

////////////////////////////////////////////////////////////////////////

touching_playerboat local.vehicles:

	level.touching_playerboat = 1

	if(local.vehicles == NIL) // only run once when map starts. leave local.vehicles = NIL or empty at first.
	{
		local.a = 0
		for(local.e = 0; local.e <= 868; local.e++)
		{
			local.entity = getentity(local.e)
			if(local.entity != NULL && local.entity.classname == DrivableVehicle && local.entity.model == "models/vehicles/higginsxtrahull.tik")
			{
				local.vehicles[local.a] = local.entity.targetname
				local.a++
			}
			if(local.e % 14 == 0) { waitframe }
		}
		if(local.vehicles.size < 1) { end }
	}

	while($player.size < 1) { waitframe }
	while($player.size >= 1)
	{
		for(local.i = 1; local.i <= $player.size; local.i++)
		{
			$player[local.i].touching_playerboat = 0 // ensures that only one boat needs to be touched for touching_playerboat = 1.
		}

		for(local.a = 0; local.a <= local.vehicles.size; local.a++)
		{
			for(local.s = 1; $(local.vehicles[local.a]) != NULL && local.s <= $(local.vehicles[local.a]).size; local.s++) // sometimes, two vehicles with the same targetname can exist
			{													// for 1 or 2 frames. this for-loop prevents any console errors.
				for(local.i = 1; local.i <= $player.size; local.i++)
				{
					if($player[local.i] istouching $(local.vehicles[local.a])[local.s]) { $player[local.i].touching_playerboat = 1 }
				}
			}
		}
		waitframe
	}

	thread touching_playerboat local.vehicles
end

////////////////////////////////////////////////////////////////////////

removeclass_camera:

	level.removeclass_camera = 1
	while(1)
	{
		for(local.e = 0; local.e <= 868; local.e++)
		{
			local.entity = getentity(local.e)
			if(local.entity != NULL && local.entity.classname == "Camera" && local.entity.targetname == "") { local.entity remove }
			waitframe
		}
		waitframe
	}
end

////////////////////////////////////////////////////////////////////////

display:

	if(game.game != "AA") { local.menu1 = "bastogne1"; local.menu2 = "bastogne2" }
	else { local.menu1 = "dday1"; local.menu2 = "dday2" }

	self stufftext ("globalwidgetcommand " + local.menu1 + " shader townhallwindow")
	self stufftext ("globalwidgetcommand " + local.menu1 + " fgcolor 1.00 1.00 1.00 1.00")
	self stufftext ("globalwidgetcommand " + local.menu1 + " bgcolor 0.50 0.50 0.50 0.00")
	self stufftext ("globalwidgetcommand " + local.menu1 + " fadein 0")
	self stufftext ("globalwidgetcommand " + local.menu1 + " menu " + local.menu1 + " 640 480 NONE 0")
	self stufftext ("globalwidgetcommand " + local.menu1 + " virtualres 1")
	self stufftext ("globalwidgetcommand " + local.menu1 + " fullscreen 1")

	self stufftext "globalwidgetcommand june6 borderstyle NONE"
	self stufftext "globalwidgetcommand june6 shader textures/hud/healthback"
	self stufftext "globalwidgetcommand june6 rect 16 420 16 64"
	self stufftext "globalwidgetcommand june6 fgcolor 1.00 1.00 1.00 1.00"
	self stufftext "globalwidgetcommand june6 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand june6 linkcvar phealth"
	self stufftext "globalwidgetcommand june6 statbar vertical 0 100"
	self stufftext "globalwidgetcommand june6 statbar_shader textures/hud/healthmeter"
	self stufftext "globalwidgetcommand june6 statbar_shader_flash textures/hud/healthmeterflash"

	self stufftext ("globalwidgetcommand " + local.menu2 + " fgcolor 1.00 1.00 1.00 1.00")
	self stufftext ("globalwidgetcommand " + local.menu2 + " bgcolor 0.50 0.50 0.50 0.00")
	self stufftext ("globalwidgetcommand " + local.menu2 + " fadein 0")
	self stufftext ("globalwidgetcommand " + local.menu2 + " menu " + local.menu2 + " 640 480 NONE 0")
	self stufftext ("globalwidgetcommand " + local.menu2 + " virtualres 1")
	self stufftext ("globalwidgetcommand " + local.menu2 + " fullscreen 1")

	self stufftext "globalwidgetcommand charliesector borderstyle NONE"
	self stufftext "globalwidgetcommand charliesector textalign left "
	self stufftext "globalwidgetcommand charliesector rect 40 470 150 20"
	self stufftext "globalwidgetcommand charliesector fgcolor 0.70 0.60 0.05 1.00"
	self stufftext "globalwidgetcommand charliesector bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand charliesector linkcvar phealth"
	self stufftext "globalwidgetcommand charliesector font facfont-20"
	self stufftext "globalwidgetcommand charliesector shader townhallwindow"

	self stufftext ("showmenu " + local.menu2)
	self stufftext ("showmenu " + local.menu1)
	self stufftext "set phealth 100"
end

////////////////////////////////////////////////////////////////////////

scriptmaster local.model:

level.mapname = getcvar "mapname"
local.master = spawn scriptmaster

if(level.boatscriptmaster != 1)
{
	local.master aliascache wavelaps sound/amb/Wave_Laps1.wav soundparms 1 0 1 0 200 4000 auto loaded maps level.mapname
	local.master aliascache riverdrive sound/amb/Amb_River.wav soundparms 2.0 0 1 0 200 4000 auto loaded maps level.mapname
	local.master aliascache impact_leavewater sound/null.wav soundparms .7 .4 1 .5 100 1600 auto loaded maps level.mapname
}

if(level.boatscriptmaster2 != 1 && local.model == "models/vehicles/uboat.tik")
{
	local.master aliascache rocketfireloop sound/amb/Amb_FirePlace.wav soundparms 2.0 0 1 0 400 5000 auto loaded maps level.mapname
	local.master aliascache grenadethrow sound/weapons/foley/Grenade_Throw.wav soundparms .9 .2 .8 .2 400 5000 weapon loaded maps level.mapname
	//local.master aliascache panzerschrecksndfire sound/weapons/fire/PanzershrekFire2.wav soundparms 1.5 0 .92 .15 500 9000 weapon loaded maps level.mapname

	local.master aliascache uboat_reload sound/weapons/fire/TankFire1.wav soundparms 1.5 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache uboat_snd_fire1 sound/weapons/fire/TankCannonFire1.wav soundparms 1.5 0 1 0 2000 5000 weapon loaded maps level.mapname
	local.master aliascache uboat_snd_fire2 sound/weapons/fire/Flak88Fire1.wav soundparms 1.5 0 1 0 2000 5000 weapon loaded maps level.mapname
	local.master aliascache uboat_snd_fire3 sound/weapons/fire/Flak88Fire3.wav soundparms 1.5 0 1 0 2000 5000 weapon loaded maps level.mapname
	local.master aliascache uboat_snd_fire4 sound/weapons/fire/Flak88Fire4.wav soundparms 1.5 0 1 0 2000 5000 weapon loaded maps level.mapname
	level.boatscriptmaster2 = 1
}

local.soundtype = 2
if(level.vehiclescriptmaster[local.soundtype] != NIL) { end }
level.vehiclescriptmaster[local.soundtype] = 1

if(local.soundtype == 2 && level.mapname != "training" && level.mapname != "m3l3" && level.mapname != "m5l2a")
{
	local.master aliascache sdkfz_snd_idle sound/vehicle/veh_track_idle.wav soundparms .5 0 1 0 800 4000 auto loaded maps level.mapname
}

if(local.soundtype == 2 && level.mapname != "m3l3" && level.mapname != "m5l2a")
{
	local.master aliascache sdkfz_snd_run sound/vehicle/veh_track_move.wav soundparms 1.5 0 1 0 1000 6000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_revup sound/vehicle/veh_track_revup.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_revdown sound/vehicle/veh_track_revdown.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_shift1 sound/vehicle/veh_track_shiftin.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_shift2 sound/vehicle/veh_track_shiftout.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_on sound/vehicle/veh_track_on.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_start sound/vehicle/veh_track_on.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_off sound/vehicle/veh_track_off.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_stop sound/vehicle/veh_track_off.wav soundparms 1.5 0 1 0 1000 6000 auto loaded maps level.mapname
	local.master aliascache sdkfz_tread_snd_dirt sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_tread_snd_stone sound/vehicle/veh_tread_metal.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_tread_snd_grass sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_tread_snd_wood sound/vehicle/veh_tread_metal.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_tread_snd_mud sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_doorclose sound/null.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_dooropen sound/null.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
}

if(local.soundtype == 2 && level.mapname != "m3l3" && level.mapname != "m5l2a" && level.mapname != "m5l2b")
{
	local.master aliascache sdkfz_vehicle_crash1 sound/null.wav soundparms .7 .4 1 .5 100 1600 auto loaded maps level.mapname
}

if(level.vehiclescriptmaster2 != 1 && level.mapname != "m1l3a" && level.mapname != "m1l3b" && level.mapname != "m4l1")
{
	local.master aliascache explode_truck1 sound/weapons/explo/Explo_MetalMed1.wav soundparms 1.2 .2 .8 .2 1500 8000 weapon loaded maps level.mapname
}

if(level.vehiclescriptmaster2 != 1 && level.mapname != "m1l3a" && level.mapname != "m1l3b")
{
	local.master aliascache explode_truck2 sound/weapons/explo/Explo_MetalMed2.wav soundparms 1.2 .2 .8 .2 1500 8000 weapon loaded maps level.mapname
	local.master aliascache explode_truck3 sound/weapons/explo/Explo_MetalMed3.wav soundparms 1.2 .2 .8 .2 1500 8000 weapon loaded maps level.mapname
	local.master aliascache explode_truck4 sound/weapons/explo/Explo_MetalMed4.wav soundparms 1.2 .2 .8 .2 1500 8000 weapon loaded maps level.mapname
	local.master aliascache explode_truck5 sound/weapons/explo/Explo_MetalMed5.wav soundparms 1.2 .2 .8 .2 1500 8000 weapon loaded maps level.mapname
}

if(level.vehiclescriptmaster2 != 1 && level.mapname != "m5l1a" && level.mapname != "m5l1b" && level.mapname != "m5l2a" && level.mapname != "m5l2b" && level.mapname != "m5l3")
{
	local.master aliascache damage_vehicle1 sound/null.wav soundparms .7 .4 .9 .2 160 1600 auto loaded maps level.mapname
}

if(level.vehiclescriptmaster3 != 1)
{
	local.master aliascache sndfire30cal sound/weapons/fire/50CalFire2.wav soundparms 1.05 .2 .95 .1 800 4000 weapon loaded maps level.mapname

	local.master aliascache vehicledeathfire sound/amb/fire.wav soundparms 1.2 0.0 1.0 0.0 200 2000 auto loaded maps level.mapname
	local.master aliascache vehicledeathwater sound/mechanics/Mec_WaterLoop_03.wav soundparms 1.2 0.0 1.0 0.0 200 2000 auto loaded maps level.mapname
}

level.boatscriptmaster = 1
level.vehiclescriptmaster2 = 1
level.vehiclescriptmaster3 = 1
end
