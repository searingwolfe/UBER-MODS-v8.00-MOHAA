main local.name local.model local.origin local.angles local.health local.resettime local.gotout local.groundtarget:

	if(local.model == NIL) { wait 1; println("----- ERROR playertank.scr: 'model' parameter is missing!"); end }
	if(local.model[0] != "m" && local.model[1] != "o" && local.model[2] != "d" && local.model[3] != "e" && local.model[4] != "l" && local.model[5] != "s")
	{
		local.model = "models/" + local.model
		if(level.tankscriptmaster[local.model] != 1) { cache local.model }
	}

	if($(local.name) != NULL) 
	{
		waitframe; if($(local.name) != NULL) { waitframe; if($(local.name) != NULL) { waitframe; if($(local.name) != NULL) { waitframe; if($(local.name) != NULL) { waitframe } } } }
		if($(local.name) != NULL)
		{
			if(level.tankscriptmaster[local.model] != 1) { wait 1; println("----- ERROR playertank.scr: $" + local.name + " must be removed before spawning a drivable tank.") }
			end
		}
	}

	if(local.health == NIL || (local.health != NIL && local.health <= 0 && level.tankscriptmaster[local.model] != 1)) { wait 1; println("----- ERROR playertank.scr: health must be greater than 0."); end }
	if(local.health == NIL || (local.health != NIL && local.health <= 0 && level.tankscriptmaster[local.model] == 1)) { end } // end when in rare cases, a 2nd tank with local.health = 0 could spawn after getting destroyed

	local.tank = spawn local.model targetname (local.name) // scriptmasters are already added in ubersound.scr
	local.tank.name = local.name
	local.tank.origin = local.origin
	local.tank.originold = local.origin
	local.tank.angles = local.angles
	local.tank.health = local.health
	//local.tank.vehiclespeed = local.vehiclespeed // tank speed parameter still does not work, since tank's velocity takes forever to fully reach ( 0 0 0 ), even after the tank has stopped
	local.tank.resettime = local.resettime

	if(local.tank.classname != "VehicleTank") { local.tank remove; wait 1; println("----- ERROR playertank.scr: .tik model is not a VehicleTank."); end }

	local.tank thread tank_settings local.gotout // gotout playsound, desmodel, outheight, etc.
	local.tank thread tankreset local.groundtarget
	local.tank thread tankdamage
	local.tank thread tankdeath
	local.tank thread tanktrigger
	local.tank thread move_stuck_players // the vehicle might respawn on top of other players, move them onto the top of it.

	if(level.tank_initorigin[local.name] == NIL) { level.tank_initorigin[local.name] = local.origin } // store the initial origin/angles as level variable arrays
	if(level.tank_initangles[local.name] == NIL) { level.tank_initangles[local.name] = local.angles }
	if(level.tank_inithealth[local.name] == NIL) { level.tank_inithealth[local.name] = local.health }
	local.tank thread tankdamagesmoke

	if(level.remove_viewmodels != 1) { thread remove_viewmodels }
	level.remove_viewmodels = 1

	if(level.chainreactors == NIL || (level.chainreactors != NIL && level.chainreactors.size < 1)) { level.chainreactors[1] = local.tank }
	else
	{
		for(local.c = 1; local.c <= 999; local.c++)
		{
			if(level.chainreactors[local.c] == NIL)
			{
				level.chainreactors[local.c] = local.tank
				local.tank thread chainreactors_remove local.c
				break
			}
		}
	}

	if(level.drivable_entities == NIL) { level.drivable_entities[1] = local.name }
	else
	{
		for(local.d = 1; local.d <= level.drivable_entities.size; local.d++)
		{
			if(level.drivable_entities[local.d] == local.name) { end }
		}
		level.drivable_entities[level.drivable_entities.size + 1] = local.name
	}
end

chainreactors_remove local.c:

	while(self != NULL) { waitframe }
	level.chainreactors[local.c] = NIL
end

////////////////////////////////////////////////////////////////////////

tankreset local.groundtarget: // tank turret must be reset each time a new tank spawns (after player exits), otherwise turret will not shoot projectiles.

	self fullstop
	self anim idle // doesn't stop tank treads from moving server-side, only client-side.

	self.gun = self queryturretslotentity 0
	if(self.gun == NIL || self.gun == NULL) { self spawnturret 0 self.turretmodel }
	self.gun = self queryturretslotentity 0
	self.gun solid
	self.gun.tank = self

	self.gun2 = self queryturretslotentity 1
	if(self.gun2 != NIL && self.gun2 != NULL)
	{
		if(self.gun2.model != "models/vehicles/jeep_30cal.tik")
		{
			self.gun2 remove
			self spawnturret 1 "models/vehicles/jeep_30cal.tik"
			self.gun2 = self queryturretslotentity 1
		}
		self.gun2 notsolid
		self.gun2 pitchcaps ( -60 35 0 )
		self.gun2.scale = 0.5
	}
	self.gun dmprojectile projectiles/tigercannonshell.tik // keep this before any waitframes, otherwise it won't work
	
	if(local.groundtarget == NIL || local.groundtarget == NULL) { wait 1 } // only wait after map initially loads, for turret to get attached to tank after level waittill spawn.
	local.fwd_vec = angles_toforward self.angles
	local.groundtarget_gun2 = spawn script_origin
	local.gun2origin = self gettagposition "turret0"
	local.groundtarget_gun2.origin = trace (local.gun2origin + local.fwd_vec * 56) (local.gun2origin + local.fwd_vec * 10240) 0

	waitframe // need this for setaimtarget to work properly
	if(self != NULL)
	{
		if(local.groundtarget != NIL && local.groundtarget != NULL)
		{
			self.gun turnspeed 9999
			self.gun setaimtarget local.groundtarget
		}
		if(self.gun2 != NIL && self.gun2 != NULL) { self.gun2 setaimtarget local.groundtarget_gun2 }
	}

	waitframe
	if(self != NULL && self.gun != NIL && self.gun != NULL && local.groundtarget != NIL && local.groundtarget != NULL)
	{
		if(self.gun != NIL && self.gun != NULL) { self.gun turnspeed 50 }
		local.groundtarget remove
	}
	local.groundtarget_gun2 remove
	//removeclass Camera // also removes PlayerIntermission and other func_cameras
	if(level.removeclass_camera != 1) { thread removeclass_camera } // when exiting any drivable tanks, a "Camera" entity is left behind (likely from the VehicleTurretGun); remove them to prevent Camera entities from building up over time.
end

tanktrigger:

	if($(self.name + "_trig") != NULL) { $(self.name + "_trig") remove }
	local.trig = spawn trigger_use targetname (self.name + "_trig")
	local.trig.origin = self.origin
	if(self.model != vehicles/kingtank.tik && self.model != models/vehicles/kingtank.tik) { local.trig setsize ( -110 -110 -5 ) ( 110 110 160 ) }
	if(self.model == vehicles/kingtank.tik || self.model == models/vehicles/kingtank.tik) { local.trig setsize ( -150 -150 -5 ) ( 150 150 180 ) }
	local.trig.tank = self
	local.trig glue self
	local.trig setthread triggered
end

triggered:

	local.player = parm.other
	if(local.player.classname != Player) { end }
	if(self.tank == NULL || self.tank.dead == 1 || local.player == NIL || local.player == NULL || local.player.enteringvehicle == 1 || !isalive local.player || local.player.dead == 1 || level.change_team_score == 1 || level.bbactive == 0 || local.player.driving == 1 || local.player.passenger == 1 || local.player.flying == 1 || local.player.missile != NIL || local.player.leanleftheld == 1 || local.player.leanrightheld == 1) { end }

	if(self.tank != NULL)
	{
		if(self.tank.driver != NIL)
		{
			if(self.tank.gun2 != NIL && self.tank.gun2 != NULL && (self.tank.turretplayer == NIL || self.tank.turretplayer == NULL))
			{
				self.tank thread turretslot_2nd local.player
				end
			}
		}
		else { self.tank thread playergetin }
	}
end

playergetin:

	local.player = parm.other
	if(local.player.classname != Player) { end }
	local.team = local.player.dmteam
	if(self.attachingdriver == 1) { end }
	self.attachingdriver = 1
	local.player.enteringvehicle = 1

	if(self.gun2 != NIL && self.gun2 != NULL) { local.player iprint "Entering tank... press FIRE to use turret." }

	if(self.turretplayer != NIL && self.turretplayer != NULL && (self.turretplayer.dmteam != local.player.dmteam || getcvar("g_gametype") == "1")) { local.cancel = 1 }
	if(local.cancel == 1)
	{
		local.player iprint "An enemy player is in this tank!"
		local.player.enteringvehicle = 0
		self.attachingdriver = 0
		end
	}

	local.player safeholster 1
	local.c = 0
	local.fireholding = 0
	while(self != NULL && local.player != NULL && local.c <= 20) // wait 1
	{
		if(local.player.fireheld != 1 && local.fireholding == 1 && self.gun2 != NIL && self.gun2 != NULL && (self.turretplayer == NIL || self.turretplayer == NULL))
		{
			local.player.enteringvehicle = 0
			self.attachingdriver = 0
			self thread turretslot_2nd local.player
			end
		}

		if(local.player.fireheld == 1) { local.fireholding = 1 }
		local.c++
		waitframe
	}

	if(self == NULL || self.flooded == 1 || self.dead == 1 || self.driver != NIL || local.player == NIL || local.player == NULL || !isalive local.player || local.player.dmteam != local.team || local.player.dead == 1 || level.change_team_score == 1 || level.bbactive == 0 || local.player.driving == 1 || local.player.passenger == 1 || local.player.flying == 1 || local.player.missile != NIL)
	{
		if(self != NULL) { self.attachingdriver = 0 }
		if(local.player != NULL) { local.player.enteringvehicle = 0 }
		end
	}
	if(local.player.leanleftheld == 1 || local.player.leanrightheld == 1)
	{
		if(self != NULL) { self.attachingdriver = 0 }
		local.player.enteringvehicle = 0
		local.player safeholster 0
		local.player iprint "You canceled entering tank by leaning left/right."
		end
	}
	if(local.player.isdog == 1)
	{
		if(self != NULL) { self.attachingdriver = 0 }
		local.player.enteringvehicle = 0
		local.player iprint ("Dogs cannot drive tanks.")
		end
	}
	if(local.player.fireheld == 1 && self.gun2 != NIL && self.gun2 != NULL && (self.turretplayer == NIL || self.turretplayer == NULL)) // enter 30_cal turret slot if still holding FIRE.
	{
		local.player.enteringvehicle = 0
		self.attachingdriver = 0
		self thread turretslot_2nd local.player
		end
	}

	self.driver = local.player
	self.driver.driving = 1
	self.driver.drivingent = self
	local.driver = self.driver
	self.player_owner = self.driver

	self.driver forcelegsstate STAND
	self.driver hide
	self.driver nodamage
	self.driver notsolid
	self.driver iprint ("JUMP = exit tank... Hold USE(e) for 3 seconds while not moving tank or turret = repair tank.")
	self.driver.driving_state_jump = 0
	if(local.player.fireheld == 1 && self.gun2 != NIL && self.gun2 != NULL) { local.player iprint "To use 30 Cal Turret: FIRE once, then let go of FIRE before entering vehicle." }

	self attachdriverslot 0 self.driver
	self thread dummyavatar
	local.groundtarget = spawn script_origin
	local.turretangles = self.gun.angles
	local.holdtime = 0

	if(self.driver.using_pack == 1)
	{
		self.driver stufftext "globalwidgetcommand june6 linkcvar phealth"
		self.driver stufftext ("globalwidgetcommand june6 statbar vertical 0 " + level.tank_inithealth[self.name] )
		self.driver stufftext "globalwidgetcommand charliesector linkcvar phealth"
		self.driver stufftext ("set phealth " + int(self.health))
	}
	else { self.driver thread display self }

	ihuddraw_alpha local.player 110 0
	ihuddraw_virtualsize local.player 110 1
	ihuddraw_alpha local.player 110 .8
	ihuddraw_font local.player 110 "verdana-12"
	ihuddraw_color local.player 110 .85 .85 0
	ihuddraw_rect local.player 110 330 222 200 14 
	ihuddraw_string local.player 110 "" // "Turret User:   0"
	local.turretuser_hud = 0
	local.turretuser_count = 0
	local.stufftext_c = 0

	local.player.enteringvehicle = 0
	self.attachingdriver = 0
	while(self != NULL && self.dead != 1 && self.flooded != 1 && isalive self.driver && self.driver.dmteam == local.team && self.driver.dead != 1 && level.change_team_score != 1 && level.bbactive != 0)
	{
		//if(self.velocity != ( 0 0 0 )) { self.velocity = self.velocity + self.forwardvector * self.vehiclespeed } // does not work properly, so speed increase was removed.

		local.fwd_vec = angles_toforward ( self.driver.viewangles[0] self.gun.angles[1] self.driver.viewangles[2] )
		local.start = self.gun gettagposition "tag_barrel"		// aim the groundtarget from where turret currently is, since turret rotation is slower than player's aim.
		local.groundtarget.origin = trace (local.start + local.fwd_vec * 56) (local.start + local.fwd_vec * 10240) 0

		if(self.driver.driving_state_jump == 1 || self.flooded == 1) // Press JUMP to exit, or force-exit if tank gets flooded by a Light Bomb exploding on it.
		{
			self thread driverreset
			self thread tankreset local.groundtarget
			self.driver thread wallstuck_fix
			self.driver stoploopsound
			self.driver = NIL
			break
		}
		else if(self.driving_state_forward != 1 && self.driving_state_backward != 1 && self.driving_state_left != 1 && self.driving_state_right != 1 && self.gun.angles == local.turretangles && self.health < level.tank_inithealth[self.name])
		{
			if(self.driver.useheld == 1) { local.holdtime++ }
			if(local.holdtime >= 30)
			{
				self.health += 1.5	// if the tank is not moving, turret is not moving, and the driver is holding USE(e) for > 1 second, then slowly repair the tank's health.
				self.driver loopsound weldingtorch
			}
		}

		if(self.turretplayer != NIL && self.turretplayer != NULL) { local.turretuser_count = 1 }
		else { local.turretuser_count = 0 }
		if(local.turretuser_hud != local.turretuser_count)
		{
			if(local.turretuser_count == 1) { ihuddraw_string local.player 110 "Turret User:   1" }
			else { ihuddraw_string local.player 110 "" }
			local.turretuser_hud = local.turretuser_count
		}

		if(self.driver.fireheld == 1 && self.firingshell != 1)
		{
			self thread fire_tank_sound
			self thread projectile
		}
		if(self.shooter != NIL) { self thread shooter_NIL }

		if(self.driver.useheld != 1 || self.driver.fireheld == 1 || self.gun.angles != local.turretangles || self.health >= level.tank_inithealth[self.name]) { local.holdtime = 0; self.driver stoploopsound }
		if(local.holdtime > 9999) { local.holdtime = 9999 }
		local.turretangles = self.gun.angles

		if(self.health > level.tank_inithealth[self.name]) { self.health = level.tank_inithealth[self.name] }
		if(local.stufftext_c == 10) { self.driver stufftext ("set phealth " + int(self.health)) }

		local.stufftext_c++
		if(local.stufftext_c > 10) { local.stufftext_c = 0 } // twice every second.
		waitframe
	}

	if(self != NULL) // spawn in the new tank and remove the old one.
	{
		thread main self.name self.model self.origin self.angles self.health self.resettime 1 local.groundtarget

		if(self.driver != NIL && self.driver != NULL)
		{
			if(self.driver.dmteam != local.team) { local.newteam = 1 }
			self thread driverreset 0 local.newteam level.change_team_score
			self thread tankreset local.groundtarget
		}
		if(self.turretplayer != NIL && self.turretplayer != NULL) { self waitthread turretplayer_reset self.turretplayer.dmteam self.turretplayer }

		if(self != NULL)
		{
			self.driver = NIL // the old vehicle must be properly removed, otherwise the server will crash if anyone driving the vehicle leaves the game (becomes NULL).
			if(self.dead != 1 && self.flooded != 1)
			{
				if(self.gun != NIL && self.gun != NULL) { self.gun remove }
				if(self.gun2 != NIL && self.gun2 != NULL) { self.gun2 remove }
				self remove
			}
		}
	}
	waitframe
	if(local.driver != NULL)
	{
		local.driver.driving = 0
		local.driver.passenger = 0
		local.driver.drivingent = NIL
		local.driver stoploopsound
		if(!isalive local.driver) { local.driver stufftext ("set phealth 0") }
		ihuddraw_string local.player 110 ""

		if(local.driver.using_pack == 1)
		{
			local.driver stufftext "globalwidgetcommand june6 linkcvar fuel"
			local.driver stufftext ("globalwidgetcommand june6 statbar vertical 0 " + level.jetpack_max_fuel)
			local.driver stufftext "globalwidgetcommand charliesector linkcvar fuel"
		}
		else
		{
			local.driver stufftext "hidemenu dday1"
			local.driver stufftext "hidemenu dday2"
		}

		local.origin = local.driver.origin
		while(local.driver != NULL && !isalive local.driver && local.driver.dmteam != "spectator")
		{
			local.driver.origin = ( local.origin[0] local.origin[1] local.driver.origin[2] ) // for some reason, drivers' dead bodies would move forward across the ground until they hit a wall.
			local.driver notsolid
			local.driver droptofloor
			waitframe
		}
	}
end

shooter_NIL:

	waitframe
	if(self != NULL) { self.shooter = NIL }
end

driverreset local.death local.newteam local.changescore:

	if(self.driver == NIL) { end } // if the tank blew up with nobody driving it, end this thread.

	//if(local.death != 1) { cueplayer } // reattaches camera to player's head. removed due to causing camera problems for other tank drivers, VehicleTurretGun, & TurretGun users.
	local.driver = self.driver
	local.driver.driving = 0
	local.driver.passenger = 0
	local.playerangles = self.driver.viewangles

	self detachdriverslot 0 self.driver

	if(local.death == 1)
	{
		self.driver show // respawning the driver does all of this automatically.
		self.driver solid
		self.driver takedamage // if tank is dead, simply detatch & reset the driver so he can die.
		end
	}

	self.driver respawn // use this instead of "cueplayer".
	self.driver forcelegsstate STAND // this must be placed before "EXIT_TANK", otherwise "Tried to deactivate a non-active weapon in hand 0" errors will print.
	self.driver forcetorsostate EXIT_TANK // fix player's weapon and arms being invisible when exiting tank by quickly putting away, then raising weapon again.

	if(local.changescore != 1 && (local.newteam != 1 || self.driver.dmteam == "spectator")) // if "changescore = 1" players are already being respawned by a gametype mod ("freeze tag", "search & destroy", etc) and need a new origin/angles.
	{
		self.driver.origin = self.origin + (angles_toup self.angles * self.outheight) // move 170 units above kingtank, or 160 units above other tanks.
		self.driver.viewangles = ( 0 local.playerangles[1] 0 ) // make sure player's camera is horizontal (in case they left while tank was on a sloped terrain.

		for(local.a = 1; local.a <= 4; local.a++)
		{
			waitframe // minimum = 0.20 seconds total.
			if(local.driver != NULL)
			{
				local.driver.viewangles = ( 0 local.playerangles[1] 0 ) // need a few more iterations to bypass the new player angles given after the player is respawned.
				if(local.driver.dmteam == "spectator" && local.toggle != 1) { local.driver stufftext "togglemenu selectprimaryweapon"; local.toggle = 1 } // remove the menu that appears when spectators are respawned.
			}
		}
	}
end

fire_tank_sound:

	if(self.model == "models/vehicles/kingtank.tik")
	{
		if(level.mapname != "m5l3") { self playsound king_snd_fire2 } // firing sound
		if(level.mapname != "m5l2a" && level.mapname != "m5l2b") { self.driver playsound king_snd_fire1 } // reloading sound
	}
	else
	{
		if(level.mapname != "m3l3" && level.mapname != "m5l1a" && level.mapname != "m5l1b" && level.mapname != "m5l2a" && level.mapname != "m5l2b" && level.mapname != "m5l3") { self.driver playsound tank_snd_fire }
		if(level.mapname != "m5l2a" && level.mapname != "m5l2b") { self playsound tank_snd_reload }
	}
	self.firingshell = 1

	self.tanksmokecount = 0
	if(self.tanksmoking != 1) { self thread smokey }
	wait 5.05
	if(self != NULL) { self.firingshell = 0 }
end

projectile:

	local.player = self.driver // used for the for-loop later

	local.rocket = spawn script_model
	local.rocket model "projectiles/tigercannonshell.tik"
	local.rocket.origin = self.gun gettagposition "tag_barrel"
	local.rocket.angles = self.gun.angles
	local.rocket light 0 1 0 250
	local.rocket.scale = 2
	local.rocket solid
	local.rocket physics_on    // need this for gravity and waittill touch to work.

	local.rocket gravity 0
	local.angles = ( self.driver.viewangles[0] self.gun.angles[1] self.driver.viewangles[2] )
	local.rocket.velocity = (angles_toforward local.angles) * 6000
	local.rocket.player_owner = self.driver

	local.rocket thread waittill_touch local self local.player
	local.hitthing = self
	while(local.hitthing == self || (self != NULL && local.hitthing == self.gun))
	{
		local.rocket waittill touch
		local.hitthing = parm.other
	}
	local.rocket.velocity = ( 0 0 0 )

	local.explode = spawn "fx/explosionTIGERshell.tik"
	local.explode.origin = local.rocket.origin
	local.explode.scale = 2.5
	local.explode light 1 0 0 500
	local.explode anim idle
	//local.explode playsound bazooka_exp // already included in explosionTIGERshell

	local.blewup = 1
	for(local.i = 1; local.i <= $player.size; local.i++) // use this instead of radiusdamage, so rockets can count as score/kills
	{
		if(vector_length(local.explode.origin - $player[local.i].origin) <= 400) // "local.explode" emitters cannot be used with "cansee"
		{
			if(local.player == NIL || local.player == NULL)
			{
				if($player[local.i].driving != 1 && $player[local.i].flying != 1 && $player[local.i] cansee local.rocket 360)
				{
					$player[local.i] damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0
				}
				else if($player[local.i].drivingent != NIL && $player[local.i].drivingent != NULL)
				{
					if($player[local.i].flying == 1) { $("planehit" + $player[local.i].entnum) damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else { $player[local.i].drivingent damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
				}
			}
			else if($player[local.i] != local.player && $player[local.i].dmteam == local.player.dmteam && getcvar("g_teamdamage") != "1" && getcvar("g_gametype") != "1") { local.blewup = 0 }
			else
			{
				if($player[local.i].driving != 1 && $player[local.i].flying != 1 && $player[local.i] cansee local.rocket 360)
				{
					$player[local.i] damage local.player 500 local.player (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 // "damage" does not hurt teammates, but scriptbazookaexplosion.tik does
				}
				else if($player[local.i].drivingent != NIL && $player[local.i].drivingent != NULL)
				{
					$player[local.i].drivingent.shooter = local.player
					if($player[local.i].flying == 1) { $("planehit" + $player[local.i].entnum) damage local.player 500 local.player (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else { $player[local.i].drivingent damage local.player 500 local.player (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
				}
			}
		}
	}
	if(local.blewup == 1) { radiusdamage local.explode.origin 500 400 } // occurs one frame after impact, otherwise some scorepoints (i.e. killing players using nebelwerfers) will not count properly.
	waitframe
	local.rocket remove
	local.explode remove
end

////////////////////////////////////////////////////////////////////////

waittill_touch local.thread local.turret local.player:

	while(1)
	{
		if(self == NULL || vector_length(self.origin) > 12000) // if moving outside the map or NULL.
		{
			if(local.thread != NULL) { local.thread remove } // prematurely end "waittill touch" and its thread (nothing else runs after it).
			if(self != NULL) { self remove }
			end
		}

		if(self.velocity == ( 0 0 0 )) { end } // self.hitwater not needed, since these projectiles already stop when hitting water.
		waitframe
	}
end

////////////////////////////////////////////////////////////////////////

smokey:

	self.tanksmoking = 1
	local.targetname = self.targetname
	local.tanksmokecount = self.tanksmokecount

	local.smoke = spawn script_model
	local.smoke model "fx/fx_cannonsmoke.tik"
	self.gun = self QueryTurretSlotEntity 0
	local.smoke.origin = self.gun gettagposition "tag_barrel"

	while(self != NULL && self.tanksmokecount < 120)
	{
		local.smoke.origin = self.gun gettagposition "tag_barrel"
		self.tanksmokecount++
		local.tanksmokecount = self.tanksmokecount
		waitframe
	}

	local.c = 0
	while($(local.targetname) == NULL) // tank is always removed after a player exits the tank, wait for the tank to respawn before continuing smokecount
	{
		if(local.c >= 10) // remove the smoke sooner if the tank was destroyed
		{
			if(local.smoke != NULL) { local.smoke remove }
			end
		}
		local.c++
		waitframe
	}

	$(local.targetname).tanksmoking = 1
	$(local.targetname).tanksmokecount = local.tanksmokecount
	$(local.targetname).gun = $(local.targetname) QueryTurretSlotEntity 0

	while($(local.targetname) != NULL && $(local.targetname).gun != NULL && $(local.targetname).tanksmokecount != NIL && $(local.targetname).tanksmokecount < 120)
	{
		local.smoke.origin = $(local.targetname).gun gettagposition "tag_barrel"
		$(local.targetname).tanksmokecount++
		waitframe	
	}

	if(local.smoke != NULL) { local.smoke remove }
	if($(local.targetname) != NULL) { $(local.targetname).tanksmoking = 0; $(local.targetname).tanksmokecount = 0 }
end

tankdamage:

	local.c = 0
	while(self != NULL && self.health > 0)
	{
		if(self != NULL)
		{
			local.previoushealth = self.health
			if(local.c > 0) { local.c-- }
		}

		if(self.nodamage == 1) { self.nodamage = 0; self takedamage }
		waitframe

		if(self != NULL && local.previoushealth > self.health)
		{
			local.c = local.c + 2
			self playsound damage_tank
			//if(local.c == 2) { exec global/earthquake.scr .2 3 0 0 } // if tank is getting constantly damaged per frame, stop earthquake from spamming. (removed, since it was still getting annoying)
		}
	}
end

tankdamagesmoke:

	local.smoke = spawn script_model
	local.smoke model "models/emitters/thin_black_short.tik"
	local.smoke.origin = self gettagposition "turret0"
	local.smoke.angles = ( 0 0 0 )
	local.smoke hide
	local.smoke notsolid
	local.smoke.scale = 1.000
	local.scale = local.smoke.scale

	while(self != NULL && self.health > 0)
	{
		local.smoke.origin = self gettagposition "turret0"
		local.smoke.scale = local.scale - (local.scale * self.health / level.tank_inithealth[self.name])

		if(int(self.health) < int(level.tank_inithealth[self.name])) { local.smoke show }
		else { local.smoke hide }
		waitframe
	}
	local.smoke remove
end

tankdeath:

	self waittill death // when waiting until "death", tank is not NULL yet
	self playsound explode_tank
	self.dead = 1

	local.destank = spawn script_model
	local.destank model self.desmodel
	local.destank.origin = self.origin
	local.destank.angles = self.angles
	local.destank.scale = self.scale
	local.destank thread move_stuck_players

	if(self.spawndeathfire == 1)
	{
		local.destank loopsound tankdeathfire
		if(self.model == "models/vehicles/kingtank.tik") { local.updist = 55 }
		else { local.updist = 20 }

		local.fire = spawn script_model
		local.fire model "models/emitters/fancyfire.tik"
		local.fire.origin = self.gun.origin + angles_toup self.angles * local.updist
		local.fire.angles = ( 0 0 0 )
		local.fire.scale = 3
		local.fire anim start
		local.fire notsolid
		local.smoke = spawn script_model
		local.smoke model "models/emitters/linger_smoke.tik"
		local.smoke.origin = self.gun.origin
		local.smoke.angles = ( 0 0 0 )
		local.smoke.scale = 5
		local.smoke anim start
		local.smoke notsolid
	}

	self thread driverreset 1 // local.death = 1
	self thread mainreset local.destank local.fire local.smoke // waiting self.resettime seconds until a new tank is spawned in

	self thread kill_riders
	self.driver = NIL

	if(self.turretplayer != NIL) { self waitthread turretplayer_reset self.turretplayer.dmteam self.turretplayer 1 } // ensures that the turretplayer is alaways detached after tank dies

	if(self != NULL && self.gun != NIL && self.gun != NULL) { self.gun remove }
	if(self != NULL && self.gun2 != NIL && self.gun2 != NULL) { self.gun2 remove }
	exec global/earthquake.scr .5 3 0 0

	if(self != NULL && self.shooter != NIL && self.shooter != NULL)
	{
		if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { local.shooter = self.shooter.player_owner }
		else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { local.shooter = self.shooter.owner }
		else { local.shooter = self.shooter }
	}
	local.blewup = 1
	for(local.i = 1; local.i <= $player.size; local.i++) // use this instead of radiusdamage, so death explosions can count as score/kills.
	{
		if(vector_length(local.destank.origin - $player[local.i].origin) <= 750) // "local.explode" emitters cannot be used with "cansee"
		{
			if(local.shooter == NIL || local.shooter == NULL)
			{
				if($player[local.i].driving != 1 && $player[local.i].flying != 1 && $player[local.i] cansee local.destank 360) // "cansee self" does not work.
				{
					$player[local.i] damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0
				}
				else if($player[local.i].drivingent != NIL && $player[local.i].drivingent != NULL)
				{
					if($player[local.i].flying == 1) { $("planehit" + $player[local.i].entnum) damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else { $player[local.i].drivingent damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
				}
			}
			else if($player[local.i] != local.shooter && $player[local.i].dmteam == local.shooter.dmteam && getcvar("g_teamdamage") != "1" && getcvar("g_gametype") != "1") { local.blewup = 0 }
			else
			{
				if($player[local.i].driving != 1 && $player[local.i].flying != 1 && $player[local.i] cansee local.destank 360)
				{
					$player[local.i] damage local.shooter 500 local.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 // "damage" does not hurt teammates, but scriptbazookaexplosion.tik does
				}
				else if($player[local.i].drivingent != NIL && $player[local.i].drivingent != NULL)
				{
					$player[local.i].drivingent.shooter = local.shooter
					if($player[local.i].flying == 1) { $("planehit" + $player[local.i].entnum) damage local.shooter 500 local.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else { $player[local.i].drivingent damage local.shooter 500 local.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
				}
			}
		}
	}
	if(self != NULL) { self remove }

	local.boom = spawn script_model
	local.boom model "models/emitters/mortar_higgins.tik"
	local.boom.origin = local.destank.origin
	local.boom.angles = ( 0 -90 0 ) + ( 260 0 0 )
	local.boom.scale = 1.5
	local.boom anim start
	local.boom notsolid

	local.debris = spawn script_model targetname "mortar_dirt_nosound"
	local.debris model "emitters/mortar_dirt_nosound.tik" 
	local.debris.origin = local.destank.origin
	local.debris.scale = 1.0
	local.debris anim start
	local.debris notsolid
	waitframe
	local.boom remove
	local.debris remove
	if(local.blewup == 1) { radiusdamage local.destank.origin 500 750 } // this must be one frame after other damages in this thread, otherwise chain-reaction kills will not count.
end

kill_riders:

	if(self.turretplayer != NIL && self.turretplayer != NULL)
	{
		if(self.shooter != NIL)
		{
			if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.turretplayer damage self.shooter.player_owner 9999999 self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.turretplayer damage self.shooter.owner 9999999 self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			else if(self.shooter != NULL) { self.turretplayer damage self.shooter 9999999 self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
		}
		else { self.turretplayer volumedamage 9999999 }
	}

	if(self.shooter != NIL)
	{
		if(self.driver != NIL)
		{
			if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.driver damage self.shooter.player_owner 9999999 self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.driver damage self.shooter.owner 9999999 self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			else if(self.shooter != NULL) { self.driver damage self.shooter 9999999 self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
		}
	}
	else if(self.driver != NIL) { self.driver volumedamage 9999999 } // let's make sure the driver is dead.
end

mainreset local.destank local.fire local.smoke:

	if(self.resettime == NIL || self.resettime <= 0) { end }

	local.name = self.name
	local.model = self.model
	local.turretmodel = self.turretmodel
	local.desmodel = self.desmodel
	local.origin = self.originold  // respawns the vehicle where it was destroyed, only by setting "thread main" origin/angles to "local.origin" "local.angles".
	local.angles = self.angles
	local.health = level.tank_inithealth[self.name]
	local.vehiclespeed = self.vehiclespeed
	local.resettime = self.resettime

	while(self != NULL) { waitframe }
	wait local.resettime

	if(local.fire != NIL && local.fire != NULL) { local.fire remove }
	if(local.smoke != NIL && local.smoke != NULL) { local.smoke remove }
	local.destank remove
	thread main local.name local.model level.tank_initorigin[local.name] level.tank_initangles[local.name] local.health local.resettime
end

////////////////////////////////////////////////////////////////////////

floodedreset:

	local.name = self.name
	local.model = self.model
	local.turretmodel = self.turretmodel
	local.desmodel = self.desmodel
	local.origin = self.originold  // respawns the tank where it was destroyed, only by setting "thread main" origin/angles to "local.origin" "local.angles".
	local.angles = self.angles
	local.health = level.tank_inithealth[self.name]
	local.vehiclespeed = self.vehiclespeed
	local.resettime = self.resettime

	self anim idle
	self.flooded = 1
	$(self.name + "_trig") setthread flooded
	$(self.name + "_trig") message ("*** This tank has been flooded. ***")

	local.smoke = spawn script_model
	local.smoke model "models/emitters/linger_smoke.tik"
	local.smoke.origin = self gettagposition "turret0"
	local.smoke.angles = ( 0 0 0 )
	local.smoke.scale = 5
	local.smoke anim start
	local.smoke notsolid
	local.smoke loopsound tankdeathwater

	local.c = 0
	while(self != NULL && self.dead != 1 && local.c <= self.resettime * 20)
	{
		local.smoke.origin = self gettagposition "turret0"
		local.c++
		waitframe
	}
	local.smoke remove
	if(self == NULL || self.dead == 1) { end }

	if(self.gun != NIL && self.gun != NULL) { self.gun remove }
	if(self.gun2 != NIL && self.gun2 != NULL) { self.gun2 remove }
	self remove
	thread main local.name local.model level.tank_initorigin[local.name] level.tank_initangles[local.name] local.health local.resettime
end

flooded:

	local.player = parm.other
	local.player iprint ("Wait until the tank resets again.")
end

////////////////////////////////////////////////////////////////////////

turretslot_2nd local.player:

	//if(local.player.isdog == 1) { local.player iprint ("Dogs cannot use vehicle turrets."); end }
	if(self.driver != NIL && self.driver != NULL && local.player.dmteam != self.driver.dmteam && local.player.dmteam != "spectator" && getcvar("g_gametype") != "1")
	{
		local.player iprint ("An enemy player is driving this tank!")
		end
	}

	local.team = local.player.dmteam
	waitframe	// need this here, otherwise driver & turret player could be attached to the same seat!
	if(self == NULL || self.flooded == 1 || self.dead == 1 || self.turretplayer != NIL || local.player == NIL || local.player == NULL || !isalive local.player || local.player.dmteam != local.team || local.player == self.driver || local.player.passenger == 1 || local.player.driving == 1 || local.player.flying == 1 || local.player.dead == 1 || level.change_team_score == 1 || level.bbactive == 0) { end }

	self.turretplayer = local.player
	//self.turretplayer hide
	self.turretplayer.scale = 0.5
	self.turretplayer.passenger = 1
	self.turretplayer.driving = 1
	self.turretplayer.turreting = 1
	self.turretplayer.remove_viewmodel = 0
	self.turretplayer.driving_state_jump = 0
	self.turretplayer forcetorsostate TURRET_START
	self.turretplayer iprint ("JUMP = exit turret.")
	self.turretplayer.turretingent = self // used with killstreaks/damagehandler.scr to properly give score to shooter if turretplayer's vehicle gets blown up by an enemy bazooka rocket.
	self.turretplayer.drivingent = self

	local.origin_init = self.origin
	local.angles_init = self.angles
	local.fwd_vec = angles_toforward self.turretplayer.viewangles
	local.origin = self.turretplayer gettagposition "eyes bone" + ( 0 0 10000 )
	local.groundtarget = spawn script_origin // need this entity to initially point the turret towards player's viewangles
	local.groundtarget.origin = trace local.origin (local.origin + local.fwd_vec * 10240) 0 // when attaching to VehicleTurretGun entities, player's angles will always face the tank's angles initially.
	self.origin += ( 0 0 10000 ) // this moves the tank away from any walls in order to find the correct turret angles (may not always work).
	self.angles = vector_toangles(local.groundtarget.origin - self.origin) // without any waitframes, point the vehicle towards player's angles, attach the player, then move the tank's angles back to normal.

	self unlock
	self.gun unlock
	self.gun2 unlock
	self.gun2 douse local.player
	self attachturretslot 1 local.player
	self.gun2 lock
	self.gun lock
	self lock
	self.gun2 show

	self thread spawn_turretgun_player_glue local.player

	self.angles = local.angles_init // move the tank's angles back to where it was before attaching the player.
	self.origin = local.origin_init
	local.groundtarget remove

	local.driver = self.driver
	local.team = local.player.dmteam
	local.targetname = self.targetname

	self.turretplayer_reattach = 0
	while(self != NULL && self.dead != 1 && self.flooded != 1 && self.turretplayer != NIL && self.turretplayer != NULL && isalive local.player && local.player.dmteam == local.team && local.player.dead != 1 && level.change_team_score != 1 && level.bbactive != 0)
	{
		local.player.origin = self.gun2.origin
		if(local.player.fireheld == 1) { self.gun2 playsound sndfire30cal }

		if(self.turretplayer.driving_state_jump == 1)
		{
			self.turretplayer_reattach = 0
			self waitthread turretplayer_reset local.team local.player
			end
		}

		local.driver = self.driver
		if(self.driver != NIL && self.driver != NULL) { self.turretplayer_reattach = 1 }
		waitframe
	}
	if(self != NULL) { self waitthread turretplayer_reset local.team local.player }

	if(local.player != NULL)
	{
		local.player.passenger = 0
		local.player.driving = 0
		local.player.turreting = 0
		local.player.remove_viewmodel = 1
		local.player.scale = 1
		local.player unglue
		//local.player show
	}
end

turretplayer_reset local.team local.player local.dead:

	if(local.player == NIL || local.player == NULL) // if turret player left the game
	{
		self lock
		self.gun lock
		self.gun2 lock
		self.turretplayer = NIL // if turret player leaves, then rejoins, he cannot see the vehicle's turretgun, but everyone else can (weird graphics glitch?).
		end			// for the rejoining player to fix it: enter the turret again, or wait for the vehicle to respawn.
	}

	local.player unglue
	local.player.passenger = 0
	local.player.driving = 0
	local.player.turreting = 0
	local.player.scale = 1
	if(local.player.dmteam != "spectator") { local.player show }
	local.player thread wallstuck_fix
	local.player forcetorsostate STAND
	//local.player forcelegsstate STAND // do not use this when exiting turrets; it will force players into noclip after exiting.
	local.player takedamage // this prevents a rare bug that kept the turret player from ever dying again (player is somehow, but only sometimes given "nodamage"?)
	local.player.turretingent = NIL
	local.player.drivingent = NIL

	if(isalive local.player && local.player.dmteam != "spectator")
	{
		self unlock
		self.gun unlock
		self.gun2 unlock
		self douse local.player
		local.player exit
		local.player forcelegsstate STAND
	}
	self lock
	self.gun lock
	self.gun2 lock
	self.turretplayer = NIL
	local.targetname = self.targetname

	if(local.player.dmteam != local.team && local.player.dmteam != "spectator") { local.player respawn }
	else { local.player.viewangles = ( self.gun2.angles[0] self.gun2.angles[1] 0 ) }

	if(local.player.dmteam == local.team) { local.player.origin = self.gun2.origin + (angles_toup self.angles * 15) }

	if(self.turretplayer_reattach != 1)
	{
		self.gun2 remove
		waitframe	// need this for the turret to be fully removed, before spawning a new one.
		if(self != NULL)
		{
			self spawnturret 1 "models/vehicles/jeep_30cal.tik"
			self.gun2 = self queryturretslotentity 1
			self.gun2 notsolid
			self.gun2 pitchcaps ( -60 35 0 )
			self.gun2.scale = 0.5
			self thread turret_2nd_reset // realigns the turret with the tank's angles after exiting the turret.
		}
	}
	if(self != NULL && self.dead != 1) { self thread turretplayer_reattach local.player local.team }
end

turretplayer_reattach local.player local.team:

	local.targetname = self.targetname
	if(self != NULL && self.flooded != 1 && self.turretplayer_reattach == 1 && isalive local.player && local.player.dmteam == local.team)
	{
		while(self != NULL) { waitframe }
		local.c = 0
		while($(local.targetname) == NULL) { local.c++; waitframe } // wait until the vehicle respawns before reattaching player.
		if(local.c > 20) { end }

		if($(local.targetname) != NULL && isalive local.player && local.player.dmteam == local.team) { $(local.targetname) thread turretslot_2nd local.player }
	}
end

turret_2nd_reset:

	local.fwd_vec = angles_toforward self.angles
	local.groundtarget_gun2 = spawn script_origin
	local.gun2origin = self gettagposition "turret0"
	local.groundtarget_gun2.origin = trace (local.gun2origin + local.fwd_vec * 56) (local.gun2origin + local.fwd_vec * 10240) 0

	waitframe // need this for setaimtarget to work properly
	if(self != NULL && self.gun2 != NIL && self.gun2 != NULL) { self.gun2 setaimtarget local.groundtarget_gun2 }

	waitframe
	local.groundtarget_gun2 remove
end

remove_viewmodels:

	while(1)
	{
		for(local.e = 0; local.e <= 868; local.e++)
		{
			local.entity = getentity(local.e)
			if(local.entity != NULL && (local.entity.model == "models/vehicles/jeep_30cal_viewmodel.tik" || local.entity.model == "models/vehicles/sdkfz_mg42_viewmodel.tik"))
			{
				for(local.i = 1; local.i <= $player.size; local.i++)
				{
					local.dist = vector_length(local.entity.origin - $player[local.i].origin)
					if(local.dist <= 100 && $player[local.i].remove_viewmodel == 1) { local.entity remove; $player[local.i].remove_viewmodel = 0 }
				}
			}
			waitframe
		}
		waitframe
	}
end

spawn_turretgun_player_glue local.player:

	while(self != NULL && self.gun2 != NIL && self.gun2 != NULL && $("turretgun_player_glue_" + self.gun2.entnum) != NULL) { $("turretgun_player_glue_" + self.gun2.entnum) remove; waitframe }

	if(self != NULL && self.gun2 != NIL && self.gun2 != NULL)
	{
		local.offset = ( (self.gun2.scale * 10) (self.gun2.scale * 48) (self.gun2.scale * -8) )
		self.gun2 attachmodel models/static/jug.tik "Box01" 1 ("turretgun_player_glue_" + self.gun2.entnum) 1 -1 -1 -1 -1 local.offset //( +left -right, +backward -forward, +up -down )
		$("turretgun_player_glue_" + self.gun2.entnum).angles = self.gun2.angles
		$("turretgun_player_glue_" + self.gun2.entnum) bind self.gun2
		$("turretgun_player_glue_" + self.gun2.entnum) hide
	}

	if(local.player != NULL && local.player.turreting == 1 && local.player.turretingent == self)
	{
		local.player glue $("turretgun_player_glue_" + self.gun2.entnum) // keep player's angles aligned with 30cal turret.
	}
end

////////////////////////////////////////////////////////////////////////

dummyavatar:

/*
	local.avatar = spawn func_beam
	local.avatar attach self.driver "Bip01 Head"
	local.avatar.origin = self.driver.origin + ( 0 0 100 )
	local.avatar endpoint (local.avatar.origin + ( 0 0 13 ))
	local.avatar minoffset 0.0
	local.avatar maxoffset 0.0
	local.avatar color ( 1 1 1 )
	local.avatar scale 7.0
	local.avatar life 0
	if(self.driver.dmteam == "allies") { local.avatar shader ("textures/hud/allies_headicon") }
	if(self.driver.dmteam == "axis") { local.avatar shader ("textures/hud/axis_headicon") }
	local.avatar numsegments 1
	local.avatar alpha 0.80
	local.avatar activate

	local.team = self.driver.dmteam
	while(self != NULL && isalive self.driver && self.driver.dmteam == local.team && self.driver.dead != 1 && level.change_team_score != 1 && level.bbactive != 0)
	{
		local.avatar.origin = self.driver.origin + self.upvector * 100
		local.avatar endpoint (local.avatar.origin + ( 0 0 13 ))
		waitframe
	}
	local.avatar remove
*/
end

////////////////////////////////////////////////////////////////////////

wallstuck_fix:

	local.c = 0
	local.origin = self.origin
	local.team = self.dmteam

	if(self.wallstuck_fixing == 1) { end }
	self.wallstuck_fixing = 1

	while(self != NULL && isalive self && self.dmteam == local.team) // while player is stuck in a wall (falling) and origin isn't changing, count a few seconds, then respawn the player
	{
		if(local.c >= 60) // about 3 seconds
		{
			if((self getmovement) == falling && self.origin == local.origin) { self respawn }
			if(self.isdog == 1) { self hide }
			break
		}
		local.c++
		waitframe
	}
	if(self != NULL) { self.wallstuck_fixing = 0 }
end

////////////////////////////////////////////////////////////////////////

removeclass_camera:

	level.removeclass_camera = 1
	while(1)
	{
		for(local.e = 0; local.e <= 868; local.e++)
		{
			local.entity = getentity(local.e)
			if(local.entity != NULL && local.entity.classname == "Camera" && local.entity.targetname == "") { local.entity remove }
			waitframe
		}
		waitframe
	}
end

////////////////////////////////////////////////////////////////////////

move_stuck_players:

	waitframe
	for(local.i = 1; local.i <= $player.size; local.i++)
	{
		if(isalive $player[local.i] && $player[local.i].dead != 1 && $player[local.i].dmteam != "spectator" && self != NULL && $player[local.i] istouching self && (self.gun == NIL || (self.gun != NIL && self.gun != NULL && $player[local.i] istouching self.gun)) && $player[local.i].driving != 1 && $player[local.i].passenger != 1 && $player[local.i].turreting != 1 && $player[local.i].flying != 1 && $player[local.i].missile == NIL)
		{
			self thread moving_stuck_players $player[local.i]
		}
	}
end

moving_stuck_players local.player:

	if(local.player.moving_stuck_players == 1) { end }
	local.player.moving_stuck_players = 1

	while(self != NULL && isalive local.player && local.player.dmteam != "spectator" && local.player istouching self && (self.gun == NIL || (self.gun != NIL && self.gun != NULL && local.player istouching self.gun)) && local.player.driving != 1 && local.player.passenger != 1 && local.player.turreting != 1 && local.player.flying != 1 && local.player.missile == NIL)
	{
		local.player.origin += (angles_toup self.angles * 20)
		waitframe
	}
	if(local.player != NULL) { local.player.moving_stuck_players = 0 }
end

////////////////////////////////////////////////////////////////////////

display local.ent:

	if(game.game != "AA") { local.menu1 = "bastogne1"; local.menu2 = "bastogne2" }
	else { local.menu1 = "dday1"; local.menu2 = "dday2" }

	self stufftext ("globalwidgetcommand " + local.menu1 + " shader townhallwindow")
	self stufftext ("globalwidgetcommand " + local.menu1 + " fgcolor 1.00 1.00 1.00 1.00")
	self stufftext ("globalwidgetcommand " + local.menu1 + " bgcolor 0.50 0.50 0.50 0.00")
	self stufftext ("globalwidgetcommand " + local.menu1 + " fadein 0")
	self stufftext ("globalwidgetcommand " + local.menu1 + " menu " + local.menu1 + " 640 480 NONE 0")
	self stufftext ("globalwidgetcommand " + local.menu1 + " virtualres 1")
	self stufftext ("globalwidgetcommand " + local.menu1 + " fullscreen 1")

	self stufftext "globalwidgetcommand june6 borderstyle NONE"
	self stufftext "globalwidgetcommand june6 shader textures/hud/healthback"
	self stufftext "globalwidgetcommand june6 rect 16 420 16 64"
	self stufftext "globalwidgetcommand june6 fgcolor 1.00 1.00 1.00 1.00"
	self stufftext "globalwidgetcommand june6 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand june6 linkcvar phealth"
	self stufftext ("globalwidgetcommand june6 statbar vertical 0 " + level.tank_inithealth[local.ent.targetname] )
	self stufftext "globalwidgetcommand june6 statbar_shader textures/hud/healthmeter"
	self stufftext "globalwidgetcommand june6 statbar_shader_flash textures/hud/healthmeterflash"

	self stufftext ("globalwidgetcommand " + local.menu2 + " fgcolor 1.00 1.00 1.00 1.00")
	self stufftext ("globalwidgetcommand " + local.menu2 + " bgcolor 0.50 0.50 0.50 0.00")
	self stufftext ("globalwidgetcommand " + local.menu2 + " fadein 0")
	self stufftext ("globalwidgetcommand " + local.menu2 + " menu " + local.menu2 + " 640 480 NONE 0")
	self stufftext ("globalwidgetcommand " + local.menu2 + " virtualres 1")
	self stufftext ("globalwidgetcommand " + local.menu2 + " fullscreen 1")

	self stufftext "globalwidgetcommand charliesector borderstyle NONE"
	self stufftext "globalwidgetcommand charliesector textalign left "
	self stufftext "globalwidgetcommand charliesector rect 40 470 150 20"
	self stufftext "globalwidgetcommand charliesector fgcolor 0.70 0.60 0.05 1.00"
	self stufftext "globalwidgetcommand charliesector bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand charliesector linkcvar phealth"
	self stufftext "globalwidgetcommand charliesector font facfont-20"
	self stufftext "globalwidgetcommand charliesector shader townhallwindow"

	self stufftext ("showmenu " + local.menu2)
	self stufftext ("showmenu " + local.menu1)
	self stufftext ("set phealth " + int(local.ent.health))
end

////////////////////////////////////////////////////////////////////////

tank_settings local.gotout:

	switch(self.model)
	{
		case "models/vehicles/kingtank.tik":
			self.turretmodel = models/vehicles/kingcannon.tik
			self.desmodel = models/vehicles/kingtank_all_d.tik
			self.spawndeathfire = 1
			self.outheight = 167
			if(local.gotout == 1) { self playsound king_snd_stop }
			break

		case "models/vehicles/panzer_tank.tik":
			self.turretmodel = models/vehicles/panzer_cannon.tik
			self.desmodel = models/vehicles/panzer_iv_d.tik
			self.spawndeathfire = 0
			self.outheight = 157
			if(local.gotout == 1) { self playsound tank_snd_stop }
			break

		case "models/vehicles/panzer_tank_europe.tik":
			self.turretmodel = models/vehicles/panzer_cannon_europe.tik
			self.desmodel = models/vehicles/panzer_iv_eud.tik
			self.spawndeathfire = 1
			self.outheight = 157
			if(local.gotout == 1) { self playsound tank_snd_stop }
			break

		case "models/vehicles/tigertank.tik":
			self.turretmodel = models/vehicles/tigercannon.tik
			self.desmodel = models/vehicles/tigertank_d.tik
			self.spawndeathfire = 0
			self.outheight = 157
			if(local.gotout == 1) { self playsound tank_snd_stop }
			break

		case "models/vehicles/tigertankdsrt.tik":
			self.turretmodel = models/vehicles/tigercannon.tik
			self.desmodel = models/vehicles/tigertank_d.tik
			self.spawndeathfire = 0
			self.outheight = 157
			if(local.gotout == 1) { self playsound tank_snd_stop }
			break

		default:
			self.turretmodel = models/vehicles/tigercannon.tik
			self.desmodel = models/vehicles/tigertank_d.tik
			self.spawndeathfire = 1
			self.outheight = 157
			if(local.gotout == 1) { self playsound tank_snd_stop }
			break
	}

	if(level.tankscriptmaster[self.model] != 1) // this only runs once
	{
		cache self.desmodel
		cache self.turretmodel
		cache models/emitters/mortar_higgins.tik
		cache models/emitters/mortar_dirt_nosound.tik
		cache models/projectiles/tigercannonshell.tik
		cache models/fx/fx_cannonsmoke.tik
		cache models/emitters/fancyfire.tik
		cache models/emitters/linger_smoke.tik
		cache models/emitters/thin_black_short.tik
		thread scriptmaster self.model
		level.tankscriptmaster[self.model] = 1
		level.tankscriptmaster2 = 1
	}
	if(level.tankscriptmaster2 != 1) { cache models/vehicles/jeep_30cal_viewmodel.tik } //{ cache models/vehicles/sdkfz_mg42_viewmodel.tik }
end

////////////////////////////////////////////////////////////////////////

scriptmaster local.model:

level.mapname = getcvar "mapname"
local.master = spawn scriptmaster

if(level.scriptmaster[weldingtorch] != 1 && level.scriptmaster[detonator_switch] != 1)
{
	local.master aliascache weldingtorch sound/mechanics/WeldingTorch.wav soundparms 1.0 0.0 1.0 0.0 400 1000 item loaded maps level.mapname
	level.scriptmaster[weldingtorch] = 1
}

if(local.model == "models/vehicles/kingtank.tik")
{
	local.soundtype = 1
}
else { local.soundtype = 2 }

if(level.tankscriptmaster[local.soundtype] != NIL) { end }
level.tankscriptmaster[local.soundtype] = 1

if(local.soundtype == 1 && level.mapname != "m5l1a" && level.mapname != "m5l1b" && level.mapname != "m5l2a" && level.mapname != "m5l2b" && level.mapname != "m5l3")
{
	local.master aliascache king_snd_idle sound/vehicle/veh_tank_idle1.wav soundparms .5 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_revup sound/vehicle/veh_tank_revup1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_revdown sound/vehicle/veh_tank_revdown1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_shift1 sound/vehicle/veh_tank_shift1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_shift2 sound/vehicle/veh_tank_shift2.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_shift3 sound/vehicle/veh_tank_shift3.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_on sound/vehicle/veh_tank_on1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_start sound/vehicle/veh_tank_on1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_off sound/vehicle/veh_tank_off1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_stop sound/vehicle/veh_tank_off1.wav soundparms 1.5 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_tread_snd_dirt sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_tread_snd_stone sound/vehicle/veh_tread_metal.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_tread_snd_grass sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_tread_snd_wood sound/vehicle/veh_tread_metal.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_tread_snd_mud sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_doorclose sound/mechanics/DoorHatchClose_02.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache king_vehicle_crash1 sound/mechanics/damage_vehicle_1.wav soundparms .5 .5 .7 .5 160 1600 auto loaded maps level.mapname
	local.master aliascache king_vehicle_crash2 sound/mechanics/damage_vehicle_2.wav soundparms .5 .5 .7 .5 160 1600 auto loaded maps level.mapname
	local.master aliascache king_vehicle_crash3 sound/mechanics/damage_vehicle_3.wav soundparms .5 .5 .7 .5 160 1600 auto loaded maps level.mapname
	local.master aliascache king_vehicle_crash4 sound/mechanics/damage_vehicle_4.wav soundparms .5 .5 .7 .5 160 1600 auto loaded maps level.mapname
	local.master aliascache king_snd_turret_up sound/null.wav soundparms .7 0 1.3 .2 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_reload sound/null.wav soundparms .9 .2 .9 .2 800 4000 auto loaded maps level.mapname
}
if(local.soundtype == 1 && level.mapname != "m5l2a" && level.mapname != "m5l2b")
{
	local.master aliascache king_snd_fire1 sound/weapons/fire/TankFire1.wav soundparms 1.5 0 1 0 2000 4000 weapon loaded maps level.mapname
}
if(local.soundtype == 1 && level.mapname != "m5l3")
{
	local.master aliascache king_snd_fire2 sound/weapons/fire/TankCannonFire1.wav soundparms 1.5 0 1 0 2000 4000 weapon loaded maps level.mapname
}
if(local.soundtype == 1)
{
	local.master aliascache king_snd_dooropen sound/null.wav soundparms .9 .2 .9 .2 800 4000 auto loaded maps level.mapname
}

if(local.soundtype == 2 && level.mapname != "m5l2a" && level.mapname != "m5l2b")
{
	local.master aliascache tank_snd_reload sound/weapons/fire/TankFire1.wav soundparms 1.5 0 1 0 800 4000 weapon loaded maps level.mapname
}

if(local.soundtype == 2 && level.mapname != "m3l3" && level.mapname != "m5l1a" && level.mapname != "m5l1b" && level.mapname != "m5l2a" && level.mapname != "m5l2b" && level.mapname != "m5l3")
{
	local.master aliascache tank_tread_snd_dirt sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache tank_tread_snd_grass sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache tank_tread_snd_wood sound/vehicle/veh_tread_metal.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache tank_tread_snd_mud sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache tank_snd_fire1 sound/weapons/fire/TankCannonFire1.wav soundparms 1.5 0 1 0 2000 4000 weapon loaded maps level.mapname
	local.master aliascache tank_snd_fire2 sound/weapons/fire/Flak88Fire1.wav soundparms 1.5 0 1 0 2000 4000 weapon loaded maps level.mapname
	local.master aliascache tank_snd_fire3 sound/weapons/fire/Flak88Fire3.wav soundparms 1.5 0 1 0 2000 4000 weapon loaded maps level.mapname
	local.master aliascache tank_snd_fire4 sound/weapons/fire/Flak88Fire4.wav soundparms 1.5 0 1 0 2000 4000 weapon loaded maps level.mapname

	if(level.mapname != "m1l2b")
	{
		local.master alias tank_snd_run sound/vehicle/veh_tank_run1.wav soundparms 1 0 1 0 800 4000 auto streamed maps level.mapname
		local.master aliascache tank_snd_revup sound/vehicle/veh_tank_revup1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
		local.master aliascache tank_snd_revdown sound/vehicle/veh_tank_revdown1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
		local.master aliascache tank_snd_shift1 sound/vehicle/veh_tank_shift1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
		local.master aliascache tank_snd_shift2 sound/vehicle/veh_tank_shift2.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
		local.master aliascache tank_snd_shift3 sound/vehicle/veh_tank_shift3.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
		local.master aliascache tank_snd_on sound/vehicle/veh_tank_on1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
		local.master aliascache tank_snd_start sound/vehicle/veh_tank_on1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
		local.master aliascache tank_snd_off sound/vehicle/veh_tank_off1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
		local.master aliascache tank_snd_stop sound/vehicle/veh_tank_off1.wav soundparms 1 0 1 0 1000 4000 auto loaded maps level.mapname
		local.master aliascache tank_tread_snd_stone sound/vehicle/veh_tread_metal.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname

		if(level.mapname != "training")
		{
			local.master alias tank_idle_training sound/vehicle/veh_tank_idle1.wav soundparms 1 0 1 0 800 4000 auto streamed maps level.mapname
			local.master alias tank_snd_idle sound/vehicle/veh_tank_idle1.wav soundparms .5 0 1 0 800 4000 auto streamed maps level.mapname
		}
	}
}

if(level.tankscriptmaster2 != 1 && level.mapname != "m3l3" && level.mapname != "m5l1a" && level.mapname != "m5l1b" && level.mapname != "m5l2a" && level.mapname != "m5l2b" && level.mapname != "m5l3")
{
	local.master aliascache tank_snd_move sound/vehicle/veh_tank_turret1.wav soundparms .9 .2 .9 .2 800 4000 auto loaded maps level.mapname
}

if(level.tankscriptmaster2 != 1 && level.mapname != "m5l1a" && level.mapname != "m5l1b" && level.mapname != "m5l2a" && level.mapname != "m5l2b" && level.mapname != "m5l3")
{
	local.master aliascache king_snd_move sound/vehicle/veh_tank_turret1.wav soundparms .9 .2 .9 .2 800 4000 auto loaded maps level.mapname
	local.master aliascache king_snd_run sound/vehicle/veh_tank_run1.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
}

if(level.tankscriptmaster2 != 1 && level.mapname != "m5l1a" && level.mapname != "m5l1b" && level.mapname != "m5l2a" && level.mapname != "m5l2b" && level.mapname != "m5l3")
{
	local.master aliascache tank_vehicle_crash1 sound/null.wav soundparms .7 .4 1 .5 160 1600 auto loaded maps level.mapname
	local.master aliascache damage_tank1 sound/null.wav soundparms .7 .4 .9 .2 160 1600 auto loaded maps level.mapname
}

if(level.tankscriptmaster2 != 1 && level.mapname != "m1l3a" && level.mapname != "m1l3b" && level.mapname != "m3l3" && level.mapname != "m4l2" && level.mapname != "m5l1a" && level.mapname != "m5l1b" && level.mapname != "m5l2a" && level.mapname != "m5l2b" && level.mapname != "m5l3" && level.mapname != "m6l3c")
{
	local.master aliascache explode_tank4 sound/weapons/explo/Explo_MetalMed4.wav soundparms .9 .2 .8 .2 1500 9000 weapon loaded maps level.mapname

	if(level.mapname != "m4l3" && level.mapname[3] != "/")
	{
		local.master aliascache explode_tank3 sound/weapons/explo/Explo_MetalMed3.wav soundparms .9 .2 .8 .2 1500 9000 weapon loaded maps level.mapname
	}

	if(level.mapname != "m1l2b" && level.mapname[3] != "/")
	{
		local.master aliascache explode_tank2 sound/weapons/explo/Explo_MetalMed2.wav soundparms .9 .2 .8 .2 1500 9000 weapon loaded maps level.mapname
	}

	if(level.mapname != "m1l2b" && level.mapname != "m4l3" && level.mapname != "m6l1c" && level.mapname != "training")
	{
		local.master aliascache explode_tank1 sound/weapons/explo/Explo_MetalMed1.wav soundparms .9 .2 .8 .2 1500 9000 weapon loaded maps level.mapname
	}
}

if(level.tankscriptmaster2 != 1 && level.mapname == "training" || level.mapname[2] == "/" || level.mapname[3] == "/")
{
	local.master aliascache tank_snd_doorclose sound/mechanics/DoorHatchClose_02.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
}
if(level.tankscriptmaster2 != 1 && level.mapname[2] == "/" || level.mapname[3] == "/")
{
	local.master aliascache tank_snd_dooropen sound/mechanics/DoorHatchClose_02.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
}

if(level.tankscriptmaster2 != 1)
{
	local.master aliascache tankfire30cal sound/weapons/fire/50CalFire2.wav soundparms 1.05 .2 .95 .1 800 4000 weapon loaded maps level.mapname

	local.master aliascache tankdeathfire sound/amb/fire.wav soundparms 1.2 0.0 1.0 0.0 250 2000 auto loaded maps level.mapname
	local.master aliascache tankdeathwater sound/mechanics/Mec_WaterLoop_03.wav soundparms 1.2 0.0 1.0 0.0 250 2000 auto loaded maps level.mapname
}
if(level.scriptmaster_sndmove != 1)
{
	local.master aliascache snd_move sound/null.wav soundparms .4 .2 .9 .2 160 1600 auto loaded maps level.mapname
}
level.scriptmaster_sndmove = 1
level.tankscriptmaster2 = 1
end
