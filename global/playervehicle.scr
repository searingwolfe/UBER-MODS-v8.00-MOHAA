main local.name local.model local.origin local.angles local.health local.vehiclespeed local.resettime local.headlights local.noheadlights local.gotout:

	if(local.model == NIL) { wait 1; println("----- ERROR playervehicle.scr: 'model' parameter is missing!"); end }
	if(local.model[0] != "m" && local.model[1] != "o" && local.model[2] != "d" && local.model[3] != "e" && local.model[4] != "l" && local.model[5] != "s")
	{
		local.model = "models/" + local.model
		if(level.vehiclescriptmaster[local.model] != 1) { cache local.model }
	}

	if($(local.name) != NULL) 
	{
		waitframe; if($(local.name) != NULL) { waitframe; if($(local.name) != NULL) { waitframe; if($(local.name) != NULL) { waitframe; if($(local.name) != NULL) { waitframe } } } }
		if($(local.name) != NULL)
		{
			if(level.vehiclescriptmaster[local.model] != 1) { wait 1; println("----- ERROR playervehicle.scr: $" + local.name + " must be removed before spawning a drivable vehicle.") }
			end
		}
	}

	if(local.health == NIL || (local.health != NIL && local.health <= 0 && level.vehiclescriptmaster[local.model] != 1)) { wait 1; println("----- ERROR playervehicle.scr: health must be greater than 0."); end }
	if(local.health == NIL || (local.health != NIL && local.health <= 0 && level.vehiclescriptmaster[local.model] == 1)) { end } // end when in rare cases, a 2nd vehicle with local.health = 0 could spawn after getting destroyed

	local.vehicle = spawn local.model targetname (local.name) // scriptmasters are already added in ubersound.scr
	local.vehicle.name = local.name
	local.vehicle.origin = local.origin
	local.vehicle.angles = local.angles
	local.vehicle.health = local.health
	local.vehicle.vehiclespeed = local.vehiclespeed
	local.vehicle.vehiclespeed_max = local.vehiclespeed
	local.vehicle.resettime = local.resettime
	local.vehicle.headlights = local.headlights

	if(local.vehicle.classname != "DrivableVehicle") { local.vehicle remove; wait 1; println("----- ERROR playervehicle.scr: .tik model is not a DrivableVehicle."); end }

	local.vehicle thread vehicle_settings local.gotout // includes seatstuff, gotout playsound, desmodel, outheight, turnrate, etc.
	local.vehicle thread vehiclereset
	local.vehicle thread vehicledamage
	local.vehicle thread vehicledeath
	local.vehicle thread vehicletrigger
	local.vehicle thread move_stuck_players // the vehicle might respawn on top of other players, move them onto the top of it.

	if(level.vehicle_initorigin[local.name] == NIL) { level.vehicle_initorigin[local.name] = local.origin } // store the initial origin/angles as level variable arrays
	if(level.vehicle_initangles[local.name] == NIL) { level.vehicle_initangles[local.name] = local.angles }
	if(level.vehicle_inithealth[local.name] == NIL) { level.vehicle_inithealth[local.name] = local.health }

										// "local.player.touching_playervehicle" or "$player[1].touching_playervehicle" can be included in trigger setthreads
	if(level.touching_playervehicle != 1) { thread touching_playervehicle }	// to exclude teleporting players that are touching "$ocean" or similar water-surface triggers.

	if(level.remove_viewmodels != 1) { thread remove_viewmodels }
	level.remove_viewmodels = 1

	if(level.check_player_kills != 1) { local.result = registerev damage killstreaks/damagehandler.scr } // for giving kills/score when players shoot/kill passengers.
	level.check_player_kills = 1

	if(level.chainreactors == NIL || (level.chainreactors != NIL && level.chainreactors.size < 1)) { level.chainreactors[1] = local.vehicle }
	else
	{
		for(local.c = 1; local.c <= 999; local.c++)
		{
			if(level.chainreactors[local.c] == NIL)
			{
				level.chainreactors[local.c] = local.vehicle
				local.vehicle thread chainreactors_remove local.c
				break
			}
		}
	}

	if(level.drivable_entities == NIL) { level.drivable_entities[1] = local.name }
	else
	{
		for(local.d = 1; local.d <= level.drivable_entities.size; local.d++)
		{
			if(level.drivable_entities[local.d] == local.name) { end }
		}
		level.drivable_entities[level.drivable_entities.size + 1] = local.name
	}
end

chainreactors_remove local.c:

	while(self != NULL) { waitframe }
	level.chainreactors[local.c] = NIL
end

////////////////////////////////////////////////////////////////////////

vehiclereset: // vehicle animations must be set each time a new vehicle spawns (after player exits); vehicle.gun must be queried before removal, if it exists.

	self fullstop
	if(self.headlights != 1) 	// since the opeltruck isn't spawned in as "= script_model" above, any animations will forcibly turn off 
	{				// the headlights (including idlelights & stop_wheels); opeltruck headlight rays cannot be turned back on until the player exits the opeltruck (once truck is removed and respawned).
		self anim idle
		self anim idlenolights // some models don't have these anims, but errors do not print
		self anim stop_wheels
		self.headlights = 0
	}
	if(self.headlights == 1 && self.noheadlights != 1) 
	{
		if(self.model == "models/vehicles/opeltruck.tik" || self.model == "models/vehicles/opeltruckgreen.tik" || self.model == "models/vehicles/opeltruckgreen_canopy.tik")
		{
			self thread deadcorona "light left" // opeltruck headlight "tags" from .skd file
			self thread deadcorona "light right"
		}
		else { self thread deadcorona }
		self thread illuminate "left"
		self thread illuminate "right"
	}
	self thread healthboost
	//removeclass Camera // also removes PlayerIntermission and other func_cameras
	if(level.removeclass_camera != 1) { thread removeclass_camera }
end

healthboost: // shotgun: 340 damage, bazooka: 105 damage, sniper: 106 damage, one grenade: 200 damage, two grenades: 400 damage

	local.health = self.health
	while(self != NULL && self.health > 0)
	{
		if(self.damagetrig != NIL && self.damagetrig != NULL && self.damagetrig.health < local.health && self.damagetrig.health > 0) { self.health = self.damagetrig.health }
		if(self.health < local.health)
		{
			for(local.i = 1; local.i <= self.passengers.size; local.i++)
			{
				local.damage = ((local.health - self.health) / (3 + self.passengers.size))
				if(self.passengers[local.i] != NIL && self.passengers[local.i] != NULL && self.shooter != NIL)
				{
					self.passengers[local.i] takedamage
					if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.passengers[local.i] damage self.shooter.player_owner local.damage self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.passengers[local.i] damage self.shooter.owner local.damage self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					else { self.passengers[local.i] damage self.shooter local.damage self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					self.passengers[local.i] nodamage
				}
			}
			if(self.driver != NIL && self.driver != NULL && self.model != "models/vehicles/sdkfz.tik" && self.model != "models/vehicles/sdkfz_afrika.tik" && self.model != "models/vehicles/shermantank.tik")
			{
				if(self.driver.health > 1)
				{
					self.driver takedamage
					if(self.passengers != NIL && self.passengers.size >= 1) { local.damage = ((local.health - self.health) / (3 + self.passengers.size)) }
					else { local.damage = ((local.health - self.health) / 3) }

					if(self.shooter != NIL)
					{
						if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.driver damage self.shooter.player_owner local.damage self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
						else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.driver damage self.shooter.owner local.damage self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
						else { self.driver damage self.shooter local.damage self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					}
					//else { self.driver damage $world local.damage $world (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 } // this may cause drivers to randomly die by running over stuff, even though "damagehandler.scr" script does not detect any damage dealt.
					self.driver nodamage
				}
				else
				{
					self thread driverreset 1
					self thread vehiclereset

					if(self.shooter != NIL)
					{
						if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.driver damage self.shooter.player_owner 9999999 self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
						else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.driver damage self.shooter.owner 9999999 self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
						else { self.driver damage self.shooter 9999999 self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 }
					}
					//else { self.driver damage $world 9999999 $world (0 0 0) (0 0 0) (0 0 0) 0 9 0 0 } // this may cause drivers to randomly die by running over stuff, even though "damagehandler.scr" script does not detect any damage dealt.
					self.driver = NIL
				}
			}
		}

		for(local.i = 1; local.i <= $player.size; local.i++)
		{
			if(self != NULL && $player[local.i].isdog == 1 && $("dogmouthtrig_" + $player[local.i].entnum).biting == 1 && ($("dogmouthtrig_" + $player[local.i].entnum) istouching self || (self.damagetrig != NIL && $("dogmouthtrig_" + $player[local.i].entnum) istouching self.damagetrig) || (self.trigshot != NIL && $("dogmouthtrig_" + $player[local.i].entnum) istouching self.trigshot)) && $player[local.i].passenger != 1 && $player[local.i].turreting != 1 && $player[local.i].driving != 1)
			{
				self.shooter = $player[local.i]
				for(local.i = 1; local.i <= self.passengers.size; local.i++)
				{
					self.passengers[local.i] takedamage
					self.passengers[local.i] damage $player[local.i] 15000 $player[local.i] (0 0 0) (0 0 0) (0 0 0) 0 9 0 0
				}
				if(self.driver != NIL && self.driver != NULL && self.model != "models/vehicles/sdkfz.tik" && self.model != "models/vehicles/sdkfz_afrika.tik" && self.model != "models/vehicles/shermantank.tik")
				{
					self.driver takedamage
					self.driver damage $player[local.i] 15000 $player[local.i] (0 0 0) (0 0 0) (0 0 0) 0 9 0 0
				}
			}
		}

		if(isalive self) // need "isalive" check to avoid "cannot give health to dead entities" error
		{
			self.health = local.health
			if(self.damagetrig != NIL && self.damagetrig != NULL && self.damagetrig.health > 0) { self.damagetrig.health = local.health }
		}

		if(self.shooter != NIL) { self thread shooter_NIL }
		if(self.nodamage == 1) { self.nodamage = 0; self takedamage }
		waitframe
	}
end

shooter_NIL:

	waitframe
	if(self != NULL) { self.shooter = NIL }
end

vehicletrigger:

	if($(self.name + "_trig") != NULL) { $(self.name + "_trig") remove }
	local.trig = spawn trigger_use targetname (self.name + "_trig")
	local.trig.origin = self.origin
	local.trig setsize ( -105 -105 -5 ) ( 105 105 125 )
	local.trig.vehicle = self
	local.trig glue self
	local.trig setthread triggered
end

triggered:

	local.player = parm.other
	if(local.player.classname != Player) { end }

	if(self.vehicle == NULL || self.vehicle.flooded == 1 || self.vehicle.dead == 1 || local.player == NIL || local.player == NULL || local.player.enteringvehicle == 1 || !isalive local.player || local.player.dead == 1 || level.change_team_score == 1 || level.bbactive == 0 || local.player.driving == 1 || local.player.passenger == 1 || local.player.flying == 1 || local.player.missile != NIL || local.player.leanleftheld == 1 || local.player.leanrightheld == 1) { end }

	if(self.vehicle != NULL)
	{
		if(self.vehicle.driver != NIL)
		{
			if(self.vehicle.gun != NIL && self.vehicle.gun != NULL && (self.vehicle.turretplayer == NIL || self.vehicle.turretplayer == NULL))
			{
				if(local.player getposition == "crouching") { self.vehicle thread passengers }
				else { self.vehicle thread turretslot local.player }
				end
			}

			if(self.vehicle.passengers.size < self.vehicle.seats) { self.vehicle thread passengers }
			else { local.player iprint "There are no seats available." }
		}
		else { self.vehicle thread playergetin }
	}
end

playergetin:

	local.player = parm.other
	if(local.player.classname != Player) { end }
	local.team = local.player.dmteam
	if(self.attachingdriver == 1) { end }
	self.attachingdriver = 1
	local.player.enteringvehicle = 1

	if(self.gun != NIL && self.gun != NULL) { local.player iprint "Entering vehicle... press FIRE to use turret... JUMP to use passenger seats." }
	else { local.player iprint "Entering vehicle... JUMP to use passenger seats." }

	for(local.s = 1; local.s <= self.seats; local.s++)
	{
		if(self.passengers[local.s] != NIL && self.passengers[local.s] != NULL && (self.passengers[local.s].dmteam != local.player.dmteam || getcvar("g_gametype") == "1")) { local.cancel = 1 }
	}
	if(self.turretplayer != NIL && self.turretplayer != NULL && (self.turretplayer.dmteam != local.player.dmteam || getcvar("g_gametype") == "1")) { local.cancel = 1 }
	if(local.cancel == 1)
	{
		local.player iprint "An enemy player is in this vehicle!"
		local.player.enteringvehicle = 0
		self.attachingdriver = 0
		end
	}

	local.player safeholster 1
	local.c = 0
	local.fireholding = 0
	local.standing = 0
	while(self != NULL && local.player != NULL && local.c <= 20) // wait 1
	{
		if(local.player.fireheld != 1 && local.fireholding == 1 && self.gun != NIL && self.gun != NULL && (self.turretplayer == NIL || self.turretplayer == NULL))
		{
			local.player.enteringvehicle = 0
			self.attachingdriver = 0
			self thread turretslot local.player
			end
		}

		for(local.s = 1; local.s <= self.seats; local.s++)
		{
			if(self.passengers[local.s] == NIL) { break }
		}
		if(local.player getposition != "standing" && local.standing == 1 && local.s <= self.seats && local.player getmovement != "falling")
		{
			local.player safeholster 0
			local.player.enteringvehicle = 0
			self.attachingdriver = 0
			self thread passengers
			end
		}

		if(local.player.fireheld == 1) { local.fireholding = 1 }
		if(local.player getposition == "standing") { local.standing = 1 }
		local.c++
		waitframe
	}

	if(self == NULL || self.flooded == 1 || self.dead == 1 || self.driver != NIL || local.player == NIL || local.player == NULL || !isalive local.player || local.player.dmteam != local.team || local.player.dead == 1 || level.change_team_score == 1 || level.bbactive == 0 || local.player.driving == 1 || local.player.passenger == 1 || local.player.flying == 1 || local.player.missile != NIL)
	{
		if(self != NULL) { self.attachingdriver = 0 }
		if(local.player != NULL) { local.player.enteringvehicle = 0 }
		end
	}
	if(local.player.leanleftheld == 1 || local.player.leanrightheld == 1)
	{
		if(self != NULL) { self.attachingdriver = 0 }
		local.player.enteringvehicle = 0
		local.player safeholster 0
		local.player iprint "You canceled entering vehicle by leaning left/right."
		end
	}
	if(local.player.isdog == 1)
	{
		if(self != NULL) { self.attachingdriver = 0 }
		local.player.enteringvehicle = 0
		local.player iprint ("Dogs cannot drive vehicles.")
		end
	}

	self.driver = local.player
	self.driver.driving = 1
	self.driver.drivingent = self
	local.driver = self.driver
	self.player_owner = self.driver
	self.passengers[0] = NIL // initialize as array to make size = 0 instead of size = -1

	self.driver forcelegsstate STAND
	self.driver hide
	self.driver nodamage // keep this off until the player receives damage, then quickly do "takedamage" and give damage, before doing "nodamage" again in "healthboost" thread (allows for more damage types such as bazooka rockets to count as kills).
	self.driver notsolid
	if(self.noheadlights != 1 && self.nohorn != 1) { self.driver iprint ("Lean Left = honk horn, Lean Right = turn on/off headlights.") }
	if(self.noheadlights != 1 && self.nohorn == 1) { self.driver iprint ("Lean Right = turn on/off headlights.") }
	if(self.noheadlights == 1 && self.nohorn != 1) { self.driver iprint ("Lean Left = honk horn.") }
	self.driver iprint ("JUMP = exit vehicle, hold FIRE = look behind.")
	self.driver.driving_state_jump = 0
	if(local.player.fireheld == 1 && self.gun != NIL && self.gun != NULL) { local.player iprint "To use 30 Cal Turret: FIRE once, then let go of FIRE before entering vehicle." }

	self attachdriverslot 0 self.driver //attachpassengerslot //attachturretslot
	self thread dummyavatar

	self waitthread spawn_driver_seat_and_trigs
	if($("driver_seat_" + self.entnum) != NULL) { self.driver glue $("driver_seat_" + self.entnum) }
	if($("rear_view_" + self.entnum) != NULL) { local.rearview = 1 }

	if(local.driver.using_pack == 1)
	{
		local.driver stufftext "globalwidgetcommand june6 linkcvar phealth"
		local.driver stufftext "globalwidgetcommand june6 statbar vertical 0 100"
		local.driver stufftext "globalwidgetcommand charliesector linkcvar phealth"
		local.driver stufftext ("set phealth " + int(local.driver.health))
	}
	else { local.driver thread display }

	ihuddraw_alpha local.player 110 0
	ihuddraw_virtualsize local.player 110 1
	ihuddraw_alpha local.player 110 .8
	ihuddraw_font local.player 110 "verdana-12"
	ihuddraw_color local.player 110 .85 .85 0
	ihuddraw_rect local.player 110 330 222 200 14 
	ihuddraw_string local.player 110 "" // "Turret User:   0"
	local.turretuser_hud = 0
	local.turretuser_count = 0

	ihuddraw_alpha local.player 111 0
	ihuddraw_virtualsize local.player 111 1
	ihuddraw_alpha local.player 111 .8
	ihuddraw_font local.player 111 "verdana-12"
	ihuddraw_color local.player 111 .85 .85 0
	ihuddraw_rect local.player 111 330 212 200 14 
	ihuddraw_string local.player 111 "" // "Passengers:   0"
	local.passengers_hud = 0
	local.stufftext_c = 0

	local.c = 5.000 	// vehicle speed divisor; Higher = starting speed is much slower (total change is larger), Lower = starting speed is closer to max speed (total change is smaller).
	local.decel_rate = 30 	// how many divisions of local.c for deceleration/acceleration. Higher = more time to reach max speed, Lower = less time to reach max speed.
	local.deceleration = local.c
	local.drivervelocity_old = ( 0 0 0 )
	self.movingforward = 0
	self.movingbackward = 0
	local.d = local.c	// vehicle turnrate will increase 1.875x as fast when accelerating, but will decrease 3.750x as fast when decelerating.

	local.player.enteringvehicle = 0
	self.attachingdriver = 0
	while(self != NULL && self.dead != 1 && self.flooded != 1 && isalive self.driver && self.driver.dmteam == local.team && self.driver.dead != 1 && level.change_team_score != 1 && level.bbactive != 0)
	{
		if(self.driver.driving_state_left == 1 && self.driver.driving_state_right != 1)
		{
			if(self.angles[2] > 180) { self.driver.viewangles = ( (self.angles[2] * -1 + 360 + 10) (self.angles[1] + 90) (self.angles[0] * -1) ) }
			else if(self.angles[2] < -180) { self.driver.viewangles = ( (self.angles[2] * -1 - 360 + 10) (self.angles[1] + 90) (self.angles[0] * -1) ) }
			else { self.driver.viewangles = ( (self.angles[2] * -1 + 10) (self.angles[1] + 90) (self.angles[0]) ) }
		}
		if(self.driver.driving_state_left != 1 && self.driver.driving_state_right == 1)
		{
			if(self.angles[2] > 180) { self.driver.viewangles = ( (self.angles[2] - 360 + 10) (self.angles[1] - 90) (self.angles[0] * -1) ) }
			else if(self.angles[2] < -180) { self.driver.viewangles = ( (self.angles[2] + 360 + 10) (self.angles[1] - 90) (self.angles[0] * -1) ) }
			else { self.driver.viewangles = ( (self.angles[2] + 10) (self.angles[1] - 90) (self.angles[0] * -1) ) }
			
		}
		if(self.driver.driving_state_left != 1 && self.driver.driving_state_right != 1) { self.driver.viewangles = ( (self.angles[0] + 10) self.angles[1] self.angles[2] ) }

		if(self.driver.driving_state_jump == 1 || self.flooded == 1) // Press JUMP to exit, or force-exit if vehicle gets flooded by a Light Bomb exploding on it.
		{
			self thread driverreset
			self thread vehiclereset
			self.driver thread wallstuck_fix
			self.driver = NIL
			break
		}

		if(self.turretplayer != NIL && self.turretplayer != NULL) { local.turretuser_count = 1 }
		else { local.turretuser_count = 0 }
		if(local.turretuser_hud != local.turretuser_count)
		{
			if(local.turretuser_count == 1) { ihuddraw_string local.player 110 "Turret User:   1" }
			else { ihuddraw_string local.player 110 "" }
			local.turretuser_hud = local.turretuser_count
		}
		if(self.passengers.size != local.passengers_hud)
		{
			if(self.passengers.size > 0) { ihuddraw_string local.player 111 ("Passengers:   " + self.passengers.size) }
			else { ihuddraw_string local.player 111 "" }
			local.passengers_hud = self.passengers.size
		}

		if(self.driver.useheld != 1)
		{
			if(self.driver.fireheld == 1) // hold FIRE for rear-view mirror (look backwards)
			{
				self.driver.viewangles = ( (10 + self.angles[0] * -1) (self.angles[1] + 180) (self.angles[2] * -1) )

				if(local.firehelding != 1 && local.rearview == 1)
				{
					self waitthread rearview_adjust 1
				}
			}
			else if(local.firehelding == 1) { self waitthread rearview_adjust 0 }
	
			if(self.driver.leanleftheld == 1 && local.toggle != 1 && self.nohorn != 1) // lean left to honk horn
			{
				self.driver iprint "Honking the horn."
				if(self.model == "models/vehicles/opeltruck.tik" || self.model == "models/vehicles/opeltruckgreen.tik" || self.model == "models/vehicles/opeltruckgreen_canopy.tik" || self.model == "models/vehicles/gmctruck.tik" || self.model == "models/vehicles/m3.tik")
				{
					self playsound horntruck
				}
				else if(self.model == "models/vehicles/bmwbike.tik") { self playsound hornbike }
				else { self playsound horncar }
				local.toggle = 1
			}
			if(self.driver.leanrightheld == 1 && local.toggle != 1 && self.noheadlights != 1) // lean right to turn on/off headlights
			{
				if(self.corona != 1 && local.toggle2 != 1) { self thread headlights; local.toggle2 = 1 }
				if(self.corona == 1 && local.toggle2 != 1) { self thread headlights; local.toggle2 = 1 }
				local.toggle = 1
			}
			if(self.driver.leanleftheld != 1 && self.driver.leanrightheld != 1) { local.toggle = 0; local.toggle2 = 0 }
		}

		if(self.driver.viewangles[0] > 180) { self.driver.viewangles = ( (10 + (self.angles[0] - 360)) self.driver.viewangles[1] self.driver.viewangles[2] ) } // any viewangles[0] +/- 180 will cause camera issues (going under vehicle).
		if(self.driver.viewangles[0] < -180) { self.driver.viewangles = ( (self.driver.viewangles[0] + 360) self.driver.viewangles[1] self.driver.viewangles[2] ) } // prevent camera from moving too far down.

		if(self.vehiclespeed == 0) { self.movingforward = 0; self.movingbackward = 0 }

		if(self.velocity != ( 0 0 0 )) // make vehicles drive faster in reverse, only when holding S (walk backwards key) and when holding FIRE (looking behind).
		{
			if(self.driver.driving_state_backward == 1)
			{
				if(self.movingforward == 1 && local.c < local.deceleration) // slowing down, before reversing begins.
				{
					local.c += local.deceleration * 2.000 / local.decel_rate
					local.d += 3.750 * local.deceleration / local.decel_rate
					if(local.c > local.deceleration) { local.c = local.deceleration; self.vehiclespeed = 0 }
					if(local.d > local.deceleration) { local.d = local.deceleration }
					self.vehiclespeed = self.vehiclespeed_max / local.c
					self.velocity = self.driver.velocity * (self.vehiclespeed / self.vehiclespeed_max * -1) + self.forwardvector * self.vehiclespeed
				}
				else
				{
					local.c -= local.deceleration / local.decel_rate
					local.d -= 1.875 * local.deceleration / local.decel_rate
					if(local.c < 1) { local.c = 1 }
					if(local.d < 1) { local.d = 1 }
					self.vehiclespeed = self.vehiclespeed_max / local.c
					self.velocity = self.driver.velocity + self.forwardvector * self.vehiclespeed * -0.500 // only reverse at half the maximum vehicle speed
					self.movingforward = 0
					self.movingbackward = 1
				}
			}
			else // make vehicles drive faster, only when holding W (forward key).
			{
				if(self.movingbackward == 1 && local.c < local.deceleration) // slowing down, before driving forward begins.
				{
					local.c += local.deceleration * 2.000 / local.decel_rate
					local.d += 3.750 * local.deceleration / local.decel_rate
					if(local.c > local.deceleration) { local.c = local.deceleration; self.vehiclespeed = 0 }
					if(local.d > local.deceleration) { local.d = local.deceleration }
					self.vehiclespeed = self.vehiclespeed_max / local.c
					self.velocity = self.driver.velocity * (self.vehiclespeed / self.vehiclespeed_max * -1) + self.forwardvector * self.vehiclespeed * -0.500 // only reverse at half the maximum vehicle speed
				}
				else
				{
					local.c -= local.deceleration / local.decel_rate
					local.d -= 1.875 * local.deceleration / local.decel_rate
					if(local.c < 1) { local.c = 1 }
					if(local.d < 1) { local.d = 1 }
					self.vehiclespeed = self.vehiclespeed_max / local.c
					self.velocity = self.driver.velocity + self.forwardvector * self.vehiclespeed
					self.movingforward = 1
					self.movingbackward = 0
				}
			}

			if(self.turningrate / local.d < 1) { self.turnrate = 1 }
			else if(self.turningrate / local.d < self.turningrate) { self turnrate (self.turningrate / (local.d * 0.500)) }
			else { self turnrate self.turningrate }
		}
		else
		{
			if(local.c == 1)
			{
				if(self.model == "models/vehicles/opeltruck.tik" || self.model == "models/vehicles/opeltruckgreen.tik" || self.model == "models/vehicles/opeltruckgreen_canopy.tik" || self.model == "models/vehicles/gmctruck.tik")
				{
					self playsound opeltruck_snd_shift2
				}
				else if(self.model == "models/vehicles/sdkfz.tik" || self.model == "models/vehicles/sdkfz_afrika.tik" || self.model == "models/vehicles/m3.tik" || self.model == "models/vehicles/shermantank.tik")
				{
					self playsound sdkfz_snd_shift2
				}
				else { self playsound jeep_snd_shift2 }
			}
			local.d += 3.750 * local.deceleration / local.decel_rate
			if(local.d > local.deceleration) { local.d = local.deceleration }

			local.c += local.deceleration / local.decel_rate
			if(local.c > local.deceleration) { local.c = local.deceleration; self.vehiclespeed = 0 }
			else { self.vehiclespeed = self.vehiclespeed_max / local.c }

			if(self.driver.driving_state_backward == 1) { self.velocity = local.drivervelocity_old + self.forwardvector * self.vehiclespeed * -1 }
			else { self.velocity = local.drivervelocity_old + self.forwardvector * self.vehiclespeed }
		}

		if(local.driver.fireheld == 1) { local.firehelding = 1 }
		else { local.firehelding = 0 }

		local.drivervelocity_old = self.driver.velocity
		if(local.stufftext_c == 10) { local.driver stufftext ("set phealth " + int(local.driver.health)) }

		local.stufftext_c++
		if(local.stufftext_c > 10) { local.stufftext_c = 0 } // twice every second.
		waitframe
	}

	if(self != NULL) // spawn in the new vehicle and remove the old one.
	{
		thread main self.name self.model self.origin self.angles self.health self.vehiclespeed_max self.resettime self.headlights self.noheadlights 1

		if(self.driver != NIL && self.driver != NULL)
		{
			if(self.driver.dmteam == local.team && level.change_team_score != 1 && level.bbactive != 0) { self thread driverreset }
			else { self thread driverreset 2 } // if the player switched teams without dying, make sure they don't tele back to the vehicle
			self thread vehiclereset
		}
		if(self.turretplayer != NIL && self.turretplayer != NULL) { self waitthread turretplayer_reset self.turretplayer.dmteam self.turretplayer }

		if(self != NULL)
		{
			self.driver = NIL // the old vehicle must be properly removed, otherwise the server will crash if anyone driving the vehicle leaves the game (becomes NULL).
			if(self.dead != 1 && self.flooded != 1)
			{
				if(self.gun != NIL && self.gun != NULL) { self.gun remove }
				self remove
			}
		}
	}
	waitframe
	if(local.driver != NULL)
	{
		local.driver.driving = 0
		local.driver.passenger = 0
		local.driver.drivingent = NIL
		if(!isalive local.driver) { local.driver stufftext ("set phealth 0") }
		ihuddraw_string local.player 110 ""
		ihuddraw_string local.player 111 ""

		if(local.driver.using_pack == 1)
		{
			local.driver stufftext "globalwidgetcommand june6 linkcvar fuel"
			local.driver stufftext ("globalwidgetcommand june6 statbar vertical 0 " + level.jetpack_max_fuel)
			local.driver stufftext "globalwidgetcommand charliesector linkcvar fuel"
		}
		else
		{
			local.driver stufftext "hidemenu dday1"
			local.driver stufftext "hidemenu dday2"
		}

		local.origin = local.driver.origin
		while(local.driver != NULL && !isalive local.driver && local.driver.dmteam != "spectator")
		{
			local.driver.origin = ( local.origin[0] local.origin[1] local.driver.origin[2] ) // for some reason, drivers' dead bodies would move forward across the ground until they hit a wall.
			local.driver notsolid
			local.driver droptofloor
			waitframe
		}
	}
end

driverreset local.status:

	if(self.driver == NIL) { end } // if the vehicle blew up with nobody driving it, end this thread.

	if(local.status != 1) { cueplayer }				// reattaches camera to player's head
	self detachdriverslot 0 self.driver
	self.driver.viewangles = ( 0 self.driver.viewangles[1] 0 )
	if($("driver_seat_" + self.entnum) != NULL) { self.driver unglue }
	self.driver exit	// not needed, but added as a redundancy.
	self.driver.driving = 0
	self.driver.passenger = 0

	if(local.status != 2)
	{
		self.driver show
		if(local.status != 1) { self.driver solid }
		self.driver takedamage
		self.driver forcetorsostate STAND // without this, players will be stuck in noclip mode, even though noclip isn't used for drivers (doing "self.driver noclip; self driver noclip" also works).
		self.driver forcelegsstate STAND
		self.driver.origin += (angles_toup self.angles * self.outheight + angles_toforward self.angles * self.outforward)
		self.driver.viewangles = ( self.driver.viewangles[0] self.driver.viewangles[1] 0 )
	}
	else { self.driver respawn }
end

headlights:

	if(self.headlights_inuse == 1) { end }
	self.headlights_inuse = 1

	self playsound light_switch
	if(self != NULL && self.driver != NIL && self.driver != NULL && self.corona != 1)
	{
		wait 0.23 // getting the timing right
		if(self == NULL) { end }
		self.driver iprint "Turning on headlights."
		self.headlights = 1

		if(self.model == "models/vehicles/opeltruck.tik" || self.model == "models/vehicles/opeltruckgreen.tik" || self.model == "models/vehicles/opeltruckgreen_canopy.tik")
		{
			self thread deadcorona "light left"
			self thread deadcorona "light right"
		}
		else { self thread deadcorona }
		self thread illuminate "left"
		self thread illuminate "right"
		self.headlights_inuse = 0
		end
	}
	if(self != NULL && self.driver != NIL && self.driver != NULL && self.corona == 1)
	{
		wait 0.28
		if(self == NULL) { end }
		self.driver iprint "Turning off headlights."
		self.corona = 0
		self.headlights = 0
		self.headlights_inuse = 0
	}
end

vehicledamage:

	local.c = 0
	while(self != NULL && self.health > 0)
	{
		if(self != NULL)
		{
			local.previoushealth = self.health
			if(local.c > 0) { local.c-- }
		}
		waitframe
		if(self != NULL && local.previoushealth > self.health)
		{
			local.c = local.c + 2
			self playsound damage_vehicle
			//if(local.c == 2) { exec global/earthquake.scr .2 3 0 0 } // if tank is getting constantly damaged per frame, stop earthquake from spamming. (removed, since it was still getting annoying)
		}
	}
end

vehicledeath:

	self waittill death // when waiting until "death", vehicle is not NULL yet
	self stoploopsound
	self playsound explode_truck
	self.dead = 1

	local.desvehicle = spawn script_model
	local.desvehicle.origin = self.origin
	local.desvehicle.angles = self.angles
	local.desvehicle.scale = self.scale
	local.desvehicle thread move_stuck_players

	if(self.desmodel == NIL)
	{
		if(self.angles[2] > 5 && self.angles[2] < 180) { local.one = 1 }
		if(self.angles[2] > 180 && self.angles[2] < 355) { local.one = -1 }
		if(self.angles[2] <= 5 || self.angles[2] >= 345)
		{
			local.r = randomint(2)
			if(local.r == 0) { local.one = 1 }
			if(local.r == 1) { local.one = -1 }
		}

		local.desvehicle model self.model
		local.desvehicle.angles = self.angles + ( 0 0 ((randomint(30) + 5) * local.one) )
	}
	else { local.desvehicle model self.desmodel }

	if(self.spawndeathfire == 1)
	{
		local.desvehicle loopsound vehicledeathfire

		if(self.model == "models/vehicles/jeep.tik" || self.model == "models/vehicles/jeep_bench.tik") { local.distance = 80 }
		else if(self.model == "models/vehicles/mercedes.tik") { local.distance = 80 }
		else if(self.model == "models/vehicles/m3.tik") { local.distance = 95 }
		else if(self.model == "models/vehicles/gmctruck.tik") { local.distance = 140 }
		else if(self.model == "models/vehicles/opeltruckgreen.tik" || self.model == "models/vehicles/opeltruckgreen_canopy.tik") { local.distance = 120 }
		else if(self.model == "models/vehicles/shermantank.tik") { local.distance = 0 }
		else if(self.model == "models/vehicles/bmwbike.tik") { local.distance = 25 }
		else { local.distance = 50 } // euro cars & trucks

		local.fire = spawn script_model
		local.fire model "models/emitters/fancyfire.tik"
		local.fire.origin = local.desvehicle.origin + local.desvehicle.forwardvector * local.distance + angles_toup local.desvehicle.angles * 42
		local.fire.angles = ( 0 0 0 )
		local.fire.scale = 2.5
		local.fire anim start
		local.fire notsolid
		local.smoke = spawn script_model
		local.smoke model "models/emitters/linger_smoke.tik"
		local.smoke.origin = local.desvehicle.origin + local.desvehicle.forwardvector * (local.distance - 25) + angles_toup local.desvehicle.angles * 42
		local.smoke.angles = ( 0 0 0 )
		local.smoke.scale = 5
		local.smoke anim start
		local.smoke notsolid

		if(self.desmodel == models/vehicles/bmwbike_d.tik) { local.fire.origin += ( 0 0 -25 ); local.smoke.origin += ( 0 0 -25 ) }
	}

	self thread driverreset 1					// use local.status = 1 for drivers that died
	self thread mainreset local.desvehicle local.fire local.smoke	// waiting self.resettime seconds until a new vehicle is spawned in

	self thread driver_shooter
	self thread kill_riders
	self.driver = NIL

	if(self.turretplayer != NIL) { self waitthread turretplayer_reset self.turretplayer.dmteam self.turretplayer 1 } // ensures that the turretplayer is alaways detached after vehicle dies

	if(self != NULL && $(self.name + "_trig") != NULL) { $(self.name + "_trig") remove }
	if(self != NULL && self.gun != NIL && self.gun != NULL) { self.gun remove }
	exec global/earthquake.scr .35 2 0 0

	if(self != NULL && self.shooter != NIL && self.shooter != NULL)
	{
		if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { local.shooter = self.shooter.player_owner }
		else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { local.shooter = self.shooter.owner }
		else { local.shooter = self.shooter }
	}
	local.blewup = 1
	for(local.i = 1; local.i <= $player.size; local.i++) // use this instead of radiusdamage, so death explosions can count as score/kills.
	{
		if(vector_length(local.desvehicle.origin - $player[local.i].origin) <= 600) // "local.explode" emitters cannot be used with "cansee"
		{
			if(local.shooter == NIL || local.shooter == NULL)
			{
				if($player[local.i].driving != 1 && $player[local.i].flying != 1 && $player[local.i] cansee local.desvehicle 360) // "cansee self" does not work.
				{
					$player[local.i] damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0
				}
				else if($player[local.i].drivingent != NIL && $player[local.i].drivingent != NULL)
				{
					if($player[local.i].flying == 1) { $("planehit" + $player[local.i].entnum) damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else { $player[local.i].drivingent damage $world 500 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
				}
			}
			else if($player[local.i] != local.shooter && $player[local.i].dmteam == local.shooter.dmteam && getcvar("g_teamdamage") != "1" && getcvar("g_gametype") != "1") { local.blewup = 0 }
			else
			{
				if($player[local.i].driving != 1 && $player[local.i].flying != 1 && $player[local.i] cansee local.desvehicle 360)
				{
					$player[local.i] damage local.shooter 500 local.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 // "damage" does not hurt teammates, but scriptbazookaexplosion.tik does
				}
				else if($player[local.i].drivingent != NIL && $player[local.i].drivingent != NULL)
				{
					$player[local.i].drivingent.shooter = local.shooter
					if($player[local.i].flying == 1) { $("planehit" + $player[local.i].entnum) damage local.shooter 500 local.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else { $player[local.i].drivingent damage local.shooter 500 local.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
				}
			}
		}
	}
	if(self != NULL) { self remove }

	local.boom = spawn script_model
	local.boom model "models/emitters/mortar_higgins.tik"
	local.boom.origin = local.desvehicle.origin
	local.boom.angles = ( 0 -90 0 ) + ( 260 0 0 )
	local.boom.scale = 1.0
	local.boom anim start
	local.boom notsolid

	local.debris = spawn script_model targetname "mortar_dirt_nosound"
	local.debris model "emitters/mortar_dirt_nosound.tik" 
	local.debris.origin = local.desvehicle.origin
	local.debris.scale = 0.8
	local.debris anim start
	local.debris notsolid
	waitframe
	local.boom remove
	local.debris remove
	if(local.blewup == 1) { radiusdamage local.desvehicle.origin 500 600 } // this must be one frame after other damages in this thread, otherwise chain-reaction kills will not count.
end

driver_shooter:

	if(self.driver == NIL || self.driver == NULL) { end }

	local.driver = self.driver
	local.driver.driver_shooter = self.shooter
	waitframe
	if(local.driver != NULL) { local.driver.driver_shooter = NIL }
end

kill_riders:

	if(self.turretplayer != NIL && self.turretplayer != NULL)
	{
		if(self.shooter != NIL)
		{
			if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.turretplayer damage self.shooter.player_owner 9999999 self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.turretplayer damage self.shooter.owner 9999999 self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			else if(self.shooter != NULL) { self.turretplayer damage self.shooter 9999999 self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
		}
		else { self.turretplayer volumedamage 9999999 }
	}

	if(self.passengers.size >= 1)
	{
		for(local.i = 1; local.i <= self.passengers.size; local.i++)
		{
			if(self.passengers[local.i] != NIL && self.passengers[local.i] != NULL)
			{
				if(self.shooter != NIL)
				{
					self.passengers[local.i] takedamage
					if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.passengers[local.i] damage self.shooter.player_owner 9999999 self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.passengers[local.i] damage self.shooter.owner 9999999 self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					else if(self.shooter != NULL) { self.passengers[local.i] damage self.shooter 9999999 self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					self.passengers[local.i] nodamage
				}
				else { self.passengers[local.i] volumedamage 9999999 }
			}
		}
	}

	if(self.shooter != NIL)
	{
		if(self.driver != NIL)
		{
			self.driver takedamage
			if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { self.driver damage self.shooter.player_owner 9999999 self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { self.driver damage self.shooter.owner 9999999 self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			else if(self.shooter != NULL) { self.driver damage self.shooter 9999999 self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
			self.driver nodamage
		}
	}
	else if(self.driver != NIL) { self.driver volumedamage 9999999 } // let's make sure the driver is dead.
end

mainreset local.desvehicle local.fire local.smoke:

	if(self.resettime == NIL || self.resettime <= 0) { end }

	local.name = self.name
	local.model = self.model
	local.origin = self.originold  // respawns the vehicle where it was destroyed, only by setting "thread main" origin/angles to "local.origin" "local.angles".
	local.angles = self.angles
	local.health = level.vehicle_inithealth[self.name]
	local.vehiclespeed = self.vehiclespeed_max
	local.resettime = self.resettime
	local.headlights = self.headlights
	local.noheadlights = self.noheadlights

	while(self != NULL) { waitframe }
	wait local.resettime

	if(local.fire != NIL && local.fire != NULL) { local.fire remove }
	if(local.smoke != NIL && local.smoke != NULL) { local.smoke remove }
	local.desvehicle remove
	thread main local.name local.model level.vehicle_initorigin[local.name] level.vehicle_initangles[local.name] local.health local.vehiclespeed local.resettime local.headlights local.noheadlights
end

////////////////////////////////////////////////////////////////////////

floodedreset:

	local.name = self.name
	local.model = self.model
	local.origin = self.originold  // respawns the vehicle where it was destroyed, only by setting "thread main" origin/angles to "local.origin" "local.angles".
	local.angles = self.angles
	local.health = level.vehicle_inithealth[self.name]
	local.vehiclespeed = self.vehiclespeed_max
	local.resettime = self.resettime
	local.headlights = self.headlights
	local.noheadlights = self.noheadlights

	self anim stop_wheels // turn off any headlights, and remove light beams from opeltrucks.
	self.corona = 0
	self.flooded = 1
	$(self.name + "_trig") setthread flooded
	$(self.name + "_trig") message ("*** This vehicle has been flooded. ***")

	if(self.model == "models/vehicles/jeep.tik" || self.model == "models/vehicles/jeep_bench.tik") { local.distance = 70 }
	else if(self.model == "models/vehicles/mercedes.tik") { local.distance = 80 }
	else if(self.model == "models/vehicles/m3.tik") { local.distance = 95 }
	else if(self.model == "models/vehicles/gmctruck.tik") { local.distance = 140 }
	else if(self.model == "models/vehicles/opeltruck.tik" || self.model == "models/vehicles/opeltruckgreen.tik" || self.model == "models/vehicles/opeltruckgreen_canopy.tik") { local.distance = 120 }
	else { local.distance = 25 } // bmwbikes

	local.smoke = spawn script_model
	local.smoke model "models/emitters/linger_smoke.tik"
	local.smoke.origin = self.origin + self.forwardvector * (local.distance - 25) + self.upvector * 42
	local.smoke.angles = ( 0 0 0 )
	local.smoke.scale = 5
	local.smoke anim start
	local.smoke notsolid
	local.smoke loopsound vehicledeathwater

	local.c = 0
	while(self != NULL && self.dead != 1 && local.c <= self.resettime * 20)
	{
		local.smoke.origin = self.origin + self.forwardvector * local.distance + self.upvector * 42
		local.c++
		waitframe
	}
	local.smoke remove
	if(self == NULL || self.dead == 1) { end }

	if(self.gun != NIL && self.gun != NULL) { self.gun remove }
	self remove
	thread main local.name local.model level.vehicle_initorigin[local.name] level.vehicle_initangles[local.name] local.health local.vehiclespeed local.resettime local.headlights local.noheadlights
end

flooded:

	local.player = parm.other
	local.player iprint ("Wait until the vehicle resets again.")
end

////////////////////////////////////////////////////////////////////////

turretslot local.player:

	//if(local.player.isdog == 1) { local.player iprint ("Dogs cannot use vehicle turrets."); end }
	if(self.driver != NIL && self.driver != NULL && local.player.dmteam != self.driver.dmteam && local.player.dmteam != "spectator" && getcvar("g_gametype") != "1")
	{
		local.player iprint ("An enemy player is driving this vehicle!")
		end
	}

	local.team = local.player.dmteam
	waitframe	// need this here, otherwise driver & turret player could be attached to the same seat!
	if(self == NULL || self.flooded == 1 || self.dead == 1 || self.turretplayer != NIL || local.player == NIL || local.player == NULL || !isalive local.player || local.player.dmteam != local.team || local.player == self.driver || local.player.passenger == 1 || local.player.driving == 1 || local.player.flying == 1 || local.player.dead == 1 || level.change_team_score == 1 || level.bbactive == 0) { end }

	self.turretplayer = local.player
	self.turretplayer.passenger = 1
	self.turretplayer.driving = 1
	self.turretplayer.turreting = 1
	self.turretplayer.remove_viewmodel = 0
	self.turretplayer.driving_state_jump = 0
	self.turretplayer forcetorsostate TURRET_START
	self.turretplayer iprint ("JUMP = exit turret.")
	self.turretplayer.turretingent = self // used with killstreaks/damagehandler.scr to properly give score to shooter if turretplayer's vehicle gets blown up by an enemy bazooka rocket.

	self unlock
	self.gun unlock
	self attachturretslot 0 local.player
	self.gun lock
	self lock
	if(self.model != "models/vehicles/jeep.tik") { self.turretplayer.scale = 0.5 } // self.turretplayer hide
	local.player glue self.gun // keep player's angles aligned with 30cal turret.

	local.driver = self.driver
	local.team = local.player.dmteam
	local.targetname = self.targetname

	self.turretplayer_reattach = 0
	while(self != NULL && self.dead != 1 && self.flooded != 1 && self.turretplayer != NIL && self.turretplayer != NULL && isalive local.player && local.player.dmteam == local.team && local.player.dead != 1 && level.change_team_score != 1 && level.bbactive != 0)
	{
		local.player.origin = self.gun.origin
		if(local.player.fireheld == 1) { self.gun playsound sndfire30cal }

		if(self.turretplayer.driving_state_jump == 1)
		{
			self.turretplayer_reattach = 0
			self waitthread turretplayer_reset local.team local.player
			end
		}

		local.driver = self.driver
		if(self.driver != NIL && self.driver != NULL) { self.turretplayer_reattach = 1 }
		waitframe
	}
	if(self != NULL) { self waitthread turretplayer_reset local.team local.player }

	if(local.player != NULL)
	{
		local.player.passenger = 0
		local.player.driving = 0
		local.player.turreting = 0
		local.player.remove_viewmodel = 1
		local.player.scale = 1
		local.player unglue
		//local.player show
	}
end

turretplayer_reset local.team local.player local.dead:

	if(local.player == NIL || local.player == NULL) // if turret player left the game
	{
		self lock
		self.gun lock
		self.turretplayer = NIL // if turret player leaves, then rejoins, he cannot see the vehicle's turretgun, but everyone else can (weird graphics glitch?).
		end			// for the rejoining player to fix it: enter the turret again, or wait for the vehicle to respawn.
	}

	local.player unglue
	local.player.passenger = 0
	local.player.driving = 0
	local.player.turreting = 0
	local.player.scale = 1
	if(local.player.dmteam != "spectator") { local.player show }
	local.player thread wallstuck_fix
	local.player forcetorsostate STAND
	//local.player forcelegsstate STAND // do not use this when exiting turrets; it will force players into noclip after exiting.
	local.player takedamage // this prevents a rare bug that kept the turret player from ever dying again (player is somehow, but only sometimes given "nodamage"?)
	local.player.turretingent = NIL

	if(isalive local.player && local.player.dmteam != "spectator")
	{
		self unlock
		self.gun unlock
		self douse local.player
		local.player exit
		local.player forcelegsstate STAND
	}
	self lock
	self.gun lock
	self.turretplayer = NIL
	local.targetname = self.targetname

	if(local.player.dmteam != local.team && local.player.dmteam != "spectator") { local.player respawn }
	else { local.player.viewangles = ( self.gun.angles[0] self.gun.angles[1] 0 ) }

	if(self.model == "models/vehicles/jeep.tik") { local.multiplier = -25 }
	else { local.multiplier = 0 }

	if(local.player.dmteam == local.team) { local.player.origin = self.gun.origin + angles_toforward self.angles * local.multiplier + (angles_toup self.angles * self.outheight) }

	if(self.turretplayer_reattach != 1)
	{
		self.gun remove
		waitframe	// need this for the turret to be fully removed, before spawning a new one.
		if(self != NULL)
		{
			self spawnturret 0 "models/vehicles/jeep_30cal.tik"
			self.gun = self queryturretslotentity 0
			self.gun notsolid
			self.gun pitchcaps ( -60 35 0 )
			if(self.model != "models/vehicles/jeep.tik") { self.gun.scale = 0.5 }
		}
	}
	if(self != NULL && self.dead != 1) { self thread turretplayer_reattach local.player local.team }
end

turretplayer_reattach local.player local.team:

	local.targetname = self.targetname
	if(self != NULL && self.flooded != 1 && self.turretplayer_reattach == 1 && isalive local.player && local.player.dmteam == local.team)
	{
		while(self != NULL) { waitframe }
		local.c = 0
		while($(local.targetname) == NULL) { local.c++; waitframe } // wait until the vehicle respawns before reattaching player.
		if(local.c > 20) { end }

		if($(local.targetname) != NULL && isalive local.player && local.player.dmteam == local.team) { $(local.targetname) thread turretslot local.player }
	}
end

remove_viewmodels:

	while(1)
	{
		for(local.e = 0; local.e <= 868; local.e++)
		{
			local.entity = getentity(local.e)
			if(local.entity != NULL && (local.entity.model == "models/vehicles/jeep_30cal_viewmodel.tik" || local.entity.model == "models/vehicles/sdkfz_mg42_viewmodel.tik"))
			{
				for(local.i = 1; local.i <= $player.size; local.i++)
				{
					local.dist = vector_length(local.entity.origin - $player[local.i].origin)
					if(local.dist <= 100 && $player[local.i].remove_viewmodel == 1) { local.entity remove; $player[local.i].remove_viewmodel = 0 }
				}
			}
			waitframe
		}
		waitframe
	}
end

////////////////////////////////////////////////////////////////////////

passengers local.player local.s:
	
	if(local.player == NIL) { local.player = parm.other }
	if(local.player.classname != Player) { end } // somehow the "self" DrivableVehicle entity was able to run this script as parm.other and crash the server; this line prevents that from ever happening.
	if(local.s == NIL) { local.s_nil = 1 }
	local.team = local.player.dmteam
	waitframe	// need this here, otherwise driver & passenger could be attached to the same seat!

	if(self == NULL || self.flooded == 1 || self.dead == 1 || local.player == NIL || local.player == NULL || !isalive local.player || local.player.dmteam != local.team || local.player == self.driver || local.player == self.turretplayer || local.player.passenger == 1 || local.player.driving == 1 || local.player.flying == 1 || local.player.dead == 1 || level.change_team_score == 1 || level.bbactive == 0) { end }

	if(local.s == NIL)
	{
		for(local.s = 1; local.s <= self.seats; local.s++)
		{
			if(self.passengers[local.s] == NIL) { self.passengers[local.s] = local.player; break } // assign player to the 1st available passenger seat
		}
		if(local.s > self.seats) { local.player iprint ("No more seats available."); end }

		if(self.driver != NIL && self.driver != NULL && local.player.dmteam != self.driver.dmteam && local.player.dmteam != "spectator" && getcvar("g_gametype") != "1")
		{
			self.passengers[local.s] = NIL
			local.player iprint ("An enemy player is driving this vehicle!")
			end
		}
	}
	else if(self.passengers[local.s] != NIL && self.passengers[local.s] != local.player) { local.player iprint ("This seat is already occupied."); end }
	else { self.passengers[local.s] = local.player }

	self waitthread spawn_driver_seat_and_trigs
	self waitthread spawn_passenger_seat local.s
	if($("passenger_seat_" + local.s + "_" + self.entnum) != NULL) { local.player glue $("passenger_seat_" + local.s + "_" + self.entnum) }

	if(local.s_nil == 1) { local.player take "models/items/binoculars.tik" } // using these will cause camera jittering again.
	local.player forcetorsostate VEHICLE_PASSENGER // prevents camera jittering.
	local.player forcelegsstate STAND
	//local.player hide
	//local.player noclip
	local.player nodamage // keep this off until the player receives damage, then quickly do "takedamage" and give damage, before doing "nodamage" again in "healthboost" thread (allows for more damage types such as bazooka rockets to count as kills).
	local.player notsolid // need this, otherwise vehicles cannot reverse properly.
	if(local.s_nil == 1)
	{
		if(self.seats > 1) { local.player iprint ("JUMP = exit vehicle. Hold FIRE(zoom) = look around. Lean Left/Right = change seats.") }
		else { local.player iprint ("JUMP = exit vehicle. Hold FIRE(zoom) = look around.") }
	}
	local.player.origin = self.origin
	local.player.passenger = 1
	local.player.ridingent = self
	local.player.driving = 1 // should help with other scripts.
	local.player.driving_state_jump = 0
	local.PI = 3.14159265359
	local.driver = self.driver
	local.outheight = self.outheight

	local.targetname = self.targetname
	local.passenger_reattach = 0
	while(self != NULL && self.dead != 1 && self.flooded != 1 && isalive local.player && local.player.dmteam == local.team && local.player.dead != 1 && level.change_team_score != 1 && level.bbactive != 0 && $("passenger_seat_" + local.s + "_" + self.entnum) != NULL)
	{
		local.player anim unarmed_stand_idle // need this, since VEHICLE_PASSENGER state uses "movetype anim" instead of "movetype legs", which omits all legs animations (player will landshark without this).

		if(local.player.fireheld != 1)
		{
			if(self.playerang_offset[local.s] != NIL) { local.player.viewangles = ( (self.angles[0] + 10) self.angles[1] self.angles[2] ) + ( self.angles[0] self.playerang_offset[local.s] self.angles[2] ) } // some vehicles' passengers should not face forward (view is blocked)
			else { local.player.viewangles = ( (self.angles[0] + 10) self.angles[1] self.angles[2] ) }
		}

		if(local.player.viewangles[0] > 180) { local.player.viewangles = ( (10 + (self.angles[0] - 360)) local.player.viewangles[1] local.player.viewangles[2] ) } // any viewangles[0] +/- 180 will cause camera issues (going under vehicle).
		if(local.player.viewangles[0] < -180) { local.player.viewangles = ( (local.player.viewangles[0] + 360) local.player.viewangles[1] local.player.viewangles[2] ) } // prevent camera from moving too far down.

		local.cycled = 0
		local.changeseats = 0
		local.newseat = 0
		local.p = local.s
		if(local.leaning == 0 && local.player.leanleftheld == 1 && local.player.leanrightheld != 1) // lean left to cycle upward through available passenger seats.
		{
			for(local.z = 1; local.z <= self.seats; local.z++)
			{
				if(local.p + local.z > self.seats && local.cycled != 1) { local.p = 1; local.z = 0; local.cycled = 1 }
				if(self.passengers[local.p + local.z] == NIL) { local.changeseats = 1; local.newseat = local.p + local.z; break }
			}
		}
		if(local.leaning == 0 && local.player.leanleftheld != 1 && local.player.leanrightheld == 1) // lean right to cycle downward through available passenger seats.
		{
			for(local.z = 1; local.z <= self.seats; local.z++)
			{
				if(local.p - local.z < 1 && local.cycled != 1) { local.p = self.seats; local.z = 0; local.cycled = 1 }
				if(self.passengers[local.p - local.z] == NIL) { local.changeseats = 1; local.newseat = local.p - local.z; break }
			}
		}

		if(local.player.driving_state_jump == 1 || local.changeseats == 1) // Press JUMP to exit vehicle.
		{
			local.player unglue
			if(local.player.isdog != 1) { local.player show }
			local.player give "models/items/binoculars.tik"
			local.player solid
			local.player takedamage
			//local.player noclip
			local.player forcetorsostate STAND
			local.player forcelegsstate STAND
			if(local.changeseats != 1) { local.player.origin += angles_toup self.angles * self.outheight }
			local.player.viewangles = ( local.player.viewangles[0] local.player.viewangles[1] 0 )

			local.player thread wallstuck_fix
			self.passengers[local.s] = NIL
			local.player.passenger = 0
			local.player.ridingent = NIL
			local.player.driving = 0
			if($("passenger_seat_" + local.s + "_" + self.entnum) != NULL) { $("passenger_seat_" + local.s + "_" + self.entnum) remove }

			if(local.changeseats == 1 && self.flooded != 1) { self thread passengers local.player local.newseat }
			end
		}
		if(local.player.leanleftheld != 1 && local.player.leanrightheld != 1) { local.leaning = 0 }

		local.driver = self.driver
		local.angles = self.angles
		if(self.driver != NIL && self.driver != NULL) { local.passenger_reattach = 1 }
		waitframe
	}
	if(self != NULL)
	{
		self.passengers[local.s] = NIL
		if($("passenger_seat_" + local.s + "_" + self.entnum) != NULL) { $("passenger_seat_" + local.s + "_" + self.entnum) remove }
	}

	if(local.player != NULL)
	{
		local.player unglue
		local.player.viewangles = ( 0 local.player.viewangles[1] 0 ) // passenger reset
		local.player.passenger = 0
		local.player.ridingent = NIL
		local.player.driving = 0
		if(local.player.dmteam != spectator)
		{
			if(isalive local.player) { local.player give "models/items/binoculars.tik" }
			if(local.player.isdog != 1) { local.player show }
			local.player solid
			local.player takedamage
			//local.player noclip
			local.player forcetorsostate STAND
			local.player forcelegsstate STAND
			if(local.player.dmteam == local.team) // if the passenger did not switch teams
			{
				local.player.origin += angles_toup local.angles * local.outheight
				local.player.viewangles = ( local.player.viewangles[0] local.player.viewangles[1] 0 )
				local.player thread wallstuck_fix
	
				if(local.driver != NIL && local.driver != NULL && (!isalive local.driver || local.driver.dead == 1))
				{
					if(self != NULL && self.shooter != NIL)
					{
						if(self.shooter.player_owner != NIL && self.shooter.player_owner != NULL) { local.player damage self.shooter.player_owner 9999999 self.shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
						else if(self.shooter.owner != NIL && self.shooter.owner != NULL) { local.player damage self.shooter.owner 9999999 self.shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
						else { local.player damage self.shooter 9999999 self.shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					}
					else if(local.driver.driver_shooter != NIL)
					{
						if(local.driver.driver_shooter.player_owner != NIL && local.driver.driver_shooter.player_owner != NULL) { local.player damage local.driver.driver_shooter.player_owner 9999999 local.driver.driver_shooter.player_owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
						else if(local.driver.driver_shooter.owner != NIL && local.driver.driver_shooter.owner != NULL) { local.player damage local.driver.driver_shooter.owner 9999999 local.driver.driver_shooter.owner (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
						else if(local.driver.driver_shooter != NIL && local.driver.driver_shooter != NULL) { local.player damage local.driver.driver_shooter 9999999 local.driver.driver_shooter (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
						else { local.player damage $world 9999999 $world (0 0 0) (0 0 0) (0 0 0) 0 9 9 0 }
					}

				}
			}
			else { local.player respawn }

			if(local.passenger_reattach == 1) { thread passenger_reattach local.player local.team local.targetname local.s }

			local.origin = local.player.origin
			while(local.player != NULL && !isalive local.player && local.player.dmteam != "spectator")
			{
				local.player.origin = ( local.origin[0] local.origin[1] local.player.origin[2] ) // for some reason, passengers' dead bodies would move forward across the ground until they hit a wall.
				local.player notsolid
				local.player droptofloor
				waitframe
			}
		}
	}
end

passenger_reattach local.player local.team local.targetname local.s:

	if(isalive local.player && local.player.dmteam == local.team)
	{
		local.c = 0
		while($(local.targetname) == NULL) { local.c++; waitframe } // wait until the vehicle respawns before reattaching player.
		if(local.c > 20) { end }

		if($(local.targetname) != NULL && isalive local.player && local.player.dmteam == local.team) { $(local.targetname) thread passengers local.player local.s }
	}
end

////////////////////////////////////////////////////////////////////////

spawn_driver_seat_and_trigs: // only spawn seats & triggers when needed, otherwise initializing all seats when vehicle spawns will greatly increase map's entity count.

	if(self.damagetrig != NIL && self.damagetrig != NULL) { end }
	if(self.trigshot != NIL && self.trigshot != NULL) { end }

	local.trig = spawn trigger_multiple targetname (self.targetname + "_damagetrig") spawnflags 128 // for calculating how much damage was given (triggers with health will not go to a setthread until it's fully dead).
	local.trig.origin = self.origin
	local.trig.health = self.health		// make sure triggers with health & "spawnflags 128" are slightly larger in setsizes than other "spawnflags 128" triggers,
	local.trig.vehicle = self		// otherwise the overlapping trigger that was last spawned in will have bullet-triggering priority,
	local.trig glue self			// preventing the trigger with health from taking any damage.
	self.damagetrig = local.trig
	local.trig thread removetrig
	local.trig.model = self.model	// any entities that have attachmodels on them will crash the server if those entities do not have a specified model, since there is no "Box01" to attach to;
	local.trig.scale = self.scale	// this also does not print any errors when crashing the server.
	local.trig hide

	local.trigshot = spawn trigger_multiple targetname (self.targetname + "_trigshot") spawnflags 128 // instantly determine the vehicle's shooter (runs setthread each time it's triggered).
	local.trigshot.origin = self.origin
	local.trigshot.vehicle = self
	local.trigshot glue self
	self.trigshot = local.trigshot
	local.trigshot thread removetrig
	local.trigshot setthread shottrig
	local.trigshot.model = self.model
	local.trigshot.scale = self.scale
	local.trigshot hide

	while($("driver_seat_" + self.entnum) != NULL) { $("driver_seat_" + self.entnum) remove; waitframe }
	while($("rear_view_" + self.entnum) != NULL) { $("rear_view_" + self.entnum) remove; waitframe }

	if(self.model == "models/vehicles/jeep.tik") // ( -right +left, +up -down, +forward -backward )
	{
		self attachmodel models/static/jug.tik "Box01" 1 ("driver_seat_" + self.entnum) 1 -1 -1 -1 -1 ( 24 5 -30 ) // "Box01", "Box02", or similar is determined by the model's .skc file.
		local.trig setsize ( -51 -51 -1 ) ( 51 51 101 )
		local.trigshot setsize ( -50 -50 0 ) ( 50 50 100 ) // make sure this is 1+ units smaller than the "damagetrig" in all +/- ( X Y Z ) directions.
	}
	if(self.model == "models/vehicles/jeep_bench.tik") // ( -right +left, +up -down, +forward -backward )
	{
		self attachmodel models/static/jug.tik "Box01" 1 ("driver_seat_" + self.entnum) 1 -1 -1 -1 -1 ( 24 5 -30 ) // "Box01", "Box02", or similar is determined by the model's .skc file.
		local.trig setsize ( -51 -51 -1 ) ( 51 51 106 )
		local.trigshot setsize ( -50 -50 0 ) ( 50 50 105 )
	}
	else if(self.model == "models/vehicles/bmwbike.tik") // ( -right +left, +up -down, +forward -backward )
	{
		self attachmodel models/static/jug.tik "Box02" 1 ("driver_seat_" + self.entnum) 1 -1 -1 -1 -1 ( 22 0 -14 ) 
		local.trig setsize ( -46 -46 -1 ) ( 46 46 96 )
		local.trigshot setsize ( -45 -45 0 ) ( 45 45 95 )
	}
	else if(self.model == "models/vehicles/opeltruck.tik" || self.model == "models/vehicles/opeltruckgreen.tik" || self.model == "models/vehicles/opeltruckgreen_canopy.tik") // ( -right +left, -forward +backward, +up -down )
	{
		self attachmodel models/static/jug.tik "Box01" 1 ("driver_seat_" + self.entnum) 1 -1 -1 -1 -1 ( 19.5 -40 20 )
		self attachmodel models/static/jug.tik "Box01" 1 ("rear_view_" + self.entnum) 1 -1 -1 -1 -1 ( 0 -10 20 )
		local.trig setsize ( -61 -61 -1 ) ( 61 61 156 )
		local.trigshot setsize ( -60 -60 0 ) ( 60 60 155 )
	}
	else if(self.model == "models/vehicles/sdkfz.tik" || self.model == "models/vehicles/sdkfz_afrika.tik") //( +backward -forward, +up -down, +left -right )
	{
		self attachmodel models/static/jug.tik "Box02" 1 ("driver_seat_" + self.entnum) 1 -1 -1 -1 -1 ( 50 75 4 )
		local.trig setsize ( -69 -69 -1 ) ( 69 69 146 )
		local.trigshot setsize ( -68 -68 0 ) ( 68 68 145 )
	}
	else if(self.model == "models/vehicles/mercedes.tik") //( -right +left, +up -down, +forward -backward )
	{
		self attachmodel models/static/jug.tik "Box02" 1 ("driver_seat_" + self.entnum) 1 -1 -1 -1 -1 ( 17 -10 5 )
		local.trig setsize ( -41 -41 -1 ) ( 41 41 86 )
		local.trigshot setsize ( -40 -40 0 ) ( 40 40 85 )
	}
	else if(self.model == "models/vehicles/gmctruck.tik") //( -right +left, +up -down, +forward -backward )
	{
		self attachmodel models/static/jug.tik "Box01" 1 ("driver_seat_" + self.entnum) 1 -1 -1 -1 -1 ( 16 35 56 )
		self attachmodel models/static/jug.tik "Box01" 1 ("rear_view_" + self.entnum) 1 -1 -1 -1 -1 ( 0 30 15 )
		local.trig setsize ( -57 -57 -1 ) ( 57 57 165 )
		local.trigshot setsize ( -56 -56 0 ) ( 56 56 164 )
	}
	else if(self.model == "models/vehicles/european_car_grey.tik" || self.model == "models/vehicles/european_car_silver.tik" || self.model == "models/vehicles/european_car_tan.tik") //( -right +left, +up -down, +forward -backward )
	{
		self attachmodel models/static/jug.tik "Box02" 1 ("driver_seat_" + self.entnum) 1 -1 -1 -1 -1 ( 17 2 -17 )
		local.trig setsize ( -41 -41 -1 ) ( 41 41 98 )
		local.trigshot setsize ( -40 -40 0 ) ( 40 40 97 )
	}
	else if(self.model == "models/vehicles/european_delivery_truck_green.tik" || self.model == "models/vehicles/european_delivery_truck_grey.tik" || self.model == "models/vehicles/european_delivery_truck_red3.tik") //( -right +left, +up -down, +forward -backward )
	{
		self attachmodel models/static/jug.tik "Box02" 1 ("driver_seat_" + self.entnum) 1 -1 -1 -1 -1 ( 15 -5.5 -8 )
		local.trig setsize ( -41 -41 -1 ) ( 41 41 90.5 )
		local.trigshot setsize ( -40 -40 0 ) ( 40 40 89.5 )
	}
	else if(self.model == "models/vehicles/m3.tik") //( +forward -backward, +up -down, -left +right )
	{
		self attachmodel models/static/jug.tik "Box01" 1 ("driver_seat_" + self.entnum) 1 -1 -1 -1 -1 ( 0 60 0 )
		local.trig setsize ( -61 -61 -1 ) ( 61 61 164 )
		local.trigshot setsize ( -60 -60 0 ) ( 60 60 163 )
	}
	else if(self.model == "models/vehicles/shermantank.tik") //( -right +left, +up -down, +forward -backward )
	{
		self attachmodel models/static/jug.tik "Box02" 1 ("driver_seat_" + self.entnum) 1 -1 -1 -1 -1 ( 0 75 -125 )
		local.trig setsize ( -71 -71 -1 ) ( 71 71 181 )
		local.trigshot setsize ( -70 -70 0 ) ( 70 70 180 )
	}

	if($("driver_seat_" + self.entnum) != NULL)
	{
		$("driver_seat_" + self.entnum).angles = self.angles
		$("driver_seat_" + self.entnum) bind self
		$("driver_seat_" + self.entnum).scale = 2
		$("driver_seat_" + self.entnum) show
	}
	if($("rear_view_" + self.entnum) != NULL)
	{
		$("rear_view_" + self.entnum).angles = self.angles + ( 0 180 0 )
		$("rear_view_" + self.entnum) bind self
		$("rear_view_" + self.entnum) hide
	}
end

shottrig:

	local.player = parm.other
	if(self.vehicle != NULL && (self.vehicle.driver == NIL || (self.vehicle.driver != NIL && (self.vehicle.driver.dmteam != local.player.dmteam || getcvar("g_gametype") == "1")))) { self.vehicle.shooter = local.player }
end

removetrig:

	while(self != NULL && self.vehicle != NIL && self.vehicle != NULL && self.vehicle.dead != 1 && self.vehicle.flooded != 1) { waitframe }
	if(self != NULL) { self remove }
end

////////////////////////////////////////////////////////////////////////

spawn_passenger_seat local.s: // only spawn seats when needed.

	while($("passenger_seat_" + local.s + "_" + self.entnum) != NULL) { $("passenger_seat_" + local.s + "_" + self.entnum) remove; waitframe }

	local.add = 0
	if(self.model == "models/vehicles/jeep.tik") // ( -right +left, +up -down, +forward -backward )
	{
		self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -24 5 -30 )
	}
	else if(self.model == "models/vehicles/jeep_bench.tik") // ( -right +left, +up -down, +forward -backward )
	{
		if(local.s == 1) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -24 5 -30 ) } // or -25
		if(local.s == 2) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 0 10 -80 ) }
	}
	else if(self.model == "models/vehicles/bmwbike.tik") // ( -right +left, +up -down, +forward -backward )
	{
		if(local.s == 1) { self.damagetrig attachmodel models/static/jug.tik "Box02" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -18 0 -12 ) }
		if(local.s == 2) { self.damagetrig attachmodel models/static/jug.tik "Box02" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 22 0 -44 ) }
	}
	else if(self.model == "models/vehicles/opeltruck.tik" || self.model == "models/vehicles/opeltruckgreen.tik" || self.model == "models/vehicles/opeltruckgreen_canopy.tik") // ( -right +left, -forward +backward, +up -down )
	{
		if(self.model == "models/vehicles/opeltruckgreen_canopy.tik") { local.num = 180 }
		else { local.num = 0 }
		if(local.s == 1) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -19.5 -40 20 ) }
		if(local.s == 2) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 29 22 60 ); local.add = local.num }
		if(local.s == 3) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 29 87 60 ); local.add = local.num }
		if(local.s == 4) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 29 152 60 ); local.add = local.num }
		if(local.s == 5) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -29 22 60 ); local.add = local.num }
		if(local.s == 6) { self.trigshot attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -29 87 60 ); local.add = local.num }
		if(local.s == 7) { self.trigshot attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -29 152 60 ); local.add = local.num }
	}
	else if(self.model == "models/vehicles/sdkfz.tik" || self.model == "models/vehicles/sdkfz_afrika.tik") //( +backward -forward, +up -down, +left -right )
	{
		if(local.s == 1) { self.damagetrig attachmodel models/static/jug.tik "Box02" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 10 50 22 ) }
		if(local.s == 2) { self.damagetrig attachmodel models/static/jug.tik "Box02" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 10 50 -14 ) }
		if(local.s == 3) { self.damagetrig attachmodel models/static/jug.tik "Box02" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 90 50 22 ) }
		if(local.s == 4) { self.damagetrig attachmodel models/static/jug.tik "Box02" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 90 50 -14 ) }
	}
	else if(self.model == "models/vehicles/mercedes.tik") //( -right +left, +up -down, +forward -backward )
	{
		if(local.s == 1) { self.damagetrig attachmodel models/static/jug.tik "Box02" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -17 -10 5 ) }
		if(local.s == 2) { self.damagetrig attachmodel models/static/jug.tik "Box02" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 17 -10 -47 ) }
		if(local.s == 3) { self.damagetrig attachmodel models/static/jug.tik "Box02" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -17 -10 -47 ) }
	}
	else if(self.model == "models/vehicles/gmctruck.tik") //( -right +left, +up -down, +forward -backward )
	{
		if(local.s == 1) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -16.5 35 56 ) }
		if(local.s == 2) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -26 69 -2 ); local.add = 180 }
		if(local.s == 3) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -26 69 -67 ); local.add = 180 }
		if(local.s == 4) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -26 69 -132 ); local.add = 180 }
		if(local.s == 5) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 21 69 -2 ); local.add = 180 }
		if(local.s == 6) { self.trigshot attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 21 69 -67 ); local.add = 180 }
		if(local.s == 7) { self.trigshot attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 21 69 -132 ); local.add = 180 }
	}
	else if(self.model == "models/vehicles/european_car_grey.tik" || self.model == "models/vehicles/european_car_silver.tik" || self.model == "models/vehicles/european_car_tan.tik") //( -right +left, +up -down, +forward -backward )
	{
		if(local.s == 1) { self.damagetrig attachmodel models/static/jug.tik "Box02" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -17 2 -17 ) }
		if(local.s == 2) { self.damagetrig attachmodel models/static/jug.tik "Box02" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 17 2 -73 ) }
		if(local.s == 3) { self.damagetrig attachmodel models/static/jug.tik "Box02" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -17 2 -73 ) }
	}
	else if(self.model == "models/vehicles/european_delivery_truck_green.tik" || self.model == "models/vehicles/european_delivery_truck_grey.tik" || self.model == "models/vehicles/european_delivery_truck_red3.tik") //( -right +left, +up -down, +forward -backward )
	{
		if(local.s == 1) { self.damagetrig attachmodel models/static/jug.tik "Box02" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -15 -5.5 -8 ) }
		if(local.s == 2) { self.damagetrig attachmodel models/static/jug.tik "Box02" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 15 -5.5 -72 ) }
		if(local.s == 3) { self.damagetrig attachmodel models/static/jug.tik "Box02" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -15 -5.5 -72 ) }
	}
	else if(self.model == "models/vehicles/m3.tik") // ( +forward -backward, +up -down, -left +right )
	{
		if(local.s == 1) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( 3 30 27 ) }
		if(local.s == 2) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -53 68 -38 ) }
		if(local.s == 3) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -103 68 -38 ) }
		if(local.s == 4) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -153 68 -38 ) }
		if(local.s == 5) { self.damagetrig attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -53 68 33 ) }
		if(local.s == 6) { self.trigshot attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -103 68 33 ) }
		if(local.s == 7) { self.trigshot attachmodel models/static/jug.tik "Box01" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -153 68 33 ) }
	}
	else if(self.model == "models/vehicles/shermantank.tik") //( -right +left, +up -down, +forward -backward )
	{
		self.damagetrig attachmodel models/static/jug.tik "Box02" 1 ("passenger_seat_" + local.s + "_" + self.entnum) 1 -1 -1 -1 -1 ( -24 85 -153 )
	}

	if($("passenger_seat_" + local.s + "_" + self.entnum) != NULL)
	{
		if(local.add != 0) { self.playerang_offset[local.s] = local.add }
		$("passenger_seat_" + local.s + "_" + self.entnum).angles = self.angles + ( 0 local.add 0 )
		$("passenger_seat_" + local.s + "_" + self.entnum) bind self
		$("passenger_seat_" + local.s + "_" + self.entnum) hide
	}
end

////////////////////////////////////////////////////////////////////////

rearview_adjust local.firehelding:

	self.driver unglue
	if(local.firehelding == 1) { self.driver glue $("rear_view_" + self.entnum) }
	else { self.driver glue $("driver_seat_" + self.entnum) }
end

////////////////////////////////////////////////////////////////////////

illuminate local.side:

	if(self.model == "models/vehicles/opeltruck.tik" || self.model == "models/vehicles/opeltruckgreen.tik" || self.model == "models/vehicles/opeltruckgreen_canopy.tik") { local.distance = 325; local.height = 57 } // distance = how far away from the vehicle's origin
	else if(self.model == "models/vehicles/bmwbike.tik") { local.distance = 165; local.height = 52 }
	else if(self.model == "models/vehicles/m3.tik") { local.distance = 285; local.height = 77 }
	else if(self.model == "models/vehicles/shermantank.tik") { local.distance = 145; local.height = 80.5 }
	else if(self.model == "models/vehicles/gmctruck.tik") { local.distance = 320; local.height = 72.5 }
	else if(self.model == "models/vehicles/european_car_grey.tik" || self.model == "models/vehicles/european_car_silver.tik" || self.model == "models/vehicles/european_car_tan.tik" || self.model == "models/vehicles/mercedes.tik") { local.distance = 300 }
	else { local.distance = 255 }

	if(self.model == "models/vehicles/jeep.tik" || self.model == "models/vehicles/jeep_bench.tik") { local.height = 53 }
	if(self.model == "models/vehicles/mercedes.tik") { local.height = 46.5 }
	if(self.model == "models/vehicles/european_car_grey.tik" || self.model == "models/vehicles/european_car_silver.tik" || self.model == "models/vehicles/european_car_tan.tik") { local.height = 55 }
	if(self.model == "models/vehicles/european_delivery_truck_green.tik" || self.model == "models/vehicles/european_delivery_truck_grey.tik" || self.model == "models/vehicles/european_delivery_truck_red3.tik") { local.height = 44.25 }
	if(local.height == NIL) { local.height = 55 }

	local.radius = 250
	if(self.model == "models/vehicles/bmwbike.tik") { local.radius = 175 }

	local.light = spawn script_model
	local.light model "fx/searchlight.tik"
	local.light.origin = self.origin
	local.light.scale = 0.001
	local.light notsolid
	if(local.side == "right")
	{
		local.light light .5 .5 .5 (local.radius * 2)
		local.distance += local.radius
	}
	else { local.light light 1 1 1 local.radius }

	local.origin = self.origin
	while(self != NULL && self.corona == 1 && self.dead != 1 && self.flooded != 1) // make sure the illumination stays a certain distance in front of the truck. adding the speed to the distance keeps the entity roughly in the same spot.
	{
		local.speed = sqrt ((self.origin[0] - local.origin[0]) * (self.origin[0] - local.origin[0]) + (self.origin[1] - local.origin[1]) * (self.origin[1] - local.origin[1]) + (self.origin[2] - local.origin[2]) * (self.origin[2] - local.origin[2]))
 		local.light.origin = trace (self.origin + ( 0 0 local.height )) (self.origin + ( 0 0 local.height ) + self.forwardvector * (local.distance + (local.speed * 0.55))) 0 // use trace to ensure the light doesn't go into walls when vehicle is facing walls.
		local.origin = self.origin
		waitframe
	}
	if(local.light != NULL) { local.light remove }
end

////////////////////////////////////////////////////////////////////////

deadcorona local.tag:

	if(local.tag != NIL) // opeltruck, opeltruckgreen, opeltruckgreen_canopy
	{
		local.flare = spawn script_model
		local.flare model "fx/searchlight.tik"
		local.flare.scale = 3
		local.flare notsolid
		local.flare attach self local.tag 0 ( 0 0 0 )
	}
	self.corona = 1
	local.entnum = self.entnum

	while($("headlight_1_" + local.entnum) != NULL) { waitframe } // make sure the old headlight attachmodels are removed first

	if(self != NULL && local.tag == NIL)
	{
		if(self.model == "models/vehicles/jeep.tik" || self.model == "models/vehicles/jeep_bench.tik") // simulate headlight tags for jeeps
		{
			self attachmodel models/miscobj/searchlight.tik "Box01" 0.45 ("headlight_1_" + self.entnum) 1 -1 -1 -1 -1 ( 20 53 74 ) //( -right +left, +up -down, +forward -backward )
			self attachmodel models/miscobj/searchlight.tik "Box01" 0.45 ("headlight_2_" + self.entnum) 1 -1 -1 -1 -1 ( -22 53 74 )
			self attachmodel models/static/jug.tik "Box01" 1 ("headlight_3_" + self.entnum) 1 -1 -1 -1 -1 ( 20 53 84 )
			self attachmodel models/static/jug.tik "Box01" 1 ("headlight_4_" + self.entnum) 1 -1 -1 -1 -1 ( -22 53 84 )
			$("headlight_1_" + self.entnum).angles = ( 90 0 90 )
			$("headlight_2_" + self.entnum).angles = ( 90 0 90 )
			$("headlight_3_" + self.entnum).angles = ( 0 0 180 )
			$("headlight_4_" + self.entnum).angles = ( 0 0 180 )
		}
		else if(self.model == "models/vehicles/bmwbike.tik") // simulate headlight tag for bmwbikes
		{
			self attachmodel models/miscobj/searchlight.tik "Box02" 0.365 ("headlight_1_" + self.entnum) 1 -1 -1 -1 -1 ( 22.5 52 34 ) //( -right +left, +up -down, +forward -backward )
			self attachmodel models/static/jug.tik "Box02" 0.9 ("headlight_2_" + self.entnum) 1 -1 -1 -1 -1 ( 22.5 52 42 )
			$("headlight_1_" + self.entnum).angles = ( 90 0 90 )
			$("headlight_2_" + self.entnum).angles = ( 0 0 180 )
		}
		else if(self.model == "models/vehicles/mercedes.tik") // simulate headlight tags for mercedes cars
		{
			self attachmodel models/miscobj/searchlight.tik "Box02" 0.4 ("headlight_1_" + self.entnum) 1 -1 -1 -1 -1 ( 22 46.5 98 ) //( -right +left, +up -down, +forward -backward )
			self attachmodel models/miscobj/searchlight.tik "Box02" 0.4 ("headlight_2_" + self.entnum) 1 -1 -1 -1 -1 ( -23 46.5 98 )
			self attachmodel models/static/jug.tik "Box02" 0.8 ("headlight_3_" + self.entnum) 1 -1 -1 -1 -1 ( 22 46.5 106 )
			self attachmodel models/static/jug.tik "Box02" 0.8 ("headlight_4_" + self.entnum) 1 -1 -1 -1 -1 ( -23 46.5 106 )
			$("headlight_1_" + self.entnum).angles = ( 90 0 90 )
			$("headlight_2_" + self.entnum).angles = ( 90 0 90 )
			$("headlight_3_" + self.entnum).angles = ( 0 0 180 )
			$("headlight_4_" + self.entnum).angles = ( 0 0 180 )
		}
		else if(self.model == "models/vehicles/european_car_grey.tik" || self.model == "models/vehicles/european_car_silver.tik" || self.model == "models/vehicles/european_car_tan.tik")
		{
			self attachmodel models/miscobj/searchlight.tik "Box02" 0.32 ("headlight_1_" + self.entnum) 1 -1 -1 -1 -1 ( 26 55 95.25 ) //( -right +left, +up -down, +forward -backward )
			self attachmodel models/miscobj/searchlight.tik "Box02" 0.32 ("headlight_2_" + self.entnum) 1 -1 -1 -1 -1 ( -26.5 55 95.25 )
			self attachmodel models/static/jug.tik "Box02" 0.75 ("headlight_3_" + self.entnum) 1 -1 -1 -1 -1 ( 26 55 101.25 )
			self attachmodel models/static/jug.tik "Box02" 0.75 ("headlight_4_" + self.entnum) 1 -1 -1 -1 -1 ( -26.5 55 101.25 )
			$("headlight_1_" + self.entnum).angles = ( 90 0 90 )
			$("headlight_2_" + self.entnum).angles = ( 90 0 90 )
			$("headlight_3_" + self.entnum).angles = ( 0 0 180 )
			$("headlight_4_" + self.entnum).angles = ( 0 0 180 )
		}
		else if(self.model == "models/vehicles/european_delivery_truck_green.tik" || self.model == "models/vehicles/european_delivery_truck_grey.tik" || self.model == "models/vehicles/european_delivery_truck_red3.tik")
		{
			self attachmodel models/miscobj/searchlight.tik "Box02" 0.3 ("headlight_1_" + self.entnum) 1 -1 -1 -1 -1 ( 15.75 44.25 86.5 ) //( -right +left, +up -down, +forward -backward )
			self attachmodel models/miscobj/searchlight.tik "Box02" 0.3 ("headlight_2_" + self.entnum) 1 -1 -1 -1 -1 ( -16.2 44.25 86.5 )
			self attachmodel models/static/jug.tik "Box02" 0.75 ("headlight_3_" + self.entnum) 1 -1 -1 -1 -1 ( 15.75 44.25 92 )
			self attachmodel models/static/jug.tik "Box02" 0.75 ("headlight_4_" + self.entnum) 1 -1 -1 -1 -1 ( -16.2 44.25 92 )
			$("headlight_1_" + self.entnum).angles = ( 90 0 90 )
			$("headlight_2_" + self.entnum).angles = ( 90 0 90 )
			$("headlight_3_" + self.entnum).angles = ( 0 0 180 )
			$("headlight_4_" + self.entnum).angles = ( 0 0 180 )
		}
		else if(self.model == "models/vehicles/gmctruck.tik") // simulate headlight tags for gmctrucks
		{
			self attachmodel models/miscobj/searchlight.tik "Box01" 0.32 ("headlight_1_" + self.entnum) 1 -1 -1 -1 -1 ( 26 72.5 160 ) //( -right +left, +up -down, +forward -backward )
			self attachmodel models/miscobj/searchlight.tik "Box01" 0.32 ("headlight_2_" + self.entnum) 1 -1 -1 -1 -1 ( -27.5 72.5 160 )
			self attachmodel models/static/jug.tik "Box01" 0.75 ("headlight_3_" + self.entnum) 1 -1 -1 -1 -1 ( 26 72.5 165 )
			self attachmodel models/static/jug.tik "Box01" 0.75 ("headlight_4_" + self.entnum) 1 -1 -1 -1 -1 ( -27.5 72.5 165 )
			$("headlight_1_" + self.entnum).angles = ( 90 0 90 )
			$("headlight_2_" + self.entnum).angles = ( 90 0 90 )
			$("headlight_3_" + self.entnum).angles = ( 0 0 180 )
			$("headlight_4_" + self.entnum).angles = ( 0 0 180 )
		}
		else if(self.model == "models/vehicles/m3.tik") // simulate headlight tags for m3 halftracks
		{
			self attachmodel models/miscobj/searchlight.tik "Box01" 0.3 ("headlight_1_" + self.entnum) 1 -1 -1 -1 -1 ( 125 77 25.5 ) //( +forward -backward, +up -down, -left +right )
			self attachmodel models/miscobj/searchlight.tik "Box01" 0.3 ("headlight_2_" + self.entnum) 1 -1 -1 -1 -1 ( 125 77 -29.5 )
			self attachmodel models/static/jug.tik "Box01" 0.6 ("headlight_3_" + self.entnum) 1 -1 -1 -1 -1 ( 130 77 25.5 )
			self attachmodel models/static/jug.tik "Box01" 0.6 ("headlight_4_" + self.entnum) 1 -1 -1 -1 -1 ( 130 77 -29.5 )
			$("headlight_1_" + self.entnum).angles = ( 180 0 90 )
			$("headlight_2_" + self.entnum).angles = ( 180 0 90 )
			$("headlight_3_" + self.entnum).angles = ( 90 0 180 )
			$("headlight_4_" + self.entnum).angles = ( 90 0 180 )
		}
		else if(self.model == "models/vehicles/shermantank.tik") // simulate headlight tags for shermantanks
		{
			self attachmodel models/miscobj/searchlight.tik "Box02" 0.3 ("headlight_1_" + self.entnum) 1 -1 -1 -1 -1 ( 45.8 80.5 -23 ) //( -right +left, +up -down, +forward -backward )
			self attachmodel models/miscobj/searchlight.tik "Box02" 0.3 ("headlight_2_" + self.entnum) 1 -1 -1 -1 -1 ( -45.5 80.5 -23 )
			self attachmodel models/static/jug.tik "Box02" 0.6 ("headlight_3_" + self.entnum) 1 -1 -1 -1 -1 ( 45.8 80.5 -17 )
			self attachmodel models/static/jug.tik "Box02" 0.6 ("headlight_4_" + self.entnum) 1 -1 -1 -1 -1 ( -45.5 80.5 -17 )
			$("headlight_1_" + self.entnum).angles = ( 90 0 90 )
			$("headlight_2_" + self.entnum).angles = ( 90 0 90 )
			$("headlight_3_" + self.entnum).angles = ( 0 0 180 )
			$("headlight_4_" + self.entnum).angles = ( 0 0 180 )
		}

		if(self.model == "models/vehicles/bmwbike.tik") // spawning the blinding bright white corona flares
		{
			local.flare = spawn script_model
			local.flare model fx/searchlight.tik
			local.flare.scale = 2
			local.flare attach $("headlight_2_" + self.entnum) "Box06" 0 ( 0 0 0 )
			local.flare notsolid
			self.flare1 = local.flare
		}
		else // two for each non-opeltruck vehicle, except for bmwbike
		{
			local.flare1 = spawn script_model
			local.flare1 model fx/searchlight.tik
			local.flare1.scale = 3
			local.flare1 attach $("headlight_3_" + self.entnum) "Box06" 0 ( 0 0 0 )
			local.flare1 notsolid
			local.flare2 = spawn script_model
			local.flare2 model fx/searchlight.tik
			local.flare2.scale = 3
			local.flare2 attach $("headlight_4_" + self.entnum) "Box06" 0 ( 0 0 0 )
			local.flare2 notsolid
			self.flare1 = local.flare1
			self.flare2 = local.flare2
		}
	}

	while(self != NULL && self.corona == 1 && self.dead != 1 && self.flooded != 1) { waitframe }

	if(local.flare != NIL && local.flare != NULL) { local.flare remove }
	if($("headlight_1_" + local.entnum) != NULL) { $("headlight_1_" + local.entnum) remove } // attach & attachmodels automatically get removed if self = NULL
	if($("headlight_2_" + local.entnum) != NULL) { $("headlight_2_" + local.entnum) remove }
	if($("headlight_3_" + local.entnum) != NULL) { $("headlight_3_" + local.entnum) remove }
	if($("headlight_4_" + local.entnum) != NULL) { $("headlight_4_" + local.entnum) remove }
end

////////////////////////////////////////////////////////////////////////

dummyavatar:

/*
	local.avatar = spawn func_beam
	local.avatar attach self.driver "Bip01 Head"
	local.avatar.origin = self.driver.origin + ( 0 0 100 )
	local.avatar endpoint (local.avatar.origin + ( 0 0 13 ))
	local.avatar minoffset 0.0
	local.avatar maxoffset 0.0
	local.avatar color ( 1 1 1 )
	local.avatar scale 7.0
	local.avatar life 0
	if(self.driver.dmteam == "allies") { local.avatar shader ("textures/hud/allies_headicon") }
	if(self.driver.dmteam == "axis") { local.avatar shader ("textures/hud/axis_headicon") }
	local.avatar numsegments 1
	local.avatar alpha 0.80
	local.avatar activate
	local.heightinc = 0
	if(self.model == "models/vehicles/opeltruckgreen_canopy.tik") { local.heightinc = 10 }
	if(self.model == "models/vehicles/gmctruck.tik") { local.heightinc = 40 }
*/

	local.entnum = self.entnum
	while($("driverdummy_" + local.entnum) != NULL) { waitframe } // make sure the old dummy attachmodel is removed first

	if(self != NULL)
	{
		if(self.model == "models/vehicles/m3.tik")
		{
			self attachmodel self.driver.model "Box01" 1 ("driverdummy_" + self.entnum) 1 -1 -1 -1 -1 ( 3 30 -32 ) //( +forward -backward, +up -down, -left +right )
			$("driverdummy_" + self.entnum).angles = ( 0 0 -90 )
		}
		else if(self.model != "models/vehicles/sdkfz.tik" && self.model != "models/vehicles/sdkfz_afrika.tik" && self.model != "models/vehicles/m3.tik" && self.model != "models/vehicles/shermantank.tik")
		{
			self.driver show
		}

		local.team = self.driver.dmteam
	}
/*
	while(self != NULL && isalive self.driver && self.driver.dmteam == local.team && self.driver.dead != 1 && level.change_team_score != 1 && level.bbactive != 0)
	{
		local.avatar.origin = self.driver.origin + self.upvector * (100 + local.heightinc)
		local.avatar endpoint (local.avatar.origin + ( 0 0 13 ))
		waitframe
	}
	local.avatar remove
*/
end

////////////////////////////////////////////////////////////////////////

wallstuck_fix:

	local.c = 0
	local.origin = self.origin
	local.team = self.dmteam

	if(self.wallstuck_fixing == 1) { end }
	self.wallstuck_fixing = 1

	while(self != NULL && isalive self && self.dmteam == local.team) // while player is stuck in a wall (falling) and origin isn't changing, count a few seconds, then respawn the player
	{
		if(local.c >= 60) // about 3 seconds
		{
			if((self getmovement) == falling && self.origin == local.origin) { self respawn }
			if(self.isdog == 1) { self hide }
			break
		}
		local.c++
		waitframe
	}
	if(self != NULL) { self.wallstuck_fixing = 0 }
end

////////////////////////////////////////////////////////////////////////

touching_playervehicle:

	level.touching_playervehicle = 1

	while($player.size < 1) { waitframe }
	while($player.size >= 1)
	{
		for(local.i = 1; local.i <= $player.size; local.i++)
		{
			$player[local.i].touching_playervehicle = 0 // ensures that only one vehicle needs to be touched for touching_playervehicle = 1.
		}

		for(local.a = 0; local.a <= level.drivable_entities.size; local.a++)
		{
			for(local.s = 1; $(level.drivable_entities[local.a]) != NULL && local.s <= $(level.drivable_entities[local.a]).size; local.s++) // sometimes, two vehicles with the same targetname can exist
			{													// for 1 or 2 frames. this for-loop prevents any console errors.
				for(local.i = 1; local.i <= $player.size; local.i++)
				{
					if($player[local.i] istouching $(level.drivable_entities[local.a])[local.s]) { $player[local.i].touching_playervehicle = 1 }
				}
			}
		}
		waitframe
	}

	thread touching_playervehicle
end

////////////////////////////////////////////////////////////////////////

removeclass_camera:

	level.removeclass_camera = 1
	while(1)
	{
		for(local.e = 0; local.e <= 868; local.e++)
		{
			local.entity = getentity(local.e)
			if(local.entity != NULL && local.entity.classname == "Camera" && local.entity.targetname == "") { local.entity remove }
			waitframe
		}
		waitframe
	}
end

////////////////////////////////////////////////////////////////////////

move_stuck_players:

	waitframe
	for(local.i = 1; local.i <= $player.size; local.i++)
	{
		if(isalive $player[local.i] && $player[local.i].dead != 1 && $player[local.i].dmteam != "spectator" && self != NULL && $player[local.i] istouching self)
		{
			self thread moving_stuck_players $player[local.i]
		}
	}
end

moving_stuck_players local.player:

	while(self != NULL && isalive local.player && local.player.dmteam != "spectator" && local.player istouching self)
	{
		local.player.origin += (angles_toup self.angles * 10)
		//waitframe
	}
end

////////////////////////////////////////////////////////////////////////

display:

	if(game.game != "AA") { local.menu1 = "bastogne1"; local.menu2 = "bastogne2" }
	else { local.menu1 = "dday1"; local.menu2 = "dday2" }

	self stufftext ("globalwidgetcommand " + local.menu1 + " shader townhallwindow")
	self stufftext ("globalwidgetcommand " + local.menu1 + " fgcolor 1.00 1.00 1.00 1.00")
	self stufftext ("globalwidgetcommand " + local.menu1 + " bgcolor 0.50 0.50 0.50 0.00")
	self stufftext ("globalwidgetcommand " + local.menu1 + " fadein 0")
	self stufftext ("globalwidgetcommand " + local.menu1 + " menu " + local.menu1 + " 640 480 NONE 0")
	self stufftext ("globalwidgetcommand " + local.menu1 + " virtualres 1")
	self stufftext ("globalwidgetcommand " + local.menu1 + " fullscreen 1")

	self stufftext "globalwidgetcommand june6 borderstyle NONE"
	self stufftext "globalwidgetcommand june6 shader textures/hud/healthback"
	self stufftext "globalwidgetcommand june6 rect 16 420 16 64"
	self stufftext "globalwidgetcommand june6 fgcolor 1.00 1.00 1.00 1.00"
	self stufftext "globalwidgetcommand june6 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand june6 linkcvar phealth"
	self stufftext "globalwidgetcommand june6 statbar vertical 0 100"
	self stufftext "globalwidgetcommand june6 statbar_shader textures/hud/healthmeter"
	self stufftext "globalwidgetcommand june6 statbar_shader_flash textures/hud/healthmeterflash"

	self stufftext ("globalwidgetcommand " + local.menu2 + " fgcolor 1.00 1.00 1.00 1.00")
	self stufftext ("globalwidgetcommand " + local.menu2 + " bgcolor 0.50 0.50 0.50 0.00")
	self stufftext ("globalwidgetcommand " + local.menu2 + " fadein 0")
	self stufftext ("globalwidgetcommand " + local.menu2 + " menu " + local.menu2 + " 640 480 NONE 0")
	self stufftext ("globalwidgetcommand " + local.menu2 + " virtualres 1")
	self stufftext ("globalwidgetcommand " + local.menu2 + " fullscreen 1")

	self stufftext "globalwidgetcommand charliesector borderstyle NONE"
	self stufftext "globalwidgetcommand charliesector textalign left "
	self stufftext "globalwidgetcommand charliesector rect 40 470 150 20"
	self stufftext "globalwidgetcommand charliesector fgcolor 0.70 0.60 0.05 1.00"
	self stufftext "globalwidgetcommand charliesector bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand charliesector linkcvar phealth"
	self stufftext "globalwidgetcommand charliesector font facfont-20"
	self stufftext "globalwidgetcommand charliesector shader townhallwindow"

	self stufftext ("showmenu " + local.menu2)
	self stufftext ("showmenu " + local.menu1)
	self stufftext ("set phealth " + int(self.health))
end

////////////////////////////////////////////////////////////////////////

vehicle_settings local.gotout:

	// if model == jeep, jeep_bench, mercedes, or gmctruck, keep desmodel = current model
	switch(self.model)
	{
		case "models/vehicles/jeep.tik":
			self.seats = 1 // [1] = front passenger, not including driver's seat.
			self.desmodel = NIL
			self.spawndeathfire = 1
			self.outheight = 56 // all players in vehicle
			self.outforward = 0 // driver only
			self turnrate 10
			self.turningrate = 10.000 // keep at least 3 decimals for better turnrate accuracy.
			if(level.vehiclescriptmaster[self.model] != 1) { cache models/vehicles/jeep_30cal.tik; cache models/vehicles/jeep_30cal_viewmodel.tik }
			if(local.gotout == 1) { self playsound jeep_snd_stop }
			break

		case "models/vehicles/jeep_bench.tik":
			self.seats = 2 // [1] = front passenger, [2] = back seat (30cal spot)
			self.desmodel = NIL
			self.spawndeathfire = 1
			self.outheight = 56
			self.outforward = 0
			self turnrate 10
			self.turningrate = 10.000
			if(local.gotout == 1) { self playsound jeep_snd_stop }
			break

		case "models/vehicles/bmwbike.tik":
			self.seats = 2 // [1] = side car seat, [2] = behind driver
			self.desmodel = models/vehicles/bmwbike_d.tik
			self.spawndeathfire = 1
			self.outheight = 51
			self.outforward = 0
			self turnrate 13
			self.turningrate = 13.000
			if(local.gotout == 1) { self playsound jeep_snd_stop }
			break

		case "models/vehicles/opeltruck.tik":
			self.seats = 7 // [1] = front passenger, [2] & [3] & [4] = left side rear passengers, [5] & [6] & [7] = right side rear passengers
			self.desmodel = models/vehicles/opeltruck_d.tik
			self.spawndeathfire = 0
			self.outheight = 41
			self.outforward = 0
			self turnrate 8
			self.turningrate = 8.000
			if(local.gotout == 1) { self playsound opeltruck_snd_stop }
			break

		case "models/vehicles/opeltruckgreen.tik":
			self.seats = 7 // [1] = front passenger, [2] & [3] & [4] = left side rear passengers, [5] & [6] & [7] = right side rear passengers
			self.desmodel = models/vehicles/opeltruckgreen_d.tik
			self.spawndeathfire = 1
			self.outheight = 41
			self.outforward = 0
			self turnrate 8
			self.turningrate = 8.000
			if(local.gotout == 1) { self playsound opeltruck_snd_stop }
			break

		case "models/vehicles/opeltruckgreen_canopy.tik":
			self.seats = 7 // [1] = front passenger, [2] & [3] & [4] = left side rear passengers, [5] & [6] & [7] = right side rear passengers
			self.desmodel = models/vehicles/opeltruckgreen_d.tik
			self.spawndeathfire = 1
			self.outheight = 41
			self.outforward = 0
			self turnrate 8
			self.turningrate = 8.000
			if(local.gotout == 1) { self playsound opeltruck_snd_stop }
			break

		case "models/vehicles/sdkfz.tik":
			self.seats = 4 // [1] & [2] = left side rear passengers, [3] & [4] = right side rear passengers
			self.desmodel = models/vehicles/sdkfz_green_d.tik
			self.spawndeathfire = 0
			self.outheight = 1
			self.outforward = 125
			self turnrate 8
			self.turningrate = 8.000
			self.noheadlights = 1
			self.nohorn = 1
			if(level.vehiclescriptmaster[self.model] != 1) { cache models/vehicles/jeep_30cal.tik; cache models/vehicles/jeep_30cal_viewmodel.tik; cache models/vehicles/sdkfz_shield.tik }
			if(local.gotout == 1) { self playsound sdkfz_snd_stop }
			break

		case "models/vehicles/sdkfz_afrika.tik":
			self.seats = 4 // [1] & [2] = left side rear passengers, [3] & [4] = right side rear passengers
			self.desmodel = models/vehicles/sdkfz_desert_d.tik
			self.spawndeathfire = 0
			self.outheight = 1
			self.outforward = 125
			self turnrate 8
			self.turningrate = 8.000
			self.noheadlights = 1
			self.nohorn = 1
			if(level.vehiclescriptmaster[self.model] != 1) { cache models/vehicles/jeep_30cal.tik; cache models/vehicles/jeep_30cal_viewmodel.tik; cache models/vehicles/sdkfz_shield.tik }
			if(local.gotout == 1) { self playsound sdkfz_snd_stop }
			break

		case "models/vehicles/mercedes.tik":
			self.seats = 3 // [1] = front passenger, [2] = behind driver seat, [3] = behind front passenger
			self.desmodel = NIL
			self.spawndeathfire = 1
			self.outheight = 101
			self.outforward = 0
			self turnrate 10
			self.turningrate = 10.000
			if(local.gotout == 1) { self playsound jeep_snd_stop }
			break

		case "models/vehicles/gmctruck.tik":
			self.seats = 7 // [1] = front passenger, [2] & [3] & [4] = left side rear passengers, [5] & [6] & [7] = right side rear passengers
			self.desmodel = NIL
			self.spawndeathfire = 1
			self.outheight = 55
			self.outforward = 0
			self turnrate 8
			self.turningrate = 8.000
			if(local.gotout == 1) { self playsound opeltruck_snd_stop }
			break

		case "models/vehicles/european_car_grey.tik":
			self.seats = 3 // [1] = front passenger, [2] = behind driver seat, [3] = behind front passenger
			self.desmodel = models/static/vehicle_car_rusted.tik
			self.spawndeathfire = 1
			self.outheight = 100
			self.outforward = 0
			self turnrate 10
			self.turningrate = 10.000
			if(local.gotout == 1) { self playsound jeep_snd_stop }
			break

		case "models/vehicles/european_car_silver.tik":
			self.seats = 3 // [1] = front passenger, [2] = behind driver seat, [3] = behind front passenger
			self.desmodel = models/static/vehicle_car_rusted.tik
			self.spawndeathfire = 1
			self.outheight = 100
			self.outforward = 0
			self turnrate 10
			self.turningrate = 10.000
			if(local.gotout == 1) { self playsound jeep_snd_stop }
			break

		case "models/vehicles/european_car_tan.tik":
			self.seats = 3 // [1] = front passenger, [2] = behind driver seat, [3] = behind front passenger
			self.desmodel = models/static/vehicle_car_burnt.tik
			self.spawndeathfire = 1
			self.outheight = 100
			self.outforward = 0
			self turnrate 10
			self.turningrate = 10.000
			if(local.gotout == 1) { self playsound jeep_snd_stop }
			break

		case "models/vehicles/european_delivery_truck_green.tik":
			self.seats = 3 // [1] = front passenger, [2] = behind driver seat, [3] = behind front passenger
			self.desmodel = models/static/vehicle_dtruck_burnt.tik
			self.spawndeathfire = 1
			self.outheight = 108
			self.outforward = 0
			self turnrate 10
			self.turningrate = 10.000
			if(local.gotout == 1) { self playsound jeep_snd_stop }
			break

		case "models/vehicles/european_delivery_truck_grey.tik":
			self.seats = 3 // [1] = front passenger, [2] = behind driver seat, [3] = behind front passenger
			self.desmodel = models/static/vehicle_dtruck_burnt.tik
			self.spawndeathfire = 1
			self.outheight = 108
			self.outforward = 0
			self turnrate 10
			self.turningrate = 10.000
			if(local.gotout == 1) { self playsound jeep_snd_stop }
			break

		case "models/vehicles/european_delivery_truck_red3.tik":
			self.seats = 3 // [1] = front passenger, [2] = behind driver seat, [3] = behind front passenger
			self.desmodel = models/static/vehicle_dtruck_rusted.tik
			self.spawndeathfire = 1
			self.outheight = 108
			self.outforward = 0
			self turnrate 10
			self.turningrate = 10.000
			if(local.gotout == 1) { self playsound jeep_snd_stop }
			break

		case "models/vehicles/m3.tik":
			self.seats = 7 // [1] = front passenger, [2] & [3] & [4] = left side rear passengers, [5] & [6] & [7] = right side rear passengers
			self.desmodel = NIL
			self.spawndeathfire = 1
			self.outheight = 50
			self.outforward = 0
			self turnrate 8
			self.turningrate = 8.000
			if(local.gotout == 1) { self playsound sdkfz_snd_stop }
			break

		case "models/vehicles/shermantank.tik":
			self.seats = 1 // [1] = tank's port hole
			self.desmodel = models/vehicles/shermantank_damaged.tik
			self.spawndeathfire = 1
			self.outheight = 54
			self.outforward = 0
			self turnrate 8
			self.turningrate = 8.000
			self.nohorn = 1
			if(local.gotout == 1) { self playsound sdkfz_snd_stop }
			break

		default:
			self.seats = 0
			self.desmodel = NIL
			self.spawndeathfire = 1
			self.outheight = 100
			self.outforward = 0
			self turnrate 10
			self.turningrate = 10.000
			if(local.gotout == 1) { self playsound jeep_snd_stop }
			break
	}

	self.gun = self queryturretslotentity 0
	if(self.gun != NIL && self.gun != NULL)
	{
		self.gun notsolid
		self.gun pitchcaps ( -60 35 0 )
		if(self.model != "models/vehicles/jeep.tik") { self.gun.scale = 0.5 }
	}

	if(self.model == "models/vehicles/sdkfz.tik" || self.model == "models/vehicles/sdkfz_afrika.tik")
	{
		self attachmodel models/vehicles/sdkfz_shield.tik "Box02" 1 ("shielddummy_" + self.entnum) 1 -1 -1 -1 -1 ( -42 106 4.25 ) //( +backward -forward, +up -down, +left -right )
		$("shielddummy_" + self.entnum).angles = ( 180 0 -90 )

		if(self.gun != NIL && self.gun != NULL && self.gun.model == "models/vehicles/jeep_30cal.tik")
		{
			self attachmodel models/static/jug.tik "Box02" 1 ("turretglue_" + self.entnum) 1 -1 -1 -1 -1 ( -30 106 4 ) //( +backward -forward, +up -down, +left -right )
			$("turretglue_" + self.entnum).angles = self.angles
			$("turretglue_" + self.entnum) bind self
			$("turretglue_" + self.entnum) hide
			self.gun glue $("turretglue_" + self.entnum) // move the bottom of the turret down onto the vehicle's roof.
		}
	}

	if(level.vehiclescriptmaster[self.model] != 1) // this only runs once
	{
		cache self.model
		if(self.desmodel != NIL) { cache self.desmodel }
		if(self.spawndeathfire == 1) { cache models/emitters/fancyfire.tik; cache models/emitters/linger_smoke.tik }
		cache models/emitters/mortar_higgins.tik
		cache models/emitters/mortar_dirt_nosound.tik
		cache models/fx/searchlight.tik
		cache models/miscobj/searchlight.tik
		cache models/static/jug.tik
		thread scriptmaster self.model
		level.vehiclescriptmaster[self.model] = 1
	}
end

////////////////////////////////////////////////////////////////////////

scriptmaster local.model:

level.mapname = getcvar "mapname"
local.master = spawn scriptmaster

if(local.model == "models/vehicles/opeltruck.tik" || local.model == "models/vehicles/opeltruckgreen.tik" || local.model == "models/vehicles/opeltruckgreen_canopy.tik" || local.model == "models/vehicles/gmctruck.tik")
{
	local.soundtype = 1
}
else if(local.model == "models/vehicles/sdkfz.tik" || local.model == "models/vehicles/sdkfz_afrika.tik" || local.model == "models/vehicles/m3.tik" || local.model == "models/vehicles/shermantank.tik")
{
	local.soundtype = 2
}
else { local.soundtype = 3 }

if(level.vehiclescriptmaster[local.soundtype] != NIL) { end }
level.vehiclescriptmaster[local.soundtype] = 1

if(local.soundtype == 2 && level.mapname != "training" && level.mapname != "m3l3" && level.mapname != "m5l2a")
{
	local.master aliascache sdkfz_snd_idle sound/vehicle/veh_track_idle.wav soundparms .5 0 1 0 800 4000 auto loaded maps level.mapname
}

if(local.soundtype == 1 && level.mapname != "m1l2a" && level.mapname != "m1l2b" && level.mapname != "m1l3b" && level.mapname != "m1l3c" && level.mapname != "m4l0" && level.mapname != "m4l1" && level.mapname != "m4l2" && level.mapname != "m4l3")
{
	local.master aliascache opeltruck_snd_idle sound/vehicle/veh_truck_idle.wav soundparms .7 0 1 0 300 7000 auto loaded maps level.mapname
	local.master aliascache opeltruck_snd_run sound/vehicle/veh_truck_move.wav soundparms 1.2 0 1 0 600 4000 auto loaded maps level.mapname
	local.master aliascache opeltruck_snd_revup sound/vehicle/veh_truck_revup.wav soundparms 1 0 1 0 100 4000 auto loaded maps level.mapname
	local.master aliascache opeltruck_snd_revdown sound/vehicle/veh_truck_revdown.wav soundparms 1 0 1 0 100 4000 auto loaded maps level.mapname
	local.master aliascache opeltruck_snd_shift1 sound/vehicle/veh_truck_shiftin.wav soundparms 1 0 1 0 200 4000 auto loaded maps level.mapname
	local.master aliascache opeltruck_snd_shift2 sound/vehicle/veh_truck_shiftout.wav soundparms 1 0 1 0 200 4000 auto loaded maps level.mapname
	local.master aliascache opeltruck_snd_on sound/vehicle/veh_truck_on.wav soundparms 1 0 1 0 100 4000 auto loaded maps level.mapname
	local.master aliascache opeltruck_snd_start sound/vehicle/veh_truck_on.wav soundparms 1 0 1 0 100 4000 auto loaded maps level.mapname
	local.master aliascache opeltruck_snd_off sound/vehicle/veh_truck_off.wav soundparms 1 0 1 0 100 4000 auto loaded maps level.mapname
	local.master aliascache opeltruck_snd_stop sound/vehicle/veh_truck_off.wav soundparms 1 0 1 0 100 4000 auto loaded maps level.mapname
	local.master aliascache opeltruck_tread_snd_dirt sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 600 4000 auto loaded maps level.mapname
	local.master aliascache opeltruck_tread_snd_stone sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 600 4000 auto loaded maps level.mapname
	local.master aliascache opeltruck_tread_snd_grass sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 600 4000 auto loaded maps level.mapname
	local.master aliascache opeltruck_tread_snd_wood sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 600 4000 auto loaded maps level.mapname
	local.master aliascache opeltruck_tread_snd_mud sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 600 4000 auto loaded maps level.mapname
	local.master aliascache opeltruck_snd_doorclose sound/mechanics/DoorJeepClose_02.wav soundparms 1 0 1 0 400 4000 auto loaded maps level.mapname
	local.master aliascache opeltruck_snd_dooropen sound/mechanics/DoorJeepOpen_01.wav soundparms 1 0 1 0 400 4000 auto loaded maps level.mapname
}

if(local.soundtype == 1 && level.mapname != "m1l3b" && level.mapname != "m1l3c" && level.mapname != "m4l0" && level.mapname != "m4l1" && level.mapname != "m4l2" && level.mapname != "m4l3")
{
	local.master aliascache opeltruck_vehicle_crash1 sound/null.wav soundparms .7 .4 1 .5 100 1600 auto loaded maps level.mapname
}

if(local.soundtype == 2 && level.mapname != "m3l3" && level.mapname != "m5l2a")
{
	local.master aliascache sdkfz_snd_run sound/vehicle/veh_track_move.wav soundparms 1.5 0 1 0 1000 6000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_revup sound/vehicle/veh_track_revup.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_revdown sound/vehicle/veh_track_revdown.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_shift1 sound/vehicle/veh_track_shiftin.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_shift2 sound/vehicle/veh_track_shiftout.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_on sound/vehicle/veh_track_on.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_start sound/vehicle/veh_track_on.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_off sound/vehicle/veh_track_off.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_stop sound/vehicle/veh_track_off.wav soundparms 1.5 0 1 0 1000 6000 auto loaded maps level.mapname
	local.master aliascache sdkfz_tread_snd_dirt sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_tread_snd_stone sound/vehicle/veh_tread_metal.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_tread_snd_grass sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_tread_snd_wood sound/vehicle/veh_tread_metal.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_tread_snd_mud sound/vehicle/veh_tread_grass.wav soundparms .25 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_doorclose sound/null.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache sdkfz_snd_dooropen sound/null.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
}

if(local.soundtype == 3 && level.mapname != "m1l2b" && level.mapname != "m1l3a" && level.mapname != "m1l3b")
{
	local.master aliascache jeep_snd_idle sound/vehicle/veh_jeep_idle.wav soundparms .5 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache jeep_snd_run sound/vehicle/veh_jeep_move.wav soundparms .8 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache jeep_snd_revup sound/vehicle/veh_jeep_start.wav soundparms 1.2 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache jeep_snd_revdown sound/vehicle/veh_jeep_revdown.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache jeep_tread_snd_stone sound/vehicle/veh_tread_grass.wav soundparms .28 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache jeep_snd_off sound/vehicle/veh_jeep_off.wav soundparms 1.5 0 1 0 800 4000 auto loaded maps level.mapname
}

if(local.soundtype == 3 && level.mapname != "m1l3a" && level.mapname != "m1l3b")
{
	local.master aliascache jeep_snd_shift1 sound/vehicle/veh_jeep_shiftin.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache jeep_snd_shift2 sound/vehicle/veh_jeep_shiftout.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache jeep_tread_snd_dirt sound/vehicle/veh_tread_grass.wav soundparms .28 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache jeep_tread_snd_grass sound/vehicle/veh_tread_grass.wav soundparms .28 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache jeep_tread_snd_wood sound/vehicle/veh_tread_grass.wav soundparms .28 0 1 0 800 4000 auto loaded maps level.mapname
	local.master aliascache jeep_tread_snd_mud sound/vehicle/veh_tread_grass.wav soundparms 2.8 0 1 0 800 4000 auto loaded maps level.mapname
}

if(level.vehiclescriptmaster2 != 1 && level.mapname != "m1l2b" && level.mapname != "m1l3a" && level.mapname != "m1l3b")
{
	local.master aliascache jeep_snd_stop sound/vehicle/veh_jeep_off.wav soundparms 1.5 0 1 0 800 4000 auto loaded maps level.mapname
}

if(local.soundtype == 3)
{
	if(level.mapname != "m1l2b" && level.mapname != "m1l3a")
	{
		local.master aliascache jeep_snd_on sound/vehicle/veh_jeep_start.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname
		local.master aliascache jeep_snd_start sound/vehicle/veh_jeep_on.wav soundparms 1 0 1 0 800 4000 auto loaded maps level.mapname

		if(level.mapname != "m1l3b" && level.mapname != "m1l3c")
		{
			local.master aliascache jeep_snd_doorclose sound/mechanics/DoorJeepClose_02.wav soundparms 1.2 0 1 0 800 4000 auto loaded maps level.mapname
		}
	}
	local.master aliascache jeep_snd_dooropen sound/mechanics/DoorJeepOpen_01.wav soundparms 1 0 1 0 400 4000 auto loaded maps level.mapname // this alias was never added to original ubersound.scr
}

if(level.vehiclescriptmaster2 != 1 && level.mapname[2] == "/" || level.mapname[3] == "/")
{
	local.master aliascache jeep_vehicle_crash sound/null.wav soundparms .7 .4 1 .5 100 1600 auto loaded maps level.mapname
}

if(local.soundtype == 2 && level.mapname != "m3l3" && level.mapname != "m5l2a" && level.mapname != "m5l2b")
{
	local.master aliascache sdkfz_vehicle_crash1 sound/null.wav soundparms .7 .4 1 .5 100 1600 auto loaded maps level.mapname
}

if(level.vehiclescriptmaster2 != 1 && level.mapname != "m1l3a" && level.mapname != "m1l3b" && level.mapname != "m4l1")
{
	local.master aliascache explode_truck1 sound/weapons/explo/Explo_MetalMed1.wav soundparms 1.2 .2 .8 .2 1500 8000 weapon loaded maps level.mapname
}

if(level.vehiclescriptmaster2 != 1 && level.mapname != "m1l3a" && level.mapname != "m1l3b")
{
	local.master aliascache explode_truck2 sound/weapons/explo/Explo_MetalMed2.wav soundparms 1.2 .2 .8 .2 1500 8000 weapon loaded maps level.mapname
	local.master aliascache explode_truck3 sound/weapons/explo/Explo_MetalMed3.wav soundparms 1.2 .2 .8 .2 1500 8000 weapon loaded maps level.mapname
	local.master aliascache explode_truck4 sound/weapons/explo/Explo_MetalMed4.wav soundparms 1.2 .2 .8 .2 1500 8000 weapon loaded maps level.mapname
	local.master aliascache explode_truck5 sound/weapons/explo/Explo_MetalMed5.wav soundparms 1.2 .2 .8 .2 1500 8000 weapon loaded maps level.mapname
}

if(level.vehiclescriptmaster2 != 1 && level.mapname != "m5l1a" && level.mapname != "m5l1b" && level.mapname != "m5l2a" && level.mapname != "m5l2b" && level.mapname != "m5l3")
{
	local.master aliascache damage_vehicle1 sound/null.wav soundparms .7 .4 .9 .2 160 1600 auto loaded maps level.mapname
}

if(level.vehiclescriptmaster2 != 1 && local.soundtype != 2)
{	
	local.master aliascache horntruck sound/vehicle/horn.wav soundparms 1.5 0 1 0 800 6000 auto loaded maps level.mapname
	local.master aliascache horncar sound/vehicle/horn.wav soundparms 1.25 0 1.35 0 800 6000 auto loaded maps level.mapname
	local.master aliascache hornbike sound/vehicle/horn.wav soundparms 1 0 1.9 0 800 6000 auto loaded maps level.mapname
}

if(level.vehiclescriptmaster2 != 1 && level.scriptmaster[truck_sounds] != 1 && level.scriptmaster[light_switch] != 1 && local.soundtype != 2)
{	
	local.master aliascache light_switch sound/items/hit_notify.wav soundparms 1.5 0 1 0 320 2200 auto loaded maps level.mapname	
}

if(level.vehiclescriptmaster3 != 1)
{
	local.master aliascache sndfire30cal sound/weapons/fire/50CalFire2.wav soundparms 1.05 .2 .95 .1 800 4000 weapon loaded maps level.mapname

	local.master aliascache vehicledeathfire sound/amb/fire.wav soundparms 1.2 0.0 1.0 0.0 200 2000 auto loaded maps level.mapname
	local.master aliascache vehicledeathwater sound/mechanics/Mec_WaterLoop_03.wav soundparms 1.2 0.0 1.0 0.0 200 2000 auto loaded maps level.mapname
}

level.vehiclescriptmaster2 = 1
level.vehiclescriptmaster3 = 1
end
